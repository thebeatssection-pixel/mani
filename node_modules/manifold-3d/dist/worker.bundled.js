var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/property-graph/dist/property-graph.modern.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var EventDispatcher, GraphEdge, Graph, RefList, RefSet, RefMap, $attributes, $immutableKeys, GraphNode;
var init_property_graph_modern = __esm({
  "node_modules/property-graph/dist/property-graph.modern.js"() {
    EventDispatcher = class {
      constructor() {
        this._listeners = {};
      }
      addEventListener(type, listener) {
        const listeners = this._listeners;
        if (listeners[type] === void 0) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
        return this;
      }
      removeEventListener(type, listener) {
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          const index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
        return this;
      }
      dispatchEvent(event) {
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== void 0) {
          const array = listenerArray.slice(0);
          for (let i = 0, l = array.length; i < l; i++) {
            array[i].call(this, event);
          }
        }
        return this;
      }
      dispose() {
        for (const key in this._listeners) {
          delete this._listeners[key];
        }
      }
    };
    GraphEdge = class {
      constructor(_name, _parent, _child, _attributes = {}) {
        this._name = void 0;
        this._parent = void 0;
        this._child = void 0;
        this._attributes = void 0;
        this._disposed = false;
        this._name = _name;
        this._parent = _parent;
        this._child = _child;
        this._attributes = _attributes;
        if (!_parent.isOnGraph(_child)) {
          throw new Error("Cannot connect disconnected graphs.");
        }
      }
      /** Name (attribute name from parent {@link GraphNode}). */
      getName() {
        return this._name;
      }
      /** Owner node. */
      getParent() {
        return this._parent;
      }
      /** Resource node. */
      getChild() {
        return this._child;
      }
      /**
       * Sets the child node.
       *
       * @internal Only {@link Graph} implementations may safely call this method directly. Use
       * 	{@link Property.swap} or {@link Graph.swapChild} instead.
       */
      setChild(child) {
        this._child = child;
        return this;
      }
      /** Attributes of the graph node relationship. */
      getAttributes() {
        return this._attributes;
      }
      /** Destroys a (currently intact) edge, updating both the graph and the owner. */
      dispose() {
        if (this._disposed) return;
        this._parent._destroyRef(this);
        this._disposed = true;
      }
      /** Whether this link has been destroyed. */
      isDisposed() {
        return this._disposed;
      }
    };
    Graph = class extends EventDispatcher {
      constructor(...args) {
        super(...args);
        this._emptySet = /* @__PURE__ */ new Set();
        this._edges = /* @__PURE__ */ new Set();
        this._parentEdges = /* @__PURE__ */ new Map();
        this._childEdges = /* @__PURE__ */ new Map();
      }
      /** Returns a list of all parent->child edges on this graph. */
      listEdges() {
        return Array.from(this._edges);
      }
      /** Returns a list of all edges on the graph having the given node as their child. */
      listParentEdges(node) {
        return Array.from(this._childEdges.get(node) || this._emptySet);
      }
      /** Returns a list of parent nodes for the given child node. */
      listParents(node) {
        const parentSet = /* @__PURE__ */ new Set();
        for (const edge of this.listParentEdges(node)) {
          parentSet.add(edge.getParent());
        }
        return Array.from(parentSet);
      }
      /** Returns a list of all edges on the graph having the given node as their parent. */
      listChildEdges(node) {
        return Array.from(this._parentEdges.get(node) || this._emptySet);
      }
      /** Returns a list of child nodes for the given parent node. */
      listChildren(node) {
        const childSet = /* @__PURE__ */ new Set();
        for (const edge of this.listChildEdges(node)) {
          childSet.add(edge.getChild());
        }
        return Array.from(childSet);
      }
      disconnectParents(node, filter) {
        for (const edge of this.listParentEdges(node)) {
          if (!filter || filter(edge.getParent())) {
            edge.dispose();
          }
        }
        return this;
      }
      /**********************************************************************************************
       * Internal.
       */
      /**
       * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned
       * for the caller to store.
       * @param a Owner
       * @param b Resource
       * @hidden
       * @internal
       */
      _createEdge(name, a, b, attributes) {
        const edge = new GraphEdge(name, a, b, attributes);
        this._edges.add(edge);
        const parent = edge.getParent();
        if (!this._parentEdges.has(parent)) this._parentEdges.set(parent, /* @__PURE__ */ new Set());
        this._parentEdges.get(parent).add(edge);
        const child = edge.getChild();
        if (!this._childEdges.has(child)) this._childEdges.set(child, /* @__PURE__ */ new Set());
        this._childEdges.get(child).add(edge);
        return edge;
      }
      /**
       * Detaches a {@link GraphEdge} from the {@link Graph}. Before calling this
       * method, ensure that the GraphEdge has first been detached from any
       * associated {@link GraphNode} attributes.
       * @hidden
       * @internal
       */
      _destroyEdge(edge) {
        this._edges.delete(edge);
        this._parentEdges.get(edge.getParent()).delete(edge);
        this._childEdges.get(edge.getChild()).delete(edge);
        return this;
      }
    };
    RefList = class {
      constructor(refs) {
        this.list = [];
        if (refs) {
          for (const ref of refs) {
            this.list.push(ref);
          }
        }
      }
      add(ref) {
        this.list.push(ref);
      }
      remove(ref) {
        const index = this.list.indexOf(ref);
        if (index >= 0) this.list.splice(index, 1);
      }
      removeChild(child) {
        const refs = [];
        for (const ref of this.list) {
          if (ref.getChild() === child) {
            refs.push(ref);
          }
        }
        for (const ref of refs) {
          this.remove(ref);
        }
        return refs;
      }
      listRefsByChild(child) {
        const refs = [];
        for (const ref of this.list) {
          if (ref.getChild() === child) {
            refs.push(ref);
          }
        }
        return refs;
      }
      values() {
        return this.list;
      }
    };
    RefSet = class {
      constructor(refs) {
        this.set = /* @__PURE__ */ new Set();
        this.map = /* @__PURE__ */ new Map();
        if (refs) {
          for (const ref of refs) {
            this.add(ref);
          }
        }
      }
      add(ref) {
        const child = ref.getChild();
        this.removeChild(child);
        this.set.add(ref);
        this.map.set(child, ref);
      }
      remove(ref) {
        this.set.delete(ref);
        this.map.delete(ref.getChild());
      }
      removeChild(child) {
        const ref = this.map.get(child) || null;
        if (ref) this.remove(ref);
        return ref;
      }
      getRefByChild(child) {
        return this.map.get(child) || null;
      }
      values() {
        return Array.from(this.set);
      }
    };
    RefMap = class {
      constructor(map) {
        this.map = {};
        if (map) {
          Object.assign(this.map, map);
        }
      }
      set(key, child) {
        this.map[key] = child;
      }
      delete(key) {
        delete this.map[key];
      }
      get(key) {
        return this.map[key] || null;
      }
      keys() {
        return Object.keys(this.map);
      }
      values() {
        return Object.values(this.map);
      }
    };
    $attributes = Symbol("attributes");
    $immutableKeys = Symbol("immutableKeys");
    GraphNode = class _GraphNode extends EventDispatcher {
      /**
       * Internal graph used to search and maintain references.
       * @hidden
       */
      /**
       * Attributes (literal values and GraphNode references) associated with this instance. For each
       * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are
       * stored as arrays and dictionaries of edges.
       * @internal
       */
      /**
       * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be
       * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the
       * properties will be disposed with the parent GraphNode.
       *
       * Currently, only single-edge references (getRef/setRef) are supported as immutables.
       *
       * @internal
       */
      constructor(graph) {
        super();
        this._disposed = false;
        this.graph = void 0;
        this[$attributes] = void 0;
        this[$immutableKeys] = void 0;
        this.graph = graph;
        this[$immutableKeys] = /* @__PURE__ */ new Set();
        this[$attributes] = this._createAttributes();
      }
      /**
       * Returns default attributes for the graph node. Subclasses having any attributes (either
       * literal values or references to other graph nodes) must override this method. Literal
       * attributes should be given their default values, if any. References should generally be
       * initialized as empty (Ref → null, RefList → [], RefMap → {}) and then modified by setters.
       *
       * Any single-edge references (setRef) returned by this method will be considered immutable,
       * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,
       * setRefMap) cannot be returned as default attributes.
       */
      getDefaults() {
        return {};
      }
      /**
       * Constructs and returns an object used to store a graph nodes attributes. Compared to the
       * default Attributes interface, this has two distinctions:
       *
       * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>
       * 2. GraphNode<T> objects provided as defaults are considered immutable
       *
       * @internal
       */
      _createAttributes() {
        const defaultAttributes = this.getDefaults();
        const attributes = {};
        for (const key in defaultAttributes) {
          const value2 = defaultAttributes[key];
          if (value2 instanceof _GraphNode) {
            const ref = this.graph._createEdge(key, this, value2);
            this[$immutableKeys].add(key);
            attributes[key] = ref;
          } else {
            attributes[key] = value2;
          }
        }
        return attributes;
      }
      /** @internal Returns true if two nodes are on the same {@link Graph}. */
      isOnGraph(other) {
        return this.graph === other.graph;
      }
      /** Returns true if the node has been permanently removed from the graph. */
      isDisposed() {
        return this._disposed;
      }
      /**
       * Removes both inbound references to and outbound references from this object. At the end
       * of the process the object holds no references, and nothing holds references to it. A
       * disposed object is not reusable.
       */
      dispose() {
        if (this._disposed) return;
        this.graph.listChildEdges(this).forEach((edge) => edge.dispose());
        this.graph.disconnectParents(this);
        this._disposed = true;
        this.dispatchEvent({
          type: "dispose"
        });
      }
      /**
       * Removes all inbound references to this object. At the end of the process the object is
       * considered 'detached': it may hold references to child resources, but nothing holds
       * references to it. A detached object may be re-attached.
       */
      detach() {
        this.graph.disconnectParents(this);
        return this;
      }
      /**
       * Transfers this object's references from the old node to the new one. The old node is fully
       * detached from this parent at the end of the process.
       *
       * @hidden
       */
      swap(prevValue, nextValue) {
        for (const attribute in this[$attributes]) {
          const value2 = this[$attributes][attribute];
          if (value2 instanceof GraphEdge) {
            const ref = value2;
            if (ref.getChild() === prevValue) {
              this.setRef(attribute, nextValue, ref.getAttributes());
            }
          } else if (value2 instanceof RefList) {
            for (const ref of value2.listRefsByChild(prevValue)) {
              const refAttributes = ref.getAttributes();
              this.removeRef(attribute, prevValue);
              this.addRef(attribute, nextValue, refAttributes);
            }
          } else if (value2 instanceof RefSet) {
            const ref = value2.getRefByChild(prevValue);
            if (ref) {
              const refAttributes = ref.getAttributes();
              this.removeRef(attribute, prevValue);
              this.addRef(attribute, nextValue, refAttributes);
            }
          } else if (value2 instanceof RefMap) {
            for (const key of value2.keys()) {
              const ref = value2.get(key);
              if (ref.getChild() === prevValue) {
                this.setRefMap(attribute, key, nextValue, ref.getAttributes());
              }
            }
          }
        }
        return this;
      }
      /**********************************************************************************************
       * Literal attributes.
       */
      /** @hidden */
      get(attribute) {
        return this[$attributes][attribute];
      }
      /** @hidden */
      set(attribute, value2) {
        this[$attributes][attribute] = value2;
        return this.dispatchEvent({
          type: "change",
          attribute
        });
      }
      /**********************************************************************************************
       * Ref: 1:1 graph node references.
       */
      /** @hidden */
      getRef(attribute) {
        const ref = this[$attributes][attribute];
        return ref ? ref.getChild() : null;
      }
      /** @hidden */
      setRef(attribute, value2, attributes) {
        if (this[$immutableKeys].has(attribute)) {
          throw new Error(`Cannot overwrite immutable attribute, "${attribute}".`);
        }
        const prevRef = this[$attributes][attribute];
        if (prevRef) prevRef.dispose();
        if (!value2) return this;
        const ref = this.graph._createEdge(attribute, this, value2, attributes);
        this[$attributes][attribute] = ref;
        return this.dispatchEvent({
          type: "change",
          attribute
        });
      }
      /**********************************************************************************************
       * RefList: 1:many graph node references.
       */
      /** @hidden */
      listRefs(attribute) {
        const refs = this.assertRefList(attribute);
        return refs.values().map((ref) => ref.getChild());
      }
      /** @hidden */
      addRef(attribute, value2, attributes) {
        const ref = this.graph._createEdge(attribute, this, value2, attributes);
        const refs = this.assertRefList(attribute);
        refs.add(ref);
        return this.dispatchEvent({
          type: "change",
          attribute
        });
      }
      /** @hidden */
      removeRef(attribute, value2) {
        const refs = this.assertRefList(attribute);
        if (refs instanceof RefList) {
          for (const ref of refs.listRefsByChild(value2)) {
            ref.dispose();
          }
        } else {
          const ref = refs.getRefByChild(value2);
          if (ref) ref.dispose();
        }
        return this;
      }
      /** @hidden */
      assertRefList(attribute) {
        const refs = this[$attributes][attribute];
        if (refs instanceof RefList || refs instanceof RefSet) {
          return refs;
        }
        throw new Error(`Expected RefList or RefSet for attribute "${attribute}"`);
      }
      /**********************************************************************************************
       * RefMap: Named 1:many (map) graph node references.
       */
      /** @hidden */
      listRefMapKeys(attribute) {
        return this.assertRefMap(attribute).keys();
      }
      /** @hidden */
      listRefMapValues(attribute) {
        return this.assertRefMap(attribute).values().map((ref) => ref.getChild());
      }
      /** @hidden */
      getRefMap(attribute, key) {
        const refMap = this.assertRefMap(attribute);
        const ref = refMap.get(key);
        return ref ? ref.getChild() : null;
      }
      /** @hidden */
      setRefMap(attribute, key, value2, metadata) {
        const refMap = this.assertRefMap(attribute);
        const prevRef = refMap.get(key);
        if (prevRef) prevRef.dispose();
        if (!value2) return this;
        metadata = Object.assign(metadata || {}, {
          key
        });
        const ref = this.graph._createEdge(attribute, this, value2, _extends({}, metadata, {
          key
        }));
        refMap.set(key, ref);
        return this.dispatchEvent({
          type: "change",
          attribute,
          key
        });
      }
      /** @hidden */
      assertRefMap(attribute) {
        const map = this[$attributes][attribute];
        if (map instanceof RefMap) {
          return map;
        }
        throw new Error(`Expected RefMap for attribute "${attribute}"`);
      }
      /**********************************************************************************************
       * Events.
       */
      /**
       * Dispatches an event on the GraphNode, and on the associated
       * Graph. Event types on the graph are prefixed, `"node:[type]"`.
       */
      dispatchEvent(event) {
        super.dispatchEvent(_extends({}, event, {
          target: this
        }));
        this.graph.dispatchEvent(_extends({}, event, {
          target: this,
          type: `node:${event.type}`
        }));
        return this;
      }
      /**********************************************************************************************
       * Internal.
       */
      /** @hidden */
      _destroyRef(ref) {
        const attribute = ref.getName();
        if (this[$attributes][attribute] === ref) {
          this[$attributes][attribute] = null;
          if (this[$immutableKeys].has(attribute)) ref.getChild().dispose();
        } else if (this[$attributes][attribute] instanceof RefList) {
          this[$attributes][attribute].remove(ref);
        } else if (this[$attributes][attribute] instanceof RefSet) {
          this[$attributes][attribute].remove(ref);
        } else if (this[$attributes][attribute] instanceof RefMap) {
          const refMap = this[$attributes][attribute];
          for (const key of refMap.keys()) {
            if (refMap.get(key) === ref) {
              refMap.delete(key);
            }
          }
        } else {
          return;
        }
        this.graph._destroyEdge(ref);
        this.dispatchEvent({
          type: "change",
          attribute
        });
      }
    };
  }
});

// node_modules/@gltf-transform/core/dist/index.modern.js
function validateJPEGBuffer(view, i) {
  if (i > view.byteLength) {
    throw new TypeError("Corrupt JPG, exceeded buffer limits");
  }
  if (view.getUint8(i) !== 255) {
    throw new TypeError("Invalid JPG, marker table corrupted");
  }
  return view;
}
function create() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function getBounds(node) {
  const resultBounds = createBounds();
  const parents = node.propertyType === PropertyType.NODE ? [node] : node.listChildren();
  for (const parent of parents) {
    parent.traverse((node2) => {
      const mesh = node2.getMesh();
      if (!mesh) return;
      const meshBounds = getMeshBounds(mesh, node2.getWorldMatrix());
      if (meshBounds.min.every(isFinite) && meshBounds.max.every(isFinite)) {
        expandBounds(meshBounds.min, resultBounds);
        expandBounds(meshBounds.max, resultBounds);
      }
    });
  }
  return resultBounds;
}
function getMeshBounds(mesh, worldMatrix) {
  const meshBounds = createBounds();
  for (const prim of mesh.listPrimitives()) {
    const position = prim.getAttribute("POSITION");
    const indices = prim.getIndices();
    if (!position) continue;
    let localPos = [0, 0, 0];
    let worldPos = [0, 0, 0];
    for (let i = 0, il = indices ? indices.getCount() : position.getCount(); i < il; i++) {
      const index = indices ? indices.getScalar(i) : i;
      localPos = position.getElement(index, localPos);
      worldPos = transformMat4(worldPos, localPos, worldMatrix);
      expandBounds(worldPos, meshBounds);
    }
  }
  return meshBounds;
}
function expandBounds(point, target) {
  for (let i = 0; i < 3; i++) {
    target.min[i] = Math.min(point[i], target.min[i]);
    target.max[i] = Math.max(point[i], target.max[i]);
  }
}
function createBounds() {
  return {
    min: [Infinity, Infinity, Infinity],
    max: [-Infinity, -Infinity, -Infinity]
  };
}
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainObject(o) {
  if (isObject(o) === false) return false;
  const ctor = o.constructor;
  if (ctor === void 0) return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false) return false;
  if (Object.hasOwn(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function equalsRef(refA, refB) {
  if (!!refA !== !!refB) return false;
  const a = refA.getChild();
  const b = refB.getChild();
  return a === b || a.equals(b);
}
function equalsRefSet(refSetA, refSetB) {
  if (!!refSetA !== !!refSetB) return false;
  const refValuesA = refSetA.values();
  const refValuesB = refSetB.values();
  if (refValuesA.length !== refValuesB.length) return false;
  for (let i = 0; i < refValuesA.length; i++) {
    const a = refValuesA[i];
    const b = refValuesB[i];
    if (a.getChild() === b.getChild()) continue;
    if (!a.getChild().equals(b.getChild())) return false;
  }
  return true;
}
function equalsRefMap(refMapA, refMapB) {
  if (!!refMapA !== !!refMapB) return false;
  const keysA = refMapA.keys();
  const keysB = refMapB.keys();
  if (keysA.length !== keysB.length) return false;
  for (const key of keysA) {
    const refA = refMapA.get(key);
    const refB = refMapB.get(key);
    if (!!refA !== !!refB) return false;
    const a = refA.getChild();
    const b = refB.getChild();
    if (a === b) continue;
    if (!a.equals(b)) return false;
  }
  return true;
}
function equalsArray(a, b) {
  if (a === b) return true;
  if (!!a !== !!b || !a || !b) return false;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function equalsObject(_a2, _b2) {
  if (_a2 === _b2) return true;
  if (!!_a2 !== !!_b2) return false;
  if (!isPlainObject(_a2) || !isPlainObject(_b2)) {
    return _a2 === _b2;
  }
  const a = _a2;
  const b = _b2;
  let numKeysA = 0;
  let numKeysB = 0;
  let key;
  for (key in a) numKeysA++;
  for (key in b) numKeysB++;
  if (numKeysA !== numKeysB) return false;
  for (key in a) {
    const valueA = a[key];
    const valueB = b[key];
    if (isArray(valueA) && isArray(valueB)) {
      if (!equalsArray(valueA, valueB)) return false;
    } else if (isPlainObject(valueA) && isPlainObject(valueB)) {
      if (!equalsObject(valueA, valueB)) return false;
    } else {
      if (valueA !== valueB) return false;
    }
  }
  return true;
}
function isArray(value2) {
  return Array.isArray(value2) || ArrayBuffer.isView(value2);
}
function arrayToComponentType(array) {
  switch (array.constructor) {
    case Float32Array:
      return Accessor.ComponentType.FLOAT;
    case Uint32Array:
      return Accessor.ComponentType.UNSIGNED_INT;
    case Uint16Array:
      return Accessor.ComponentType.UNSIGNED_SHORT;
    case Uint8Array:
      return Accessor.ComponentType.UNSIGNED_BYTE;
    case Int16Array:
      return Accessor.ComponentType.SHORT;
    case Int8Array:
      return Accessor.ComponentType.BYTE;
    default:
      throw new Error("Unknown accessor componentType.");
  }
}
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends2.apply(null, arguments);
}
function getInterleavedArray(accessorDef, context) {
  const jsonDoc = context.jsonDoc;
  const bufferView = context.bufferViews[accessorDef.bufferView];
  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];
  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];
  const elementSize = Accessor.getElementSize(accessorDef.type);
  const componentSize = TypedArray.BYTES_PER_ELEMENT;
  const accessorByteOffset = accessorDef.byteOffset || 0;
  const array = new TypedArray(accessorDef.count * elementSize);
  const view = new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
  const byteStride = bufferViewDef.byteStride;
  for (let i = 0; i < accessorDef.count; i++) {
    for (let j = 0; j < elementSize; j++) {
      const byteOffset = accessorByteOffset + i * byteStride + j * componentSize;
      let value2;
      switch (accessorDef.componentType) {
        case Accessor.ComponentType.FLOAT:
          value2 = view.getFloat32(byteOffset, true);
          break;
        case Accessor.ComponentType.UNSIGNED_INT:
          value2 = view.getUint32(byteOffset, true);
          break;
        case Accessor.ComponentType.UNSIGNED_SHORT:
          value2 = view.getUint16(byteOffset, true);
          break;
        case Accessor.ComponentType.UNSIGNED_BYTE:
          value2 = view.getUint8(byteOffset);
          break;
        case Accessor.ComponentType.SHORT:
          value2 = view.getInt16(byteOffset, true);
          break;
        case Accessor.ComponentType.BYTE:
          value2 = view.getInt8(byteOffset);
          break;
        default:
          throw new Error(`Unexpected componentType "${accessorDef.componentType}".`);
      }
      array[i * elementSize + j] = value2;
    }
  }
  return array;
}
function getAccessorArray(accessorDef, context) {
  const jsonDoc = context.jsonDoc;
  const bufferView = context.bufferViews[accessorDef.bufferView];
  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];
  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];
  const elementSize = Accessor.getElementSize(accessorDef.type);
  const componentSize = TypedArray.BYTES_PER_ELEMENT;
  const elementStride = elementSize * componentSize;
  if (bufferViewDef.byteStride !== void 0 && bufferViewDef.byteStride !== elementStride) {
    return getInterleavedArray(accessorDef, context);
  }
  const byteOffset = bufferView.byteOffset + (accessorDef.byteOffset || 0);
  const byteLength = accessorDef.count * elementSize * componentSize;
  return new TypedArray(bufferView.buffer.slice(byteOffset, byteOffset + byteLength));
}
function getSparseArray(accessorDef, context) {
  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];
  const elementSize = Accessor.getElementSize(accessorDef.type);
  let array;
  if (accessorDef.bufferView !== void 0) {
    array = getAccessorArray(accessorDef, context);
  } else {
    array = new TypedArray(accessorDef.count * elementSize);
  }
  const sparseDef = accessorDef.sparse;
  if (!sparseDef) return array;
  const count = sparseDef.count;
  const indicesDef = _extends2({}, accessorDef, sparseDef.indices, {
    count,
    type: "SCALAR"
  });
  const valuesDef = _extends2({}, accessorDef, sparseDef.values, {
    count
  });
  const indices = getAccessorArray(indicesDef, context);
  const values = getAccessorArray(valuesDef, context);
  for (let i = 0; i < indicesDef.count; i++) {
    for (let j = 0; j < elementSize; j++) {
      array[indices[i] * elementSize + j] = values[i * elementSize + j];
    }
  }
  return array;
}
function getSlot(document2, texture) {
  const edge = document2.getGraph().listParentEdges(texture).find((edge2) => edge2.getParent() !== document2.getRoot());
  return edge ? edge.getName().replace(/texture$/i, "") : "";
}
function clean(object) {
  const unused = [];
  for (const key in object) {
    const value2 = object[key];
    if (Array.isArray(value2) && value2.length === 0) {
      unused.push(key);
    } else if (value2 === null || value2 === "") {
      unused.push(key);
    } else if (value2 && typeof value2 === "object" && Object.keys(value2).length === 0) {
      unused.push(key);
    }
  }
  for (const key of unused) {
    delete object[key];
  }
}
function isExternalBuffer(jsonDocument, bufferDef) {
  return bufferDef.uri !== void 0 && !(bufferDef.uri in jsonDocument.resources);
}
function isExternalImage(jsonDocument, imageDef) {
  return imageDef.uri !== void 0 && !(imageDef.uri in jsonDocument.resources) && imageDef.bufferView === void 0;
}
function isGLB(view) {
  if (view.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT) return false;
  const header = new Uint32Array(view.buffer, view.byteOffset, 3);
  return header[0] === 1179937895 && header[1] === 2;
}
var VERSION, GLB_BUFFER, PropertyType, VertexLayout, BufferViewUsage$1, TextureChannel, Format, ComponentTypeToTypedArray, BufferUtils, JPEGImageUtils, PNGImageUtils, ImageUtils, FileUtils, ARRAY_TYPE, NULL_DOMAIN, HTTPUtils, _Logger, Verbosity, Logger, MathUtils, ALPHABET, UNIQUE_RETRIES, ID_LENGTH, previousIDs, generateOne, uuid, COPY_IDENTITY, EMPTY_SET, Property, ExtensibleProperty, Accessor, Animation, AnimationChannel, AnimationSampler, Buffer$1, Camera, ExtensionProperty, TextureInfo, R, G, B, A, Material, Mesh, Node, Primitive, PrimitiveTarget, Scene, Skin, Texture, Root, Document, Extension, ReaderContext, DEFAULT_OPTIONS, SUPPORTED_PREREAD_TYPES, GLTFReader, BufferViewTarget, WriterContext, UniqueURIGenerator, BufferViewUsage, UNSIGNED_INT, UNSIGNED_SHORT, UNSIGNED_BYTE, SUPPORTED_PREWRITE_TYPES, GLTFWriter, ChunkType, PlatformIO, WebIO;
var init_index_modern = __esm({
  "node_modules/@gltf-transform/core/dist/index.modern.js"() {
    init_property_graph_modern();
    init_property_graph_modern();
    VERSION = `v${"4.2.1"}`;
    GLB_BUFFER = "@glb.bin";
    (function(PropertyType2) {
      PropertyType2["ACCESSOR"] = "Accessor";
      PropertyType2["ANIMATION"] = "Animation";
      PropertyType2["ANIMATION_CHANNEL"] = "AnimationChannel";
      PropertyType2["ANIMATION_SAMPLER"] = "AnimationSampler";
      PropertyType2["BUFFER"] = "Buffer";
      PropertyType2["CAMERA"] = "Camera";
      PropertyType2["MATERIAL"] = "Material";
      PropertyType2["MESH"] = "Mesh";
      PropertyType2["PRIMITIVE"] = "Primitive";
      PropertyType2["PRIMITIVE_TARGET"] = "PrimitiveTarget";
      PropertyType2["NODE"] = "Node";
      PropertyType2["ROOT"] = "Root";
      PropertyType2["SCENE"] = "Scene";
      PropertyType2["SKIN"] = "Skin";
      PropertyType2["TEXTURE"] = "Texture";
      PropertyType2["TEXTURE_INFO"] = "TextureInfo";
    })(PropertyType || (PropertyType = {}));
    (function(VertexLayout2) {
      VertexLayout2["INTERLEAVED"] = "interleaved";
      VertexLayout2["SEPARATE"] = "separate";
    })(VertexLayout || (VertexLayout = {}));
    (function(BufferViewUsage2) {
      BufferViewUsage2["ARRAY_BUFFER"] = "ARRAY_BUFFER";
      BufferViewUsage2["ELEMENT_ARRAY_BUFFER"] = "ELEMENT_ARRAY_BUFFER";
      BufferViewUsage2["INVERSE_BIND_MATRICES"] = "INVERSE_BIND_MATRICES";
      BufferViewUsage2["OTHER"] = "OTHER";
      BufferViewUsage2["SPARSE"] = "SPARSE";
    })(BufferViewUsage$1 || (BufferViewUsage$1 = {}));
    (function(TextureChannel2) {
      TextureChannel2[TextureChannel2["R"] = 4096] = "R";
      TextureChannel2[TextureChannel2["G"] = 256] = "G";
      TextureChannel2[TextureChannel2["B"] = 16] = "B";
      TextureChannel2[TextureChannel2["A"] = 1] = "A";
    })(TextureChannel || (TextureChannel = {}));
    (function(Format2) {
      Format2["GLTF"] = "GLTF";
      Format2["GLB"] = "GLB";
    })(Format || (Format = {}));
    ComponentTypeToTypedArray = {
      "5120": Int8Array,
      "5121": Uint8Array,
      "5122": Int16Array,
      "5123": Uint16Array,
      "5125": Uint32Array,
      "5126": Float32Array
    };
    BufferUtils = class {
      /** Creates a byte array from a Data URI. */
      static createBufferFromDataURI(dataURI) {
        if (typeof Buffer === "undefined") {
          const byteString = atob(dataURI.split(",")[1]);
          const ia = new Uint8Array(byteString.length);
          for (let i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
          }
          return ia;
        } else {
          const data = dataURI.split(",")[1];
          const isBase64 = dataURI.indexOf("base64") >= 0;
          return Buffer.from(data, isBase64 ? "base64" : "utf8");
        }
      }
      /** Encodes text to a byte array. */
      static encodeText(text) {
        return new TextEncoder().encode(text);
      }
      /** Decodes a byte array to text. */
      static decodeText(array) {
        return new TextDecoder().decode(array);
      }
      /**
       * Concatenates N byte arrays.
       */
      static concat(arrays) {
        let totalByteLength = 0;
        for (const array of arrays) {
          totalByteLength += array.byteLength;
        }
        const result = new Uint8Array(totalByteLength);
        let byteOffset = 0;
        for (const array of arrays) {
          result.set(array, byteOffset);
          byteOffset += array.byteLength;
        }
        return result;
      }
      /**
       * Pads a Uint8Array to the next 4-byte boundary.
       *
       * Reference: [glTF → Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)
       */
      static pad(srcArray, paddingByte = 0) {
        const paddedLength = this.padNumber(srcArray.byteLength);
        if (paddedLength === srcArray.byteLength) return srcArray;
        const dstArray = new Uint8Array(paddedLength);
        dstArray.set(srcArray);
        if (paddingByte !== 0) {
          for (let i = srcArray.byteLength; i < paddedLength; i++) {
            dstArray[i] = paddingByte;
          }
        }
        return dstArray;
      }
      /** Pads a number to 4-byte boundaries. */
      static padNumber(v) {
        return Math.ceil(v / 4) * 4;
      }
      /** Returns true if given byte array instances are equal. */
      static equals(a, b) {
        if (a === b) return true;
        if (a.byteLength !== b.byteLength) return false;
        let i = a.byteLength;
        while (i--) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      }
      /**
       * Returns a Uint8Array view of a typed array, with the same underlying ArrayBuffer.
       *
       * A shorthand for:
       *
       * ```js
       * const buffer = new Uint8Array(
       * 	array.buffer,
       * 	array.byteOffset + byteOffset,
       * 	Math.min(array.byteLength, byteLength)
       * );
       * ```
       *
       */
      static toView(a, byteOffset = 0, byteLength = Infinity) {
        return new Uint8Array(a.buffer, a.byteOffset + byteOffset, Math.min(a.byteLength, byteLength));
      }
      static assertView(view) {
        if (view && !ArrayBuffer.isView(view)) {
          throw new Error(`Method requires Uint8Array parameter; received "${typeof view}".`);
        }
        return view;
      }
    };
    JPEGImageUtils = class {
      match(array) {
        return array.length >= 3 && array[0] === 255 && array[1] === 216 && array[2] === 255;
      }
      getSize(array) {
        let view = new DataView(array.buffer, array.byteOffset + 4);
        let i, next;
        while (view.byteLength) {
          i = view.getUint16(0, false);
          validateJPEGBuffer(view, i);
          next = view.getUint8(i + 1);
          if (next === 192 || next === 193 || next === 194) {
            return [view.getUint16(i + 7, false), view.getUint16(i + 5, false)];
          }
          view = new DataView(array.buffer, view.byteOffset + i + 2);
        }
        throw new TypeError("Invalid JPG, no size found");
      }
      getChannels(_buffer) {
        return 3;
      }
    };
    PNGImageUtils = class _PNGImageUtils {
      match(array) {
        return array.length >= 8 && array[0] === 137 && array[1] === 80 && array[2] === 78 && array[3] === 71 && array[4] === 13 && array[5] === 10 && array[6] === 26 && array[7] === 10;
      }
      getSize(array) {
        const view = new DataView(array.buffer, array.byteOffset);
        const magic = BufferUtils.decodeText(array.slice(12, 16));
        if (magic === _PNGImageUtils.PNG_FRIED_CHUNK_NAME) {
          return [view.getUint32(32, false), view.getUint32(36, false)];
        }
        return [view.getUint32(16, false), view.getUint32(20, false)];
      }
      getChannels(_buffer) {
        return 4;
      }
    };
    PNGImageUtils.PNG_FRIED_CHUNK_NAME = "CgBI";
    ImageUtils = class {
      /** Registers support for a new image format; useful for certain extensions. */
      static registerFormat(mimeType, impl) {
        this.impls[mimeType] = impl;
      }
      /**
       * Returns detected MIME type of the given image buffer. Note that for image
       * formats with support provided by extensions, the extension must be
       * registered with an I/O class before it can be detected by ImageUtils.
       */
      static getMimeType(buffer) {
        for (const mimeType in this.impls) {
          if (this.impls[mimeType].match(buffer)) {
            return mimeType;
          }
        }
        return null;
      }
      /** Returns the dimensions of the image. */
      static getSize(buffer, mimeType) {
        if (!this.impls[mimeType]) return null;
        return this.impls[mimeType].getSize(buffer);
      }
      /**
       * Returns a conservative estimate of the number of channels in the image. For some image
       * formats, the method may return 4 indicating the possibility of an alpha channel, without
       * the ability to guarantee that an alpha channel is present.
       */
      static getChannels(buffer, mimeType) {
        if (!this.impls[mimeType]) return null;
        return this.impls[mimeType].getChannels(buffer);
      }
      /** Returns a conservative estimate of the GPU memory required by this image. */
      static getVRAMByteLength(buffer, mimeType) {
        if (!this.impls[mimeType]) return null;
        if (this.impls[mimeType].getVRAMByteLength) {
          return this.impls[mimeType].getVRAMByteLength(buffer);
        }
        let uncompressedBytes = 0;
        const channels = 4;
        const resolution = this.getSize(buffer, mimeType);
        if (!resolution) return null;
        while (resolution[0] > 1 || resolution[1] > 1) {
          uncompressedBytes += resolution[0] * resolution[1] * channels;
          resolution[0] = Math.max(Math.floor(resolution[0] / 2), 1);
          resolution[1] = Math.max(Math.floor(resolution[1] / 2), 1);
        }
        uncompressedBytes += 1 * 1 * channels;
        return uncompressedBytes;
      }
      /** Returns the preferred file extension for the given MIME type. */
      static mimeTypeToExtension(mimeType) {
        if (mimeType === "image/jpeg") return "jpg";
        return mimeType.split("/").pop();
      }
      /** Returns the MIME type for the given file extension. */
      static extensionToMimeType(extension) {
        if (extension === "jpg") return "image/jpeg";
        if (!extension) return "";
        return `image/${extension}`;
      }
    };
    ImageUtils.impls = {
      "image/jpeg": new JPEGImageUtils(),
      "image/png": new PNGImageUtils()
    };
    FileUtils = class {
      /**
       * Extracts the basename from a file path, e.g. "folder/model.glb" -> "model".
       * See: {@link HTTPUtils.basename}
       */
      static basename(uri) {
        const fileName = uri.split(/[\\/]/).pop();
        return fileName.substring(0, fileName.lastIndexOf("."));
      }
      /**
       * Extracts the extension from a file path, e.g. "folder/model.glb" -> "glb".
       * See: {@link HTTPUtils.extension}
       */
      static extension(uri) {
        if (uri.startsWith("data:image/")) {
          const mimeType = uri.match(/data:(image\/\w+)/)[1];
          return ImageUtils.mimeTypeToExtension(mimeType);
        } else if (uri.startsWith("data:model/gltf+json")) {
          return "gltf";
        } else if (uri.startsWith("data:model/gltf-binary")) {
          return "glb";
        } else if (uri.startsWith("data:application/")) {
          return "bin";
        }
        return uri.split(/[\\/]/).pop().split(/[.]/).pop();
      }
    };
    ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
    if (!Math.hypot) Math.hypot = function() {
      var y = 0, i = arguments.length;
      while (i--) {
        y += arguments[i] * arguments[i];
      }
      return Math.sqrt(y);
    };
    (function() {
      var vec = create();
      return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if (!stride) {
          stride = 3;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l = Math.min(count * stride + offset, a.length);
        } else {
          l = a.length;
        }
        for (i = offset; i < l; i += stride) {
          vec[0] = a[i];
          vec[1] = a[i + 1];
          vec[2] = a[i + 2];
          fn(vec, vec, arg);
          a[i] = vec[0];
          a[i + 1] = vec[1];
          a[i + 2] = vec[2];
        }
        return a;
      };
    })();
    NULL_DOMAIN = "https://null.example";
    HTTPUtils = class {
      static dirname(path) {
        const index = path.lastIndexOf("/");
        if (index === -1) return "./";
        return path.substring(0, index + 1);
      }
      /**
       * Extracts the basename from a URL, e.g. "folder/model.glb" -> "model".
       * See: {@link FileUtils.basename}
       */
      static basename(uri) {
        return FileUtils.basename(new URL(uri, NULL_DOMAIN).pathname);
      }
      /**
       * Extracts the extension from a URL, e.g. "folder/model.glb" -> "glb".
       * See: {@link FileUtils.extension}
       */
      static extension(uri) {
        return FileUtils.extension(new URL(uri, NULL_DOMAIN).pathname);
      }
      static resolve(base, path) {
        if (!this.isRelativePath(path)) return path;
        const stack = base.split("/");
        const parts = path.split("/");
        stack.pop();
        for (let i = 0; i < parts.length; i++) {
          if (parts[i] === ".") continue;
          if (parts[i] === "..") {
            stack.pop();
          } else {
            stack.push(parts[i]);
          }
        }
        return stack.join("/");
      }
      /**
       * Returns true for URLs containing a protocol, and false for both
       * absolute and relative paths.
       */
      static isAbsoluteURL(path) {
        return this.PROTOCOL_REGEXP.test(path);
      }
      /**
       * Returns true for paths that are declared relative to some unknown base
       * path. For example, "foo/bar/" is relative both "/foo/bar/" is not.
       */
      static isRelativePath(path) {
        return !/^(?:[a-zA-Z]+:)?\//.test(path);
      }
    };
    HTTPUtils.DEFAULT_INIT = {};
    HTTPUtils.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;
    (function(Verbosity2) {
      Verbosity2[Verbosity2["SILENT"] = 4] = "SILENT";
      Verbosity2[Verbosity2["ERROR"] = 3] = "ERROR";
      Verbosity2[Verbosity2["WARN"] = 2] = "WARN";
      Verbosity2[Verbosity2["INFO"] = 1] = "INFO";
      Verbosity2[Verbosity2["DEBUG"] = 0] = "DEBUG";
    })(Verbosity || (Verbosity = {}));
    Logger = class _Logger2 {
      /** Constructs a new Logger instance. */
      constructor(verbosity) {
        this.verbosity = void 0;
        this.verbosity = verbosity;
      }
      /** Logs an event at level {@link Logger.Verbosity.DEBUG}. */
      debug(text) {
        if (this.verbosity <= _Logger2.Verbosity.DEBUG) {
          console.debug(text);
        }
      }
      /** Logs an event at level {@link Logger.Verbosity.INFO}. */
      info(text) {
        if (this.verbosity <= _Logger2.Verbosity.INFO) {
          console.info(text);
        }
      }
      /** Logs an event at level {@link Logger.Verbosity.WARN}. */
      warn(text) {
        if (this.verbosity <= _Logger2.Verbosity.WARN) {
          console.warn(text);
        }
      }
      /** Logs an event at level {@link Logger.Verbosity.ERROR}. */
      error(text) {
        if (this.verbosity <= _Logger2.Verbosity.ERROR) {
          console.error(text);
        }
      }
    };
    _Logger = Logger;
    Logger.Verbosity = Verbosity;
    Logger.DEFAULT_INSTANCE = new _Logger(_Logger.Verbosity.INFO);
    MathUtils = class _MathUtils {
      static identity(v) {
        return v;
      }
      static eq(a, b, tolerance = 1e-5) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
          if (Math.abs(a[i] - b[i]) > tolerance) return false;
        }
        return true;
      }
      static clamp(value2, min, max) {
        if (value2 < min) return min;
        if (value2 > max) return max;
        return value2;
      }
      // TODO(perf): Compare performance if we replace the switch with individual functions.
      static decodeNormalizedInt(i, componentType) {
        switch (componentType) {
          case 5126:
            return i;
          case 5123:
            return i / 65535;
          case 5121:
            return i / 255;
          case 5122:
            return Math.max(i / 32767, -1);
          case 5120:
            return Math.max(i / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      // TODO(perf): Compare performance if we replace the switch with individual functions.
      static encodeNormalizedInt(f, componentType) {
        switch (componentType) {
          case 5126:
            return f;
          case 5123:
            return Math.round(_MathUtils.clamp(f, 0, 1) * 65535);
          case 5121:
            return Math.round(_MathUtils.clamp(f, 0, 1) * 255);
          case 5122:
            return Math.round(_MathUtils.clamp(f, -1, 1) * 32767);
          case 5120:
            return Math.round(_MathUtils.clamp(f, -1, 1) * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      /**
       * Decompose a mat4 to TRS properties.
       *
       * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the
       * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408
       *
       * @param srcMat Matrix element, to be decomposed to TRS properties.
       * @param dstTranslation Translation element, to be overwritten.
       * @param dstRotation Rotation element, to be overwritten.
       * @param dstScale Scale element, to be overwritten.
       */
      static decompose(srcMat, dstTranslation, dstRotation, dstScale) {
        let sx = length([srcMat[0], srcMat[1], srcMat[2]]);
        const sy = length([srcMat[4], srcMat[5], srcMat[6]]);
        const sz = length([srcMat[8], srcMat[9], srcMat[10]]);
        const det = determinant(srcMat);
        if (det < 0) sx = -sx;
        dstTranslation[0] = srcMat[12];
        dstTranslation[1] = srcMat[13];
        dstTranslation[2] = srcMat[14];
        const _m1 = srcMat.slice();
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1[0] *= invSX;
        _m1[1] *= invSX;
        _m1[2] *= invSX;
        _m1[4] *= invSY;
        _m1[5] *= invSY;
        _m1[6] *= invSY;
        _m1[8] *= invSZ;
        _m1[9] *= invSZ;
        _m1[10] *= invSZ;
        getRotation(dstRotation, _m1);
        dstScale[0] = sx;
        dstScale[1] = sy;
        dstScale[2] = sz;
      }
      /**
       * Compose TRS properties to a mat4.
       *
       * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the
       * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408
       *
       * @param srcTranslation Translation element of matrix.
       * @param srcRotation Rotation element of matrix.
       * @param srcScale Scale element of matrix.
       * @param dstMat Matrix element, to be modified and returned.
       * @returns dstMat, overwritten to mat4 equivalent of given TRS properties.
       */
      static compose(srcTranslation, srcRotation, srcScale, dstMat) {
        const te2 = dstMat;
        const x = srcRotation[0], y = srcRotation[1], z = srcRotation[2], w = srcRotation[3];
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        const sx = srcScale[0], sy = srcScale[1], sz = srcScale[2];
        te2[0] = (1 - (yy + zz)) * sx;
        te2[1] = (xy + wz) * sx;
        te2[2] = (xz - wy) * sx;
        te2[3] = 0;
        te2[4] = (xy - wz) * sy;
        te2[5] = (1 - (xx + zz)) * sy;
        te2[6] = (yz + wx) * sy;
        te2[7] = 0;
        te2[8] = (xz + wy) * sz;
        te2[9] = (yz - wx) * sz;
        te2[10] = (1 - (xx + yy)) * sz;
        te2[11] = 0;
        te2[12] = srcTranslation[0];
        te2[13] = srcTranslation[1];
        te2[14] = srcTranslation[2];
        te2[15] = 1;
        return te2;
      }
    };
    ALPHABET = "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ";
    UNIQUE_RETRIES = 999;
    ID_LENGTH = 6;
    previousIDs = /* @__PURE__ */ new Set();
    generateOne = function generateOne2() {
      let rtn = "";
      for (let i = 0; i < ID_LENGTH; i++) {
        rtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));
      }
      return rtn;
    };
    uuid = function uuid2() {
      for (let retries = 0; retries < UNIQUE_RETRIES; retries++) {
        const id = generateOne();
        if (!previousIDs.has(id)) {
          previousIDs.add(id);
          return id;
        }
      }
      return "";
    };
    COPY_IDENTITY = (t) => t;
    EMPTY_SET = /* @__PURE__ */ new Set();
    Property = class extends GraphNode {
      /** @hidden */
      constructor(graph, name = "") {
        super(graph);
        this[$attributes]["name"] = name;
        this.init();
        this.dispatchEvent({
          type: "create"
        });
      }
      /**
       * Returns the Graph associated with this Property. For internal use.
       * @hidden
       * @experimental
       */
      getGraph() {
        return this.graph;
      }
      /**
       * Returns default attributes for the property. Empty lists and maps should be initialized
       * to empty arrays and objects. Always invoke `super.getDefaults()` and extend the result.
       */
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          name: "",
          extras: {}
        });
      }
      /** @hidden */
      set(attribute, value2) {
        if (Array.isArray(value2)) value2 = value2.slice();
        return super.set(attribute, value2);
      }
      /**********************************************************************************************
       * Name.
       */
      /**
       * Returns the name of this property. While names are not required to be unique, this is
       * encouraged, and non-unique names will be overwritten in some tools. For custom data about
       * a property, prefer to use Extras.
       */
      getName() {
        return this.get("name");
      }
      /**
       * Sets the name of this property. While names are not required to be unique, this is
       * encouraged, and non-unique names will be overwritten in some tools. For custom data about
       * a property, prefer to use Extras.
       */
      setName(name) {
        return this.set("name", name);
      }
      /**********************************************************************************************
       * Extras.
       */
      /**
       * Returns a reference to the Extras object, containing application-specific data for this
       * Property. Extras should be an Object, not a primitive value, for best portability.
       */
      getExtras() {
        return this.get("extras");
      }
      /**
       * Updates the Extras object, containing application-specific data for this Property. Extras
       * should be an Object, not a primitive value, for best portability.
       */
      setExtras(extras) {
        return this.set("extras", extras);
      }
      /**********************************************************************************************
       * Graph state.
       */
      /**
       * Makes a copy of this property, with the same resources (by reference) as the original.
       */
      clone() {
        const PropertyClass = this.constructor;
        return new PropertyClass(this.graph).copy(this, COPY_IDENTITY);
      }
      /**
       * Copies all data from another property to this one. Child properties are copied by reference,
       * unless a 'resolve' function is given to override that.
       * @param other Property to copy references from.
       * @param resolve Function to resolve each Property being transferred. Default is identity.
       */
      copy(other, resolve = COPY_IDENTITY) {
        for (const key in this[$attributes]) {
          const value2 = this[$attributes][key];
          if (value2 instanceof GraphEdge) {
            if (!this[$immutableKeys].has(key)) {
              value2.dispose();
            }
          } else if (value2 instanceof RefList || value2 instanceof RefSet) {
            for (const ref of value2.values()) {
              ref.dispose();
            }
          } else if (value2 instanceof RefMap) {
            for (const ref of value2.values()) {
              ref.dispose();
            }
          }
        }
        for (const key in other[$attributes]) {
          const thisValue = this[$attributes][key];
          const otherValue = other[$attributes][key];
          if (otherValue instanceof GraphEdge) {
            if (this[$immutableKeys].has(key)) {
              const ref = thisValue;
              ref.getChild().copy(resolve(otherValue.getChild()), resolve);
            } else {
              this.setRef(key, resolve(otherValue.getChild()), otherValue.getAttributes());
            }
          } else if (otherValue instanceof RefSet || otherValue instanceof RefList) {
            for (const ref of otherValue.values()) {
              this.addRef(key, resolve(ref.getChild()), ref.getAttributes());
            }
          } else if (otherValue instanceof RefMap) {
            for (const subkey of otherValue.keys()) {
              const ref = otherValue.get(subkey);
              this.setRefMap(key, subkey, resolve(ref.getChild()), ref.getAttributes());
            }
          } else if (isPlainObject(otherValue)) {
            this[$attributes][key] = JSON.parse(JSON.stringify(otherValue));
          } else if (Array.isArray(otherValue) || otherValue instanceof ArrayBuffer || ArrayBuffer.isView(otherValue)) {
            this[$attributes][key] = otherValue.slice();
          } else {
            this[$attributes][key] = otherValue;
          }
        }
        return this;
      }
      /**
       * Returns true if two properties are deeply equivalent, recursively comparing the attributes
       * of the properties. Optionally, a 'skip' set may be included, specifying attributes whose
       * values should not be considered in the comparison.
       *
       * Example: Two {@link Primitive Primitives} are equivalent if they have accessors and
       * materials with equivalent content — but not necessarily the same specific accessors
       * and materials.
       */
      equals(other, skip = EMPTY_SET) {
        if (this === other) return true;
        if (this.propertyType !== other.propertyType) return false;
        for (const key in this[$attributes]) {
          if (skip.has(key)) continue;
          const a = this[$attributes][key];
          const b = other[$attributes][key];
          if (a instanceof GraphEdge || b instanceof GraphEdge) {
            if (!equalsRef(a, b)) {
              return false;
            }
          } else if (a instanceof RefSet || b instanceof RefSet || a instanceof RefList || b instanceof RefList) {
            if (!equalsRefSet(a, b)) {
              return false;
            }
          } else if (a instanceof RefMap || b instanceof RefMap) {
            if (!equalsRefMap(a, b)) {
              return false;
            }
          } else if (isPlainObject(a) || isPlainObject(b)) {
            if (!equalsObject(a, b)) return false;
          } else if (isArray(a) || isArray(b)) {
            if (!equalsArray(a, b)) return false;
          } else {
            if (a !== b) return false;
          }
        }
        return true;
      }
      detach() {
        this.graph.disconnectParents(this, (n) => n.propertyType !== "Root");
        return this;
      }
      /**
       * Returns a list of all properties that hold a reference to this property. For example, a
       * material may hold references to various textures, but a texture does not hold references
       * to the materials that use it.
       *
       * It is often necessary to filter the results for a particular type: some resources, like
       * {@link Accessor}s, may be referenced by different types of properties. Most properties
       * include the {@link Root} as a parent, which is usually not of interest.
       *
       * Usage:
       *
       * ```ts
       * const materials = texture
       * 	.listParents()
       * 	.filter((p) => p instanceof Material)
       * ```
       */
      listParents() {
        return this.graph.listParents(this);
      }
    };
    ExtensibleProperty = class extends Property {
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          extensions: new RefMap()
        });
      }
      /** Returns an {@link ExtensionProperty} attached to this Property, if any. */
      getExtension(name) {
        return this.getRefMap("extensions", name);
      }
      /**
       * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only
       * one ExtensionProperty may be attached to any one Property at a time.
       */
      setExtension(name, extensionProperty) {
        if (extensionProperty) extensionProperty._validateParent(this);
        return this.setRefMap("extensions", name, extensionProperty);
      }
      /** Lists all {@link ExtensionProperty} instances attached to this Property. */
      listExtensions() {
        return this.listRefMapValues("extensions");
      }
    };
    Accessor = class _Accessor extends ExtensibleProperty {
      /**********************************************************************************************
       * Instance.
       */
      init() {
        this.propertyType = PropertyType.ACCESSOR;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          array: null,
          type: _Accessor.Type.SCALAR,
          componentType: _Accessor.ComponentType.FLOAT,
          normalized: false,
          sparse: false,
          buffer: null
        });
      }
      /**********************************************************************************************
       * Static.
       */
      /** Returns size of a given element type, in components. */
      static getElementSize(type) {
        switch (type) {
          case _Accessor.Type.SCALAR:
            return 1;
          case _Accessor.Type.VEC2:
            return 2;
          case _Accessor.Type.VEC3:
            return 3;
          case _Accessor.Type.VEC4:
            return 4;
          case _Accessor.Type.MAT2:
            return 4;
          case _Accessor.Type.MAT3:
            return 9;
          case _Accessor.Type.MAT4:
            return 16;
          default:
            throw new Error("Unexpected type: " + type);
        }
      }
      /** Returns size of a given component type, in bytes. */
      static getComponentSize(componentType) {
        switch (componentType) {
          case _Accessor.ComponentType.BYTE:
            return 1;
          case _Accessor.ComponentType.UNSIGNED_BYTE:
            return 1;
          case _Accessor.ComponentType.SHORT:
            return 2;
          case _Accessor.ComponentType.UNSIGNED_SHORT:
            return 2;
          case _Accessor.ComponentType.UNSIGNED_INT:
            return 4;
          case _Accessor.ComponentType.FLOAT:
            return 4;
          default:
            throw new Error("Unexpected component type: " + componentType);
        }
      }
      /**********************************************************************************************
       * Min/max bounds.
       */
      /**
       * Minimum value of each component in this attribute. Unlike in a final glTF file, values
       * returned by this method will reflect the minimum accounting for {@link .normalized}
       * state.
       */
      getMinNormalized(target) {
        const normalized = this.getNormalized();
        const elementSize = this.getElementSize();
        const componentType = this.getComponentType();
        this.getMin(target);
        if (normalized) {
          for (let j = 0; j < elementSize; j++) {
            target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);
          }
        }
        return target;
      }
      /**
       * Minimum value of each component in this attribute. Values returned by this method do not
       * reflect normalization: use {@link .getMinNormalized} in that case.
       */
      getMin(target) {
        const array = this.getArray();
        const count = this.getCount();
        const elementSize = this.getElementSize();
        for (let j = 0; j < elementSize; j++) target[j] = Infinity;
        for (let i = 0; i < count * elementSize; i += elementSize) {
          for (let j = 0; j < elementSize; j++) {
            const value2 = array[i + j];
            if (Number.isFinite(value2)) {
              target[j] = Math.min(target[j], value2);
            }
          }
        }
        return target;
      }
      /**
       * Maximum value of each component in this attribute. Unlike in a final glTF file, values
       * returned by this method will reflect the minimum accounting for {@link .normalized}
       * state.
       */
      getMaxNormalized(target) {
        const normalized = this.getNormalized();
        const elementSize = this.getElementSize();
        const componentType = this.getComponentType();
        this.getMax(target);
        if (normalized) {
          for (let j = 0; j < elementSize; j++) {
            target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);
          }
        }
        return target;
      }
      /**
       * Maximum value of each component in this attribute. Values returned by this method do not
       * reflect normalization: use {@link .getMinNormalized} in that case.
       */
      getMax(target) {
        const array = this.get("array");
        const count = this.getCount();
        const elementSize = this.getElementSize();
        for (let j = 0; j < elementSize; j++) target[j] = -Infinity;
        for (let i = 0; i < count * elementSize; i += elementSize) {
          for (let j = 0; j < elementSize; j++) {
            const value2 = array[i + j];
            if (Number.isFinite(value2)) {
              target[j] = Math.max(target[j], value2);
            }
          }
        }
        return target;
      }
      /**********************************************************************************************
       * Layout.
       */
      /**
       * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,
       * will have a count of 10.
       */
      getCount() {
        const array = this.get("array");
        return array ? array.length / this.getElementSize() : 0;
      }
      /** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */
      getType() {
        return this.get("type");
      }
      /**
       * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a
       * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.
       */
      setType(type) {
        return this.set("type", type);
      }
      /**
       * Number of components in each element of the accessor. For example, the element size of a
       * `VEC2` accessor is 2. This value is determined automatically based on array length and
       * accessor type, specified with {@link Accessor.setType setType()}.
       */
      // biome-ignore lint/suspicious/useAdjacentOverloadSignatures: Static vs. non-static.
      getElementSize() {
        return _Accessor.getElementSize(this.get("type"));
      }
      /**
       * Size of each component (a value in the raw array), in bytes. For example, the
       * `componentSize` of data backed by a `float32` array is 4 bytes.
       */
      getComponentSize() {
        return this.get("array").BYTES_PER_ELEMENT;
      }
      /**
       * Component type (float32, uint16, etc.). This value is determined automatically, and can only
       * be modified by replacing the underlying array.
       */
      getComponentType() {
        return this.get("componentType");
      }
      /**********************************************************************************************
       * Normalization.
       */
      /**
       * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned
       * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.
       * This property is defined only for accessors that contain vertex attributes or animation
       * output data.
       */
      getNormalized() {
        return this.get("normalized");
      }
      /**
       * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned
       * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.
       * This property is defined only for accessors that contain vertex attributes or animation
       * output data.
       */
      setNormalized(normalized) {
        return this.set("normalized", normalized);
      }
      /**********************************************************************************************
       * Data access.
       */
      /**
       * Returns the scalar element value at the given index. For
       * {@link Accessor.getNormalized normalized} integer accessors, values are
       * decoded and returned in floating-point form.
       */
      getScalar(index) {
        const elementSize = this.getElementSize();
        const componentType = this.getComponentType();
        const array = this.getArray();
        if (this.getNormalized()) {
          return MathUtils.decodeNormalizedInt(array[index * elementSize], componentType);
        }
        return array[index * elementSize];
      }
      /**
       * Assigns the scalar element value at the given index. For
       * {@link Accessor.getNormalized normalized} integer accessors, "value" should be
       * given in floating-point form — it will be integer-encoded before writing
       * to the underlying array.
       */
      setScalar(index, x) {
        const elementSize = this.getElementSize();
        const componentType = this.getComponentType();
        const array = this.getArray();
        if (this.getNormalized()) {
          array[index * elementSize] = MathUtils.encodeNormalizedInt(x, componentType);
        } else {
          array[index * elementSize] = x;
        }
        return this;
      }
      /**
       * Returns the vector or matrix element value at the given index. For
       * {@link Accessor.getNormalized normalized} integer accessors, values are
       * decoded and returned in floating-point form.
       *
       * Example:
       *
       * ```javascript
       * import { add } from 'gl-matrix/add';
       *
       * const element = [];
       * const offset = [1, 1, 1];
       *
       * for (let i = 0; i < accessor.getCount(); i++) {
       * 	accessor.getElement(i, element);
       * 	add(element, element, offset);
       * 	accessor.setElement(i, element);
       * }
       * ```
       */
      getElement(index, target) {
        const normalized = this.getNormalized();
        const elementSize = this.getElementSize();
        const componentType = this.getComponentType();
        const array = this.getArray();
        for (let i = 0; i < elementSize; i++) {
          if (normalized) {
            target[i] = MathUtils.decodeNormalizedInt(array[index * elementSize + i], componentType);
          } else {
            target[i] = array[index * elementSize + i];
          }
        }
        return target;
      }
      /**
       * Assigns the vector or matrix element value at the given index. For
       * {@link Accessor.getNormalized normalized} integer accessors, "value" should be
       * given in floating-point form — it will be integer-encoded before writing
       * to the underlying array.
       *
       * Example:
       *
       * ```javascript
       * import { add } from 'gl-matrix/add';
       *
       * const element = [];
       * const offset = [1, 1, 1];
       *
       * for (let i = 0; i < accessor.getCount(); i++) {
       * 	accessor.getElement(i, element);
       * 	add(element, element, offset);
       * 	accessor.setElement(i, element);
       * }
       * ```
       */
      setElement(index, value2) {
        const normalized = this.getNormalized();
        const elementSize = this.getElementSize();
        const componentType = this.getComponentType();
        const array = this.getArray();
        for (let i = 0; i < elementSize; i++) {
          if (normalized) {
            array[index * elementSize + i] = MathUtils.encodeNormalizedInt(value2[i], componentType);
          } else {
            array[index * elementSize + i] = value2[i];
          }
        }
        return this;
      }
      /**********************************************************************************************
       * Raw data storage.
       */
      /**
       * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse
       * accessors store only values that differ from base values. When loaded in glTF Transform (or most
       * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always
       * uses zeroes for the base values when writing files.
       * @experimental
       */
      getSparse() {
        return this.get("sparse");
      }
      /**
       * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse
       * accessors store only values that differ from base values. When loaded in glTF Transform (or most
       * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always
       * uses zeroes for the base values when writing files.
       * @experimental
       */
      setSparse(sparse) {
        return this.set("sparse", sparse);
      }
      /** Returns the {@link Buffer} into which this accessor will be organized. */
      getBuffer() {
        return this.getRef("buffer");
      }
      /** Assigns the {@link Buffer} into which this accessor will be organized. */
      setBuffer(buffer) {
        return this.setRef("buffer", buffer);
      }
      /** Returns the raw typed array underlying this accessor. */
      getArray() {
        return this.get("array");
      }
      /** Assigns the raw typed array underlying this accessor. */
      setArray(array) {
        this.set("componentType", array ? arrayToComponentType(array) : _Accessor.ComponentType.FLOAT);
        this.set("array", array);
        return this;
      }
      /** Returns the total bytelength of this accessor, exclusive of padding. */
      getByteLength() {
        const array = this.get("array");
        return array ? array.byteLength : 0;
      }
    };
    Accessor.Type = {
      /** Scalar, having 1 value per element. */
      SCALAR: "SCALAR",
      /** 2-component vector, having 2 components per element. */
      VEC2: "VEC2",
      /** 3-component vector, having 3 components per element. */
      VEC3: "VEC3",
      /** 4-component vector, having 4 components per element. */
      VEC4: "VEC4",
      /** 2x2 matrix, having 4 components per element. */
      MAT2: "MAT2",
      /** 3x3 matrix, having 9 components per element. */
      MAT3: "MAT3",
      /** 4x3 matrix, having 16 components per element. */
      MAT4: "MAT4"
    };
    Accessor.ComponentType = {
      /**
       * 1-byte signed integer, stored as
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array Int8Array}.
       */
      BYTE: 5120,
      /**
       * 1-byte unsigned integer, stored as
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array Uint8Array}.
       */
      UNSIGNED_BYTE: 5121,
      /**
       * 2-byte signed integer, stored as
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array Int16Array}.
       */
      SHORT: 5122,
      /**
       * 2-byte unsigned integer, stored as
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.
       */
      UNSIGNED_SHORT: 5123,
      /**
       * 4-byte unsigned integer, stored as
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array Uint32Array}.
       */
      UNSIGNED_INT: 5125,
      /**
       * 4-byte floating point number, stored as
       * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array Float32Array}.
       */
      FLOAT: 5126
    };
    Animation = class extends ExtensibleProperty {
      init() {
        this.propertyType = PropertyType.ANIMATION;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          channels: new RefSet(),
          samplers: new RefSet()
        });
      }
      /** Adds an {@link AnimationChannel} to this Animation. */
      addChannel(channel) {
        return this.addRef("channels", channel);
      }
      /** Removes an {@link AnimationChannel} from this Animation. */
      removeChannel(channel) {
        return this.removeRef("channels", channel);
      }
      /** Lists {@link AnimationChannel}s in this Animation. */
      listChannels() {
        return this.listRefs("channels");
      }
      /** Adds an {@link AnimationSampler} to this Animation. */
      addSampler(sampler) {
        return this.addRef("samplers", sampler);
      }
      /** Removes an {@link AnimationSampler} from this Animation. */
      removeSampler(sampler) {
        return this.removeRef("samplers", sampler);
      }
      /** Lists {@link AnimationSampler}s in this Animation. */
      listSamplers() {
        return this.listRefs("samplers");
      }
    };
    AnimationChannel = class extends ExtensibleProperty {
      /**********************************************************************************************
       * Instance.
       */
      init() {
        this.propertyType = PropertyType.ANIMATION_CHANNEL;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          targetPath: null,
          targetNode: null,
          sampler: null
        });
      }
      /**********************************************************************************************
       * Properties.
       */
      /**
       * Path (property) animated on the target {@link Node}. Supported values include:
       * `translation`, `rotation`, `scale`, or `weights`.
       */
      getTargetPath() {
        return this.get("targetPath");
      }
      /**
       * Path (property) animated on the target {@link Node}. Supported values include:
       * `translation`, `rotation`, `scale`, or `weights`.
       */
      setTargetPath(targetPath) {
        return this.set("targetPath", targetPath);
      }
      /** Target {@link Node} animated by the channel. */
      getTargetNode() {
        return this.getRef("targetNode");
      }
      /** Target {@link Node} animated by the channel. */
      setTargetNode(targetNode) {
        return this.setRef("targetNode", targetNode);
      }
      /**
       * Keyframe data input/output values for the channel. Must be attached to the same
       * {@link Animation}.
       */
      getSampler() {
        return this.getRef("sampler");
      }
      /**
       * Keyframe data input/output values for the channel. Must be attached to the same
       * {@link Animation}.
       */
      setSampler(sampler) {
        return this.setRef("sampler", sampler);
      }
    };
    AnimationChannel.TargetPath = {
      /** Channel targets {@link Node.setTranslation}. */
      TRANSLATION: "translation",
      /** Channel targets {@link Node.setRotation}. */
      ROTATION: "rotation",
      /** Channel targets {@link Node.setScale}. */
      SCALE: "scale",
      /** Channel targets {@link Node.setWeights}, affecting {@link PrimitiveTarget} weights. */
      WEIGHTS: "weights"
    };
    AnimationSampler = class _AnimationSampler extends ExtensibleProperty {
      /**********************************************************************************************
       * Instance.
       */
      init() {
        this.propertyType = PropertyType.ANIMATION_SAMPLER;
      }
      getDefaultAttributes() {
        return Object.assign(super.getDefaults(), {
          interpolation: _AnimationSampler.Interpolation.LINEAR,
          input: null,
          output: null
        });
      }
      /**********************************************************************************************
       * Static.
       */
      /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */
      getInterpolation() {
        return this.get("interpolation");
      }
      /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */
      setInterpolation(interpolation) {
        return this.set("interpolation", interpolation);
      }
      /** Times for each keyframe, in seconds. */
      getInput() {
        return this.getRef("input");
      }
      /** Times for each keyframe, in seconds. */
      setInput(input) {
        return this.setRef("input", input, {
          usage: BufferViewUsage$1.OTHER
        });
      }
      /**
       * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out
       * tangents.
       */
      getOutput() {
        return this.getRef("output");
      }
      /**
       * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out
       * tangents.
       */
      setOutput(output) {
        return this.setRef("output", output, {
          usage: BufferViewUsage$1.OTHER
        });
      }
    };
    AnimationSampler.Interpolation = {
      /** Animated values are linearly interpolated between keyframes. */
      LINEAR: "LINEAR",
      /** Animated values remain constant from one keyframe until the next keyframe. */
      STEP: "STEP",
      /** Animated values are interpolated according to given cubic spline tangents. */
      CUBICSPLINE: "CUBICSPLINE"
    };
    Buffer$1 = class extends ExtensibleProperty {
      init() {
        this.propertyType = PropertyType.BUFFER;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          uri: ""
        });
      }
      /**
       * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly
       * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)
       * is possible for custom applications, but will limit the compatibility of the asset with most
       * tools.
       *
       * Buffers commonly use the extension `.bin`, though this is not required.
       */
      getURI() {
        return this.get("uri");
      }
      /**
       * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly
       * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)
       * is possible for custom applications, but will limit the compatibility of the asset with most
       * tools.
       *
       * Buffers commonly use the extension `.bin`, though this is not required.
       */
      setURI(uri) {
        return this.set("uri", uri);
      }
    };
    Camera = class _Camera extends ExtensibleProperty {
      /**********************************************************************************************
       * Instance.
       */
      init() {
        this.propertyType = PropertyType.CAMERA;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          // Common.
          type: _Camera.Type.PERSPECTIVE,
          znear: 0.1,
          zfar: 100,
          // Perspective.
          aspectRatio: null,
          yfov: Math.PI * 2 * 50 / 360,
          // 50º
          // Orthographic.
          xmag: 1,
          ymag: 1
        });
      }
      /**********************************************************************************************
       * Common.
       */
      /** Specifies if the camera uses a perspective or orthographic projection. */
      getType() {
        return this.get("type");
      }
      /** Specifies if the camera uses a perspective or orthographic projection. */
      setType(type) {
        return this.set("type", type);
      }
      /** Floating-point distance to the near clipping plane. */
      getZNear() {
        return this.get("znear");
      }
      /** Floating-point distance to the near clipping plane. */
      setZNear(znear) {
        return this.set("znear", znear);
      }
      /**
       * Floating-point distance to the far clipping plane. When defined, zfar must be greater than
       * znear. If zfar is undefined, runtime must use infinite projection matrix.
       */
      getZFar() {
        return this.get("zfar");
      }
      /**
       * Floating-point distance to the far clipping plane. When defined, zfar must be greater than
       * znear. If zfar is undefined, runtime must use infinite projection matrix.
       */
      setZFar(zfar) {
        return this.set("zfar", zfar);
      }
      /**********************************************************************************************
       * Perspective.
       */
      /**
       * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the
       * canvas is used.
       */
      getAspectRatio() {
        return this.get("aspectRatio");
      }
      /**
       * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the
       * canvas is used.
       */
      setAspectRatio(aspectRatio) {
        return this.set("aspectRatio", aspectRatio);
      }
      /** Floating-point vertical field of view in radians. */
      getYFov() {
        return this.get("yfov");
      }
      /** Floating-point vertical field of view in radians. */
      setYFov(yfov) {
        return this.set("yfov", yfov);
      }
      /**********************************************************************************************
       * Orthographic.
       */
      /**
       * Floating-point horizontal magnification of the view, and half the view's width
       * in world units.
       */
      getXMag() {
        return this.get("xmag");
      }
      /**
       * Floating-point horizontal magnification of the view, and half the view's width
       * in world units.
       */
      setXMag(xmag) {
        return this.set("xmag", xmag);
      }
      /**
       * Floating-point vertical magnification of the view, and half the view's height
       * in world units.
       */
      getYMag() {
        return this.get("ymag");
      }
      /**
       * Floating-point vertical magnification of the view, and half the view's height
       * in world units.
       */
      setYMag(ymag) {
        return this.set("ymag", ymag);
      }
    };
    Camera.Type = {
      /** A perspective camera representing a perspective projection matrix. */
      PERSPECTIVE: "perspective",
      /** An orthographic camera representing an orthographic projection matrix. */
      ORTHOGRAPHIC: "orthographic"
    };
    ExtensionProperty = class extends Property {
      /** @hidden */
      _validateParent(parent) {
        if (!this.parentTypes.includes(parent.propertyType)) {
          throw new Error(`Parent "${parent.propertyType}" invalid for child "${this.propertyType}".`);
        }
      }
    };
    ExtensionProperty.EXTENSION_NAME = void 0;
    TextureInfo = class _TextureInfo extends ExtensibleProperty {
      /**********************************************************************************************
       * Instance.
       */
      init() {
        this.propertyType = PropertyType.TEXTURE_INFO;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          texCoord: 0,
          magFilter: null,
          minFilter: null,
          wrapS: _TextureInfo.WrapMode.REPEAT,
          wrapT: _TextureInfo.WrapMode.REPEAT
        });
      }
      /**********************************************************************************************
       * Texture coordinates.
       */
      /** Returns the texture coordinate (UV set) index for the texture. */
      getTexCoord() {
        return this.get("texCoord");
      }
      /** Sets the texture coordinate (UV set) index for the texture. */
      setTexCoord(texCoord) {
        return this.set("texCoord", texCoord);
      }
      /**********************************************************************************************
       * Min/mag filter.
       */
      /** Returns the magnification filter applied to the texture. */
      getMagFilter() {
        return this.get("magFilter");
      }
      /** Sets the magnification filter applied to the texture. */
      setMagFilter(magFilter) {
        return this.set("magFilter", magFilter);
      }
      /** Sets the minification filter applied to the texture. */
      getMinFilter() {
        return this.get("minFilter");
      }
      /** Returns the minification filter applied to the texture. */
      setMinFilter(minFilter) {
        return this.set("minFilter", minFilter);
      }
      /**********************************************************************************************
       * UV wrapping.
       */
      /** Returns the S (U) wrapping mode for UVs used by the texture. */
      getWrapS() {
        return this.get("wrapS");
      }
      /** Sets the S (U) wrapping mode for UVs used by the texture. */
      setWrapS(wrapS) {
        return this.set("wrapS", wrapS);
      }
      /** Returns the T (V) wrapping mode for UVs used by the texture. */
      getWrapT() {
        return this.get("wrapT");
      }
      /** Sets the T (V) wrapping mode for UVs used by the texture. */
      setWrapT(wrapT) {
        return this.set("wrapT", wrapT);
      }
    };
    TextureInfo.WrapMode = {
      /** */
      CLAMP_TO_EDGE: 33071,
      /** */
      MIRRORED_REPEAT: 33648,
      /** */
      REPEAT: 10497
    };
    TextureInfo.MagFilter = {
      /** */
      NEAREST: 9728,
      /** */
      LINEAR: 9729
    };
    TextureInfo.MinFilter = {
      /** */
      NEAREST: 9728,
      /** */
      LINEAR: 9729,
      /** */
      NEAREST_MIPMAP_NEAREST: 9984,
      /** */
      LINEAR_MIPMAP_NEAREST: 9985,
      /** */
      NEAREST_MIPMAP_LINEAR: 9986,
      /** */
      LINEAR_MIPMAP_LINEAR: 9987
    };
    ({
      R,
      G,
      B,
      A
    } = TextureChannel);
    Material = class _Material extends ExtensibleProperty {
      /**********************************************************************************************
       * Instance.
       */
      init() {
        this.propertyType = PropertyType.MATERIAL;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          alphaMode: _Material.AlphaMode.OPAQUE,
          alphaCutoff: 0.5,
          doubleSided: false,
          baseColorFactor: [1, 1, 1, 1],
          baseColorTexture: null,
          baseColorTextureInfo: new TextureInfo(this.graph, "baseColorTextureInfo"),
          emissiveFactor: [0, 0, 0],
          emissiveTexture: null,
          emissiveTextureInfo: new TextureInfo(this.graph, "emissiveTextureInfo"),
          normalScale: 1,
          normalTexture: null,
          normalTextureInfo: new TextureInfo(this.graph, "normalTextureInfo"),
          occlusionStrength: 1,
          occlusionTexture: null,
          occlusionTextureInfo: new TextureInfo(this.graph, "occlusionTextureInfo"),
          roughnessFactor: 1,
          metallicFactor: 1,
          metallicRoughnessTexture: null,
          metallicRoughnessTextureInfo: new TextureInfo(this.graph, "metallicRoughnessTextureInfo")
        });
      }
      /**********************************************************************************************
       * Double-sided / culling.
       */
      /** Returns true when both sides of triangles should be rendered. May impact performance. */
      getDoubleSided() {
        return this.get("doubleSided");
      }
      /** Sets whether to render both sides of triangles. May impact performance. */
      setDoubleSided(doubleSided) {
        return this.set("doubleSided", doubleSided);
      }
      /**********************************************************************************************
       * Alpha.
       */
      /** Returns material alpha, equivalent to baseColorFactor[3]. */
      getAlpha() {
        return this.get("baseColorFactor")[3];
      }
      /** Sets material alpha, equivalent to baseColorFactor[3]. */
      setAlpha(alpha) {
        const baseColorFactor = this.get("baseColorFactor").slice();
        baseColorFactor[3] = alpha;
        return this.set("baseColorFactor", baseColorFactor);
      }
      /**
       * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`
       * and `baseColorTexture`.
       *
       * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.
       * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and
       * 	the fraction of surface vs. background color in the final result. Alpha blending creates
       *	significant edge cases in realtime renderers, and some care when structuring the model is
       * 	necessary for good results. In particular, transparent geometry should be kept in separate
       * 	meshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines
       * 	should usually be disabled on transparent materials.
       * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a
       * 	surface, and the pixel is either fully visible or fully discarded based on that cutoff.
       * 	This technique is useful for things like leafs/foliage, grass, fabric meshes, and other
       * 	surfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces
       * 	that don't require semitransparency can avoid the performance penalties and visual issues
       * 	involved with `BLEND` transparency.
       *
       * Reference:
       * - [glTF → material.alphaMode](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialalphamode)
       */
      getAlphaMode() {
        return this.get("alphaMode");
      }
      /** Sets the mode of the material's alpha channels. See {@link Material.getAlphaMode getAlphaMode} for details. */
      setAlphaMode(alphaMode) {
        return this.set("alphaMode", alphaMode);
      }
      /** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */
      getAlphaCutoff() {
        return this.get("alphaCutoff");
      }
      /** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */
      setAlphaCutoff(alphaCutoff) {
        return this.set("alphaCutoff", alphaCutoff);
      }
      /**********************************************************************************************
       * Base color.
       */
      /**
       * Base color / albedo factor; Linear-sRGB components.
       * See {@link Material.getBaseColorTexture getBaseColorTexture}.
       */
      getBaseColorFactor() {
        return this.get("baseColorFactor");
      }
      /**
       * Base color / albedo factor; Linear-sRGB components.
       * See {@link Material.getBaseColorTexture getBaseColorTexture}.
       */
      setBaseColorFactor(baseColorFactor) {
        return this.set("baseColorFactor", baseColorFactor);
      }
      /**
       * Base color / albedo. The visible color of a non-metallic surface under constant ambient
       * light would be a linear combination (multiplication) of its vertex colors, base color
       * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,
       * also effect the final color. The alpha (`.a`) channel of base color factors and textures
       * will have varying effects, based on the setting of {@link Material.getAlphaMode getAlphaMode}.
       *
       * Reference:
       * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)
       */
      getBaseColorTexture() {
        return this.getRef("baseColorTexture");
      }
      /**
       * Settings affecting the material's use of its base color texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getBaseColorTextureInfo() {
        return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null;
      }
      /** Sets base color / albedo texture. See {@link Material.getBaseColorTexture getBaseColorTexture}. */
      setBaseColorTexture(texture) {
        return this.setRef("baseColorTexture", texture, {
          channels: R | G | B | A,
          isColor: true
        });
      }
      /**********************************************************************************************
       * Emissive.
       */
      /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */
      getEmissiveFactor() {
        return this.get("emissiveFactor");
      }
      /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */
      setEmissiveFactor(emissiveFactor) {
        return this.set("emissiveFactor", emissiveFactor);
      }
      /**
       * Emissive texture. Emissive color is added to any base color of the material, after any
       * lighting/shadowing are applied. An emissive color does not inherently "glow", or affect
       * objects around it at all. To create that effect, most viewers must also enable a
       * post-processing effect called "bloom".
       *
       * Reference:
       * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialemissivetexture)
       */
      getEmissiveTexture() {
        return this.getRef("emissiveTexture");
      }
      /**
       * Settings affecting the material's use of its emissive texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getEmissiveTextureInfo() {
        return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null;
      }
      /** Sets emissive texture. See {@link Material.getEmissiveTexture getEmissiveTexture}. */
      setEmissiveTexture(texture) {
        return this.setRef("emissiveTexture", texture, {
          channels: R | G | B,
          isColor: true
        });
      }
      /**********************************************************************************************
       * Normal.
       */
      /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */
      getNormalScale() {
        return this.get("normalScale");
      }
      /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */
      setNormalScale(scale) {
        return this.set("normalScale", scale);
      }
      /**
       * Normal (surface detail) texture.
       *
       * A tangent space normal map. The texture contains RGB components. Each texel represents the
       * XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1].
       * Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal
       * vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer.
       *
       * Reference:
       * - [glTF → material.normalTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialnormaltexture)
       */
      getNormalTexture() {
        return this.getRef("normalTexture");
      }
      /**
       * Settings affecting the material's use of its normal texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getNormalTextureInfo() {
        return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null;
      }
      /** Sets normal (surface detail) texture. See {@link Material.getNormalTexture getNormalTexture}. */
      setNormalTexture(texture) {
        return this.setRef("normalTexture", texture, {
          channels: R | G | B
        });
      }
      /**********************************************************************************************
       * Occlusion.
       */
      /** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */
      getOcclusionStrength() {
        return this.get("occlusionStrength");
      }
      /** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */
      setOcclusionStrength(strength) {
        return this.set("occlusionStrength", strength);
      }
      /**
       * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are
       * independent of an object's position, such as shading in inset areas and corners. Direct
       * lighting is not affected by occlusion, so at least one indirect light source must be present
       * in the scene for occlusion effects to be visible.
       *
       * The occlusion values are sampled from the R channel. Higher values indicate areas that
       * should receive full indirect lighting and lower values indicate no indirect lighting.
       *
       * Reference:
       * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialocclusiontexture)
       */
      getOcclusionTexture() {
        return this.getRef("occlusionTexture");
      }
      /**
       * Settings affecting the material's use of its occlusion texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getOcclusionTextureInfo() {
        return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null;
      }
      /** Sets (ambient) occlusion texture. See {@link Material.getOcclusionTexture getOcclusionTexture}. */
      setOcclusionTexture(texture) {
        return this.setRef("occlusionTexture", texture, {
          channels: R
        });
      }
      /**********************************************************************************************
       * Metallic / roughness.
       */
      /**
       * Roughness factor; linear multiplier. Affects roughness channel of
       * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
       */
      getRoughnessFactor() {
        return this.get("roughnessFactor");
      }
      /**
       * Sets roughness factor; linear multiplier. Affects roughness channel of
       * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
       */
      setRoughnessFactor(factor) {
        return this.set("roughnessFactor", factor);
      }
      /**
       * Metallic factor; linear multiplier. Affects roughness channel of
       * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
       */
      getMetallicFactor() {
        return this.get("metallicFactor");
      }
      /**
       * Sets metallic factor; linear multiplier. Affects roughness channel of
       * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
       */
      setMetallicFactor(factor) {
        return this.set("metallicFactor", factor);
      }
      /**
       * Metallic roughness texture. The metalness values are sampled from the B channel. The
       * roughness values are sampled from the G channel. When a material is fully metallic,
       * or nearly so, it may require image-based lighting (i.e. an environment map) or global
       * illumination to appear well-lit.
       *
       * Reference:
       * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)
       */
      getMetallicRoughnessTexture() {
        return this.getRef("metallicRoughnessTexture");
      }
      /**
       * Settings affecting the material's use of its metallic/roughness texture. If no texture is
       * attached, {@link TextureInfo} is `null`.
       */
      getMetallicRoughnessTextureInfo() {
        return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null;
      }
      /**
       * Sets metallic/roughness texture.
       * See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
       */
      setMetallicRoughnessTexture(texture) {
        return this.setRef("metallicRoughnessTexture", texture, {
          channels: G | B
        });
      }
    };
    Material.AlphaMode = {
      /**
       * The alpha value is ignored and the rendered output is fully opaque
       */
      OPAQUE: "OPAQUE",
      /**
       * The rendered output is either fully opaque or fully transparent depending on the alpha
       * value and the specified alpha cutoff value
       */
      MASK: "MASK",
      /**
       * The alpha value is used to composite the source and destination areas. The rendered
       * output is combined with the background using the normal painting operation (i.e. the
       * Porter and Duff over operator)
       */
      BLEND: "BLEND"
    };
    Mesh = class extends ExtensibleProperty {
      init() {
        this.propertyType = PropertyType.MESH;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          weights: [],
          primitives: new RefSet()
        });
      }
      /** Adds a {@link Primitive} to the mesh's draw call list. */
      addPrimitive(primitive) {
        return this.addRef("primitives", primitive);
      }
      /** Removes a {@link Primitive} from the mesh's draw call list. */
      removePrimitive(primitive) {
        return this.removeRef("primitives", primitive);
      }
      /** Lists {@link Primitive} draw calls of the mesh. */
      listPrimitives() {
        return this.listRefs("primitives");
      }
      /**
       * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must
       * have the same number of targets. Most engines only support 4-8 active morph targets at a
       * time.
       */
      getWeights() {
        return this.get("weights");
      }
      /**
       * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must
       * have the same number of targets. Most engines only support 4-8 active morph targets at a
       * time.
       */
      setWeights(weights) {
        return this.set("weights", weights);
      }
    };
    Node = class extends ExtensibleProperty {
      init() {
        this.propertyType = PropertyType.NODE;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          translation: [0, 0, 0],
          rotation: [0, 0, 0, 1],
          scale: [1, 1, 1],
          weights: [],
          camera: null,
          mesh: null,
          skin: null,
          children: new RefSet()
        });
      }
      copy(other, resolve = COPY_IDENTITY) {
        if (resolve === COPY_IDENTITY) throw new Error("Node cannot be copied.");
        return super.copy(other, resolve);
      }
      /**********************************************************************************************
       * Local transform.
       */
      /** Returns the translation (position) of this Node in local space. */
      getTranslation() {
        return this.get("translation");
      }
      /** Returns the rotation (quaternion) of this Node in local space. */
      getRotation() {
        return this.get("rotation");
      }
      /** Returns the scale of this Node in local space. */
      getScale() {
        return this.get("scale");
      }
      /** Sets the translation (position) of this Node in local space. */
      setTranslation(translation) {
        return this.set("translation", translation);
      }
      /** Sets the rotation (quaternion) of this Node in local space. */
      setRotation(rotation) {
        return this.set("rotation", rotation);
      }
      /** Sets the scale of this Node in local space. */
      setScale(scale) {
        return this.set("scale", scale);
      }
      /** Returns the local matrix of this Node. */
      getMatrix() {
        return MathUtils.compose(this.get("translation"), this.get("rotation"), this.get("scale"), []);
      }
      /** Sets the local matrix of this Node. Matrix will be decomposed to TRS properties. */
      setMatrix(matrix) {
        const translation = this.get("translation").slice();
        const rotation = this.get("rotation").slice();
        const scale = this.get("scale").slice();
        MathUtils.decompose(matrix, translation, rotation, scale);
        return this.set("translation", translation).set("rotation", rotation).set("scale", scale);
      }
      /**********************************************************************************************
       * World transform.
       */
      /** Returns the translation (position) of this Node in world space. */
      getWorldTranslation() {
        const t = [0, 0, 0];
        MathUtils.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]);
        return t;
      }
      /** Returns the rotation (quaternion) of this Node in world space. */
      getWorldRotation() {
        const r = [0, 0, 0, 1];
        MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], r, [1, 1, 1]);
        return r;
      }
      /** Returns the scale of this Node in world space. */
      getWorldScale() {
        const s = [1, 1, 1];
        MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], s);
        return s;
      }
      /** Returns the world matrix of this Node. */
      getWorldMatrix() {
        const ancestors = [];
        for (let node = this; node != null; node = node.getParentNode()) {
          ancestors.push(node);
        }
        let ancestor;
        const worldMatrix = ancestors.pop().getMatrix();
        while (ancestor = ancestors.pop()) {
          multiply(worldMatrix, worldMatrix, ancestor.getMatrix());
        }
        return worldMatrix;
      }
      /**********************************************************************************************
       * Scene hierarchy.
       */
      /**
       * Adds the given Node as a child of this Node.
       *
       * Requirements:
       *
       * 1. Nodes MAY be root children of multiple {@link Scene Scenes}
       * 2. Nodes MUST NOT be children of >1 Node
       * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}
       *
       * The `addChild` method enforces these restrictions automatically, and will
       * remove the new child from previous parents where needed. This behavior
       * may change in future major releases of the library.
       */
      addChild(child) {
        const parentNode = child.getParentNode();
        if (parentNode) parentNode.removeChild(child);
        for (const parent of child.listParents()) {
          if (parent.propertyType === PropertyType.SCENE) {
            parent.removeChild(child);
          }
        }
        return this.addRef("children", child);
      }
      /** Removes a Node from this Node's child Node list. */
      removeChild(child) {
        return this.removeRef("children", child);
      }
      /** Lists all child Nodes of this Node. */
      listChildren() {
        return this.listRefs("children");
      }
      /**
       * Returns the Node's unique parent Node within the scene graph. If the
       * Node has no parents, or is a direct child of the {@link Scene}
       * ("root node"), this method returns null.
       *
       * Unrelated to {@link Property.listParents}, which lists all resource
       * references from properties of any type ({@link Skin}, {@link Root}, ...).
       */
      getParentNode() {
        for (const parent of this.listParents()) {
          if (parent.propertyType === PropertyType.NODE) {
            return parent;
          }
        }
        return null;
      }
      /**********************************************************************************************
       * Attachments.
       */
      /** Returns the {@link Mesh}, if any, instantiated at this Node. */
      getMesh() {
        return this.getRef("mesh");
      }
      /**
       * Sets a {@link Mesh} to be instantiated at this Node. A single mesh may be instantiated by
       * multiple Nodes; reuse of this sort is strongly encouraged.
       */
      setMesh(mesh) {
        return this.setRef("mesh", mesh);
      }
      /** Returns the {@link Camera}, if any, instantiated at this Node. */
      getCamera() {
        return this.getRef("camera");
      }
      /** Sets a {@link Camera} to be instantiated at this Node. */
      setCamera(camera) {
        return this.setRef("camera", camera);
      }
      /** Returns the {@link Skin}, if any, instantiated at this Node. */
      getSkin() {
        return this.getRef("skin");
      }
      /** Sets a {@link Skin} to be instantiated at this Node. */
      setSkin(skin) {
        return this.setRef("skin", skin);
      }
      /**
       * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.
       * Most engines only support 4-8 active morph targets at a time.
       */
      getWeights() {
        return this.get("weights");
      }
      /**
       * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.
       * Most engines only support 4-8 active morph targets at a time.
       */
      setWeights(weights) {
        return this.set("weights", weights);
      }
      /**********************************************************************************************
       * Helpers.
       */
      /** Visits this {@link Node} and its descendants, top-down. */
      traverse(fn) {
        fn(this);
        for (const child of this.listChildren()) child.traverse(fn);
        return this;
      }
    };
    Primitive = class _Primitive extends ExtensibleProperty {
      /**********************************************************************************************
       * Instance.
       */
      init() {
        this.propertyType = PropertyType.PRIMITIVE;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          mode: _Primitive.Mode.TRIANGLES,
          material: null,
          indices: null,
          attributes: new RefMap(),
          targets: new RefSet()
        });
      }
      /**********************************************************************************************
       * Primitive data.
       */
      /** Returns an {@link Accessor} with indices of vertices to be drawn. */
      getIndices() {
        return this.getRef("indices");
      }
      /**
       * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,
       * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)
       * winding order.
       */
      setIndices(indices) {
        return this.setRef("indices", indices, {
          usage: BufferViewUsage$1.ELEMENT_ARRAY_BUFFER
        });
      }
      /** Returns a vertex attribute as an {@link Accessor}. */
      getAttribute(semantic) {
        return this.getRefMap("attributes", semantic);
      }
      /**
       * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex
       * count.
       */
      setAttribute(semantic, accessor) {
        return this.setRefMap("attributes", semantic, accessor, {
          usage: BufferViewUsage$1.ARRAY_BUFFER
        });
      }
      /**
       * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any
       * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,
       * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().
       */
      listAttributes() {
        return this.listRefMapValues("attributes");
      }
      /**
       * Lists all vertex attribute semantics associated with the primitive, excluding any semantics
       * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be
       * consistent with the order returned by {@link .listAttributes}().
       */
      listSemantics() {
        return this.listRefMapKeys("attributes");
      }
      /** Returns the material used to render the primitive. */
      getMaterial() {
        return this.getRef("material");
      }
      /** Sets the material used to render the primitive. */
      setMaterial(material) {
        return this.setRef("material", material);
      }
      /**********************************************************************************************
       * Mode.
       */
      /**
       * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.
       *
       * Reference:
       * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)
       */
      getMode() {
        return this.get("mode");
      }
      /**
       * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.
       *
       * Reference:
       * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)
       */
      setMode(mode) {
        return this.set("mode", mode);
      }
      /**********************************************************************************************
       * Morph targets.
       */
      /** Lists all morph targets associated with the primitive. */
      listTargets() {
        return this.listRefs("targets");
      }
      /**
       * Adds a morph target to the primitive. All primitives in the same mesh must have the same
       * number of targets.
       */
      addTarget(target) {
        return this.addRef("targets", target);
      }
      /**
       * Removes a morph target from the primitive. All primitives in the same mesh must have the same
       * number of targets.
       */
      removeTarget(target) {
        return this.removeRef("targets", target);
      }
    };
    Primitive.Mode = {
      /** Draw single points. */
      POINTS: 0,
      /** Draw lines. Each vertex connects to the one after it. */
      LINES: 1,
      /**
       * Draw lines. Each set of two vertices is treated as a separate line segment.
       * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.
       */
      LINE_LOOP: 2,
      /** Draw a connected group of line segments from the first vertex to the last,  */
      LINE_STRIP: 3,
      /** Draw triangles. Each set of three vertices creates a separate triangle. */
      TRIANGLES: 4,
      /** Draw a connected strip of triangles. */
      TRIANGLE_STRIP: 5,
      /**
       * Draw a connected group of triangles. Each vertex connects to the previous and the first
       * vertex in the fan.
       * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.
       */
      TRIANGLE_FAN: 6
    };
    PrimitiveTarget = class extends Property {
      init() {
        this.propertyType = PropertyType.PRIMITIVE_TARGET;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          attributes: new RefMap()
        });
      }
      /** Returns a morph target vertex attribute as an {@link Accessor}. */
      getAttribute(semantic) {
        return this.getRefMap("attributes", semantic);
      }
      /**
       * Sets a morph target vertex attribute to an {@link Accessor}.
       */
      setAttribute(semantic, accessor) {
        return this.setRefMap("attributes", semantic, accessor, {
          usage: BufferViewUsage$1.ARRAY_BUFFER
        });
      }
      /**
       * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be
       * consistent with the order returned by {@link .listSemantics}().
       */
      listAttributes() {
        return this.listRefMapValues("attributes");
      }
      /**
       * Lists all morph target vertex attribute semantics associated. Order will be
       * consistent with the order returned by {@link .listAttributes}().
       */
      listSemantics() {
        return this.listRefMapKeys("attributes");
      }
    };
    Scene = class extends ExtensibleProperty {
      init() {
        this.propertyType = PropertyType.SCENE;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          children: new RefSet()
        });
      }
      copy(other, resolve = COPY_IDENTITY) {
        if (resolve === COPY_IDENTITY) throw new Error("Scene cannot be copied.");
        return super.copy(other, resolve);
      }
      /**
       * Adds a {@link Node} to the Scene.
       *
       * Requirements:
       *
       * 1. Nodes MAY be root children of multiple {@link Scene Scenes}
       * 2. Nodes MUST NOT be children of >1 Node
       * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}
       *
       * The `addChild` method enforces these restrictions automatically, and will
       * remove the new child from previous parents where needed. This behavior
       * may change in future major releases of the library.
       */
      addChild(node) {
        const parentNode = node.getParentNode();
        if (parentNode) parentNode.removeChild(node);
        return this.addRef("children", node);
      }
      /** Removes a {@link Node} from the Scene. */
      removeChild(node) {
        return this.removeRef("children", node);
      }
      /**
       * Lists all direct child {@link Node Nodes} in the Scene. Indirect
       * descendants (children of children) are not returned, but may be
       * reached recursively or with {@link Scene.traverse} instead.
       */
      listChildren() {
        return this.listRefs("children");
      }
      /** Visits each {@link Node} in the Scene, including descendants, top-down. */
      traverse(fn) {
        for (const node of this.listChildren()) node.traverse(fn);
        return this;
      }
    };
    Skin = class extends ExtensibleProperty {
      init() {
        this.propertyType = PropertyType.SKIN;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          skeleton: null,
          inverseBindMatrices: null,
          joints: new RefSet()
        });
      }
      /**
       * {@link Node} used as a skeleton root. The node must be the closest common root of the joints
       * hierarchy or a direct or indirect parent node of the closest common root.
       */
      getSkeleton() {
        return this.getRef("skeleton");
      }
      /**
       * {@link Node} used as a skeleton root. The node must be the closest common root of the joints
       * hierarchy or a direct or indirect parent node of the closest common root.
       */
      setSkeleton(skeleton) {
        return this.setRef("skeleton", skeleton);
      }
      /**
       * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is
       * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were
       * pre-applied.
       */
      getInverseBindMatrices() {
        return this.getRef("inverseBindMatrices");
      }
      /**
       * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is
       * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were
       * pre-applied.
       */
      setInverseBindMatrices(inverseBindMatrices) {
        return this.setRef("inverseBindMatrices", inverseBindMatrices, {
          usage: BufferViewUsage$1.INVERSE_BIND_MATRICES
        });
      }
      /** Adds a joint {@link Node} to this {@link Skin}. */
      addJoint(joint) {
        return this.addRef("joints", joint);
      }
      /** Removes a joint {@link Node} from this {@link Skin}. */
      removeJoint(joint) {
        return this.removeRef("joints", joint);
      }
      /** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */
      listJoints() {
        return this.listRefs("joints");
      }
    };
    Texture = class extends ExtensibleProperty {
      init() {
        this.propertyType = PropertyType.TEXTURE;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          image: null,
          mimeType: "",
          uri: ""
        });
      }
      /**********************************************************************************************
       * MIME type / format.
       */
      /** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */
      getMimeType() {
        return this.get("mimeType") || ImageUtils.extensionToMimeType(FileUtils.extension(this.get("uri")));
      }
      /**
       * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not
       * have a URI, a MIME type is required for correct export.
       */
      setMimeType(mimeType) {
        return this.set("mimeType", mimeType);
      }
      /**********************************************************************************************
       * URI / filename.
       */
      /** Returns the URI (e.g. 'path/to/file.png') for this texture. */
      getURI() {
        return this.get("uri");
      }
      /**
       * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME
       * type, a URI is required for correct export.
       */
      setURI(uri) {
        this.set("uri", uri);
        const mimeType = ImageUtils.extensionToMimeType(FileUtils.extension(uri));
        if (mimeType) this.set("mimeType", mimeType);
        return this;
      }
      /**********************************************************************************************
       * Image data.
       */
      /** Returns the raw image data for this texture. */
      getImage() {
        return this.get("image");
      }
      /** Sets the raw image data for this texture. */
      setImage(image) {
        return this.set("image", BufferUtils.assertView(image));
      }
      /** Returns the size, in pixels, of this texture. */
      getSize() {
        const image = this.get("image");
        if (!image) return null;
        return ImageUtils.getSize(image, this.getMimeType());
      }
    };
    Root = class extends ExtensibleProperty {
      init() {
        this.propertyType = PropertyType.ROOT;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          asset: {
            generator: `glTF-Transform ${VERSION}`,
            version: "2.0"
          },
          defaultScene: null,
          accessors: new RefSet(),
          animations: new RefSet(),
          buffers: new RefSet(),
          cameras: new RefSet(),
          materials: new RefSet(),
          meshes: new RefSet(),
          nodes: new RefSet(),
          scenes: new RefSet(),
          skins: new RefSet(),
          textures: new RefSet()
        });
      }
      /** @internal */
      constructor(graph) {
        super(graph);
        this._extensions = /* @__PURE__ */ new Set();
        graph.addEventListener("node:create", (event) => {
          this._addChildOfRoot(event.target);
        });
      }
      clone() {
        throw new Error("Root cannot be cloned.");
      }
      copy(other, resolve = COPY_IDENTITY) {
        if (resolve === COPY_IDENTITY) throw new Error("Root cannot be copied.");
        this.set("asset", _extends2({}, other.get("asset")));
        this.setName(other.getName());
        this.setExtras(_extends2({}, other.getExtras()));
        this.setDefaultScene(other.getDefaultScene() ? resolve(other.getDefaultScene()) : null);
        for (const extensionName of other.listRefMapKeys("extensions")) {
          const otherExtension = other.getExtension(extensionName);
          this.setExtension(extensionName, resolve(otherExtension));
        }
        return this;
      }
      _addChildOfRoot(child) {
        if (child instanceof Scene) {
          this.addRef("scenes", child);
        } else if (child instanceof Node) {
          this.addRef("nodes", child);
        } else if (child instanceof Camera) {
          this.addRef("cameras", child);
        } else if (child instanceof Skin) {
          this.addRef("skins", child);
        } else if (child instanceof Mesh) {
          this.addRef("meshes", child);
        } else if (child instanceof Material) {
          this.addRef("materials", child);
        } else if (child instanceof Texture) {
          this.addRef("textures", child);
        } else if (child instanceof Animation) {
          this.addRef("animations", child);
        } else if (child instanceof Accessor) {
          this.addRef("accessors", child);
        } else if (child instanceof Buffer$1) {
          this.addRef("buffers", child);
        }
        return this;
      }
      /**
       * Returns the `asset` object, which specifies the target glTF version of the asset. Additional
       * metadata can be stored in optional properties such as `generator` or `copyright`.
       *
       * Reference: [glTF → Asset](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#asset)
       */
      getAsset() {
        return this.get("asset");
      }
      /**********************************************************************************************
       * Extensions.
       */
      /** Lists all {@link Extension Extensions} enabled for this root. */
      listExtensionsUsed() {
        return Array.from(this._extensions);
      }
      /** Lists all {@link Extension Extensions} enabled and required for this root. */
      listExtensionsRequired() {
        return this.listExtensionsUsed().filter((extension) => extension.isRequired());
      }
      /** @internal */
      _enableExtension(extension) {
        this._extensions.add(extension);
        return this;
      }
      /** @internal */
      _disableExtension(extension) {
        this._extensions.delete(extension);
        return this;
      }
      /**********************************************************************************************
       * Properties.
       */
      /** Lists all {@link Scene} properties associated with this root. */
      listScenes() {
        return this.listRefs("scenes");
      }
      /** Default {@link Scene} associated with this root. */
      setDefaultScene(defaultScene) {
        return this.setRef("defaultScene", defaultScene);
      }
      /** Default {@link Scene} associated with this root. */
      getDefaultScene() {
        return this.getRef("defaultScene");
      }
      /** Lists all {@link Node} properties associated with this root. */
      listNodes() {
        return this.listRefs("nodes");
      }
      /** Lists all {@link Camera} properties associated with this root. */
      listCameras() {
        return this.listRefs("cameras");
      }
      /** Lists all {@link Skin} properties associated with this root. */
      listSkins() {
        return this.listRefs("skins");
      }
      /** Lists all {@link Mesh} properties associated with this root. */
      listMeshes() {
        return this.listRefs("meshes");
      }
      /** Lists all {@link Material} properties associated with this root. */
      listMaterials() {
        return this.listRefs("materials");
      }
      /** Lists all {@link Texture} properties associated with this root. */
      listTextures() {
        return this.listRefs("textures");
      }
      /** Lists all {@link Animation} properties associated with this root. */
      listAnimations() {
        return this.listRefs("animations");
      }
      /** Lists all {@link Accessor} properties associated with this root. */
      listAccessors() {
        return this.listRefs("accessors");
      }
      /** Lists all {@link Buffer} properties associated with this root. */
      listBuffers() {
        return this.listRefs("buffers");
      }
    };
    Document = class _Document {
      /**
       * Returns the Document associated with a given Graph, if any.
       * @hidden
       * @experimental
       */
      static fromGraph(graph) {
        return _Document._GRAPH_DOCUMENTS.get(graph) || null;
      }
      /** Creates a new Document, representing an empty glTF asset. */
      constructor() {
        this._graph = new Graph();
        this._root = new Root(this._graph);
        this._logger = Logger.DEFAULT_INSTANCE;
        _Document._GRAPH_DOCUMENTS.set(this._graph, this);
      }
      /** Returns the glTF {@link Root} property. */
      getRoot() {
        return this._root;
      }
      /**
       * Returns the {@link Graph} representing connectivity of resources within this document.
       * @hidden
       */
      getGraph() {
        return this._graph;
      }
      /** Returns the {@link Logger} instance used for any operations performed on this document. */
      getLogger() {
        return this._logger;
      }
      /**
       * Overrides the {@link Logger} instance used for any operations performed on this document.
       *
       * Usage:
       *
       * ```ts
       * doc
       * 	.setLogger(new Logger(Logger.Verbosity.SILENT))
       * 	.transform(dedup(), weld());
       * ```
       */
      setLogger(logger) {
        this._logger = logger;
        return this;
      }
      /**
       * Clones this Document, copying all resources within it.
       * @deprecated Use 'cloneDocument(document)' from '@gltf-transform/functions'.
       * @hidden
       * @internal
       */
      clone() {
        throw new Error(`Use 'cloneDocument(source)' from '@gltf-transform/functions'.`);
      }
      /**
       * Merges the content of another Document into this one, without affecting the original.
       * @deprecated Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.
       * @hidden
       * @internal
       */
      merge(_other) {
        throw new Error(`Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.`);
      }
      /**
       * Applies a series of modifications to this document. Each transformation is asynchronous,
       * takes the {@link Document} as input, and returns nothing. Transforms are applied in the
       * order given, which may affect the final result.
       *
       * Usage:
       *
       * ```ts
       * await doc.transform(
       * 	dedup(),
       * 	prune()
       * );
       * ```
       *
       * @param transforms List of synchronous transformation functions to apply.
       */
      async transform(...transforms) {
        const stack = transforms.map((fn) => fn.name);
        for (const transform of transforms) {
          await transform(this, {
            stack
          });
        }
        return this;
      }
      /**********************************************************************************************
       * Extension factory method.
       */
      /**
       * Creates a new {@link Extension}, for the extension type of the given constructor. If the
       * extension is already enabled for this Document, the previous Extension reference is reused.
       */
      createExtension(ctor) {
        const extensionName = ctor.EXTENSION_NAME;
        const prevExtension = this.getRoot().listExtensionsUsed().find((ext) => ext.extensionName === extensionName);
        return prevExtension || new ctor(this);
      }
      /**********************************************************************************************
       * Property factory methods.
       */
      /** Creates a new {@link Scene} attached to this document's {@link Root}. */
      createScene(name = "") {
        return new Scene(this._graph, name);
      }
      /** Creates a new {@link Node} attached to this document's {@link Root}. */
      createNode(name = "") {
        return new Node(this._graph, name);
      }
      /** Creates a new {@link Camera} attached to this document's {@link Root}. */
      createCamera(name = "") {
        return new Camera(this._graph, name);
      }
      /** Creates a new {@link Skin} attached to this document's {@link Root}. */
      createSkin(name = "") {
        return new Skin(this._graph, name);
      }
      /** Creates a new {@link Mesh} attached to this document's {@link Root}. */
      createMesh(name = "") {
        return new Mesh(this._graph, name);
      }
      /**
       * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}
       * for use and export; they are not otherwise associated with a {@link Root}.
       */
      createPrimitive() {
        return new Primitive(this._graph);
      }
      /**
       * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a
       * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.
       */
      createPrimitiveTarget(name = "") {
        return new PrimitiveTarget(this._graph, name);
      }
      /** Creates a new {@link Material} attached to this document's {@link Root}. */
      createMaterial(name = "") {
        return new Material(this._graph, name);
      }
      /** Creates a new {@link Texture} attached to this document's {@link Root}. */
      createTexture(name = "") {
        return new Texture(this._graph, name);
      }
      /** Creates a new {@link Animation} attached to this document's {@link Root}. */
      createAnimation(name = "") {
        return new Animation(this._graph, name);
      }
      /**
       * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}
       * for use and export; they are not otherwise associated with a {@link Root}.
       */
      createAnimationChannel(name = "") {
        return new AnimationChannel(this._graph, name);
      }
      /**
       * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}
       * for use and export; they are not otherwise associated with a {@link Root}.
       */
      createAnimationSampler(name = "") {
        return new AnimationSampler(this._graph, name);
      }
      /** Creates a new {@link Accessor} attached to this document's {@link Root}. */
      createAccessor(name = "", buffer = null) {
        if (!buffer) {
          buffer = this.getRoot().listBuffers()[0];
        }
        return new Accessor(this._graph, name).setBuffer(buffer);
      }
      /** Creates a new {@link Buffer} attached to this document's {@link Root}. */
      createBuffer(name = "") {
        return new Buffer$1(this._graph, name);
      }
    };
    Document._GRAPH_DOCUMENTS = /* @__PURE__ */ new WeakMap();
    Extension = class {
      /** @hidden */
      constructor(document2) {
        this.extensionName = "";
        this.prereadTypes = [];
        this.prewriteTypes = [];
        this.readDependencies = [];
        this.writeDependencies = [];
        this.document = void 0;
        this.required = false;
        this.properties = /* @__PURE__ */ new Set();
        this._listener = void 0;
        this.document = document2;
        document2.getRoot()._enableExtension(this);
        this._listener = (_event) => {
          const event = _event;
          const target = event.target;
          if (target instanceof ExtensionProperty && target.extensionName === this.extensionName) {
            if (event.type === "node:create") this._addExtensionProperty(target);
            if (event.type === "node:dispose") this._removeExtensionProperty(target);
          }
        };
        const graph = document2.getGraph();
        graph.addEventListener("node:create", this._listener);
        graph.addEventListener("node:dispose", this._listener);
      }
      /** Disables and removes the extension from the Document. */
      dispose() {
        this.document.getRoot()._disableExtension(this);
        const graph = this.document.getGraph();
        graph.removeEventListener("node:create", this._listener);
        graph.removeEventListener("node:dispose", this._listener);
        for (const property of this.properties) {
          property.dispose();
        }
      }
      /** @hidden Performs first-time setup for the extension. Must be idempotent. */
      static register() {
      }
      /**
       * Indicates to the client whether it is OK to load the asset when this extension is not
       * recognized. Optional extensions are generally preferred, if there is not a good reason
       * to require a client to completely fail when an extension isn't known.
       */
      isRequired() {
        return this.required;
      }
      /**
       * Indicates to the client whether it is OK to load the asset when this extension is not
       * recognized. Optional extensions are generally preferred, if there is not a good reason
       * to require a client to completely fail when an extension isn't known.
       */
      setRequired(required) {
        this.required = required;
        return this;
      }
      /**
       * Lists all {@link ExtensionProperty} instances associated with, or created by, this
       * extension. Includes only instances that are attached to the Document's graph; detached
       * instances will be excluded.
       */
      listProperties() {
        return Array.from(this.properties);
      }
      /**********************************************************************************************
       * ExtensionProperty management.
       */
      /** @internal */
      _addExtensionProperty(property) {
        this.properties.add(property);
        return this;
      }
      /** @internal */
      _removeExtensionProperty(property) {
        this.properties.delete(property);
        return this;
      }
      /**********************************************************************************************
       * I/O implementation.
       */
      /** @hidden Installs dependencies required by the extension. */
      install(_key, _dependency) {
        return this;
      }
      /**
       * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may
       * optionally be implemented by an extension, and should then support any property type
       * declared by the Extension's {@link Extension.prereadTypes} list. The Extension will
       * be given a ReaderContext instance, and is expected to update either the context or its
       * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to
       * implement this.*
       * @hidden
       */
      preread(_readerContext, _propertyType) {
        return this;
      }
      /**
       * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method may
       * optionally be implemented by an extension, and should then support any property type
       * declared by the Extension's {@link Extension.prewriteTypes} list. The Extension will
       * be given a WriterContext instance, and is expected to update either the context or its
       * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to
       * implement this.*
       * @hidden
       */
      prewrite(_writerContext, _propertyType) {
        return this;
      }
    };
    Extension.EXTENSION_NAME = void 0;
    ReaderContext = class {
      constructor(jsonDoc) {
        this.jsonDoc = void 0;
        this.buffers = [];
        this.bufferViews = [];
        this.bufferViewBuffers = [];
        this.accessors = [];
        this.textures = [];
        this.textureInfos = /* @__PURE__ */ new Map();
        this.materials = [];
        this.meshes = [];
        this.cameras = [];
        this.nodes = [];
        this.skins = [];
        this.animations = [];
        this.scenes = [];
        this.jsonDoc = jsonDoc;
      }
      setTextureInfo(textureInfo, textureInfoDef) {
        this.textureInfos.set(textureInfo, textureInfoDef);
        if (textureInfoDef.texCoord !== void 0) {
          textureInfo.setTexCoord(textureInfoDef.texCoord);
        }
        if (textureInfoDef.extras !== void 0) {
          textureInfo.setExtras(textureInfoDef.extras);
        }
        const textureDef = this.jsonDoc.json.textures[textureInfoDef.index];
        if (textureDef.sampler === void 0) return;
        const samplerDef = this.jsonDoc.json.samplers[textureDef.sampler];
        if (samplerDef.magFilter !== void 0) {
          textureInfo.setMagFilter(samplerDef.magFilter);
        }
        if (samplerDef.minFilter !== void 0) {
          textureInfo.setMinFilter(samplerDef.minFilter);
        }
        if (samplerDef.wrapS !== void 0) {
          textureInfo.setWrapS(samplerDef.wrapS);
        }
        if (samplerDef.wrapT !== void 0) {
          textureInfo.setWrapT(samplerDef.wrapT);
        }
      }
    };
    DEFAULT_OPTIONS = {
      logger: Logger.DEFAULT_INSTANCE,
      extensions: [],
      dependencies: {}
    };
    SUPPORTED_PREREAD_TYPES = /* @__PURE__ */ new Set([PropertyType.BUFFER, PropertyType.TEXTURE, PropertyType.MATERIAL, PropertyType.MESH, PropertyType.PRIMITIVE, PropertyType.NODE, PropertyType.SCENE]);
    GLTFReader = class {
      static read(jsonDoc, _options = DEFAULT_OPTIONS) {
        const options = _extends2({}, DEFAULT_OPTIONS, _options);
        const {
          json
        } = jsonDoc;
        const document2 = new Document().setLogger(options.logger);
        this.validate(jsonDoc, options);
        const context = new ReaderContext(jsonDoc);
        const assetDef = json.asset;
        const asset = document2.getRoot().getAsset();
        if (assetDef.copyright) asset.copyright = assetDef.copyright;
        if (assetDef.extras) asset.extras = assetDef.extras;
        if (json.extras !== void 0) {
          document2.getRoot().setExtras(_extends2({}, json.extras));
        }
        const extensionsUsed = json.extensionsUsed || [];
        const extensionsRequired = json.extensionsRequired || [];
        options.extensions.sort((a, b) => a.EXTENSION_NAME > b.EXTENSION_NAME ? 1 : -1);
        for (const Extension2 of options.extensions) {
          if (extensionsUsed.includes(Extension2.EXTENSION_NAME)) {
            const extension = document2.createExtension(Extension2).setRequired(extensionsRequired.includes(Extension2.EXTENSION_NAME));
            const unsupportedHooks = extension.prereadTypes.filter((type) => !SUPPORTED_PREREAD_TYPES.has(type));
            if (unsupportedHooks.length) {
              options.logger.warn(`Preread hooks for some types (${unsupportedHooks.join()}), requested by extension ${extension.extensionName}, are unsupported. Please file an issue or a PR.`);
            }
            for (const key of extension.readDependencies) {
              extension.install(key, options.dependencies[key]);
            }
          }
        }
        const bufferDefs = json.buffers || [];
        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.BUFFER)).forEach((extension) => extension.preread(context, PropertyType.BUFFER));
        context.buffers = bufferDefs.map((bufferDef) => {
          const buffer = document2.createBuffer(bufferDef.name);
          if (bufferDef.extras) buffer.setExtras(bufferDef.extras);
          if (bufferDef.uri && bufferDef.uri.indexOf("__") !== 0) {
            buffer.setURI(bufferDef.uri);
          }
          return buffer;
        });
        const bufferViewDefs = json.bufferViews || [];
        context.bufferViewBuffers = bufferViewDefs.map((bufferViewDef, index) => {
          if (!context.bufferViews[index]) {
            const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];
            const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];
            const byteOffset = bufferViewDef.byteOffset || 0;
            context.bufferViews[index] = BufferUtils.toView(resource, byteOffset, bufferViewDef.byteLength);
          }
          return context.buffers[bufferViewDef.buffer];
        });
        const accessorDefs = json.accessors || [];
        context.accessors = accessorDefs.map((accessorDef) => {
          const buffer = context.bufferViewBuffers[accessorDef.bufferView];
          const accessor = document2.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);
          if (accessorDef.extras) accessor.setExtras(accessorDef.extras);
          if (accessorDef.normalized !== void 0) {
            accessor.setNormalized(accessorDef.normalized);
          }
          if (accessorDef.bufferView === void 0) return accessor;
          accessor.setArray(getAccessorArray(accessorDef, context));
          return accessor;
        });
        const imageDefs = json.images || [];
        const textureDefs = json.textures || [];
        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.TEXTURE)).forEach((extension) => extension.preread(context, PropertyType.TEXTURE));
        context.textures = imageDefs.map((imageDef) => {
          const texture = document2.createTexture(imageDef.name);
          if (imageDef.extras) texture.setExtras(imageDef.extras);
          if (imageDef.bufferView !== void 0) {
            const bufferViewDef = json.bufferViews[imageDef.bufferView];
            const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];
            const bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];
            const byteOffset = bufferViewDef.byteOffset || 0;
            const byteLength = bufferViewDef.byteLength;
            const imageData = bufferData.slice(byteOffset, byteOffset + byteLength);
            texture.setImage(imageData);
          } else if (imageDef.uri !== void 0) {
            texture.setImage(jsonDoc.resources[imageDef.uri]);
            if (imageDef.uri.indexOf("__") !== 0) {
              texture.setURI(imageDef.uri);
            }
          }
          if (imageDef.mimeType !== void 0) {
            texture.setMimeType(imageDef.mimeType);
          } else if (imageDef.uri) {
            const extension = FileUtils.extension(imageDef.uri);
            texture.setMimeType(ImageUtils.extensionToMimeType(extension));
          }
          return texture;
        });
        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.MATERIAL)).forEach((extension) => extension.preread(context, PropertyType.MATERIAL));
        const materialDefs = json.materials || [];
        context.materials = materialDefs.map((materialDef) => {
          const material = document2.createMaterial(materialDef.name);
          if (materialDef.extras) material.setExtras(materialDef.extras);
          if (materialDef.alphaMode !== void 0) {
            material.setAlphaMode(materialDef.alphaMode);
          }
          if (materialDef.alphaCutoff !== void 0) {
            material.setAlphaCutoff(materialDef.alphaCutoff);
          }
          if (materialDef.doubleSided !== void 0) {
            material.setDoubleSided(materialDef.doubleSided);
          }
          const pbrDef = materialDef.pbrMetallicRoughness || {};
          if (pbrDef.baseColorFactor !== void 0) {
            material.setBaseColorFactor(pbrDef.baseColorFactor);
          }
          if (materialDef.emissiveFactor !== void 0) {
            material.setEmissiveFactor(materialDef.emissiveFactor);
          }
          if (pbrDef.metallicFactor !== void 0) {
            material.setMetallicFactor(pbrDef.metallicFactor);
          }
          if (pbrDef.roughnessFactor !== void 0) {
            material.setRoughnessFactor(pbrDef.roughnessFactor);
          }
          if (pbrDef.baseColorTexture !== void 0) {
            const textureInfoDef = pbrDef.baseColorTexture;
            const texture = context.textures[textureDefs[textureInfoDef.index].source];
            material.setBaseColorTexture(texture);
            context.setTextureInfo(material.getBaseColorTextureInfo(), textureInfoDef);
          }
          if (materialDef.emissiveTexture !== void 0) {
            const textureInfoDef = materialDef.emissiveTexture;
            const texture = context.textures[textureDefs[textureInfoDef.index].source];
            material.setEmissiveTexture(texture);
            context.setTextureInfo(material.getEmissiveTextureInfo(), textureInfoDef);
          }
          if (materialDef.normalTexture !== void 0) {
            const textureInfoDef = materialDef.normalTexture;
            const texture = context.textures[textureDefs[textureInfoDef.index].source];
            material.setNormalTexture(texture);
            context.setTextureInfo(material.getNormalTextureInfo(), textureInfoDef);
            if (materialDef.normalTexture.scale !== void 0) {
              material.setNormalScale(materialDef.normalTexture.scale);
            }
          }
          if (materialDef.occlusionTexture !== void 0) {
            const textureInfoDef = materialDef.occlusionTexture;
            const texture = context.textures[textureDefs[textureInfoDef.index].source];
            material.setOcclusionTexture(texture);
            context.setTextureInfo(material.getOcclusionTextureInfo(), textureInfoDef);
            if (materialDef.occlusionTexture.strength !== void 0) {
              material.setOcclusionStrength(materialDef.occlusionTexture.strength);
            }
          }
          if (pbrDef.metallicRoughnessTexture !== void 0) {
            const textureInfoDef = pbrDef.metallicRoughnessTexture;
            const texture = context.textures[textureDefs[textureInfoDef.index].source];
            material.setMetallicRoughnessTexture(texture);
            context.setTextureInfo(material.getMetallicRoughnessTextureInfo(), textureInfoDef);
          }
          return material;
        });
        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.MESH)).forEach((extension) => extension.preread(context, PropertyType.MESH));
        const meshDefs = json.meshes || [];
        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.PRIMITIVE)).forEach((extension) => extension.preread(context, PropertyType.PRIMITIVE));
        context.meshes = meshDefs.map((meshDef) => {
          const mesh = document2.createMesh(meshDef.name);
          if (meshDef.extras) mesh.setExtras(meshDef.extras);
          if (meshDef.weights !== void 0) {
            mesh.setWeights(meshDef.weights);
          }
          const primitiveDefs = meshDef.primitives || [];
          primitiveDefs.forEach((primitiveDef) => {
            const primitive = document2.createPrimitive();
            if (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);
            if (primitiveDef.material !== void 0) {
              primitive.setMaterial(context.materials[primitiveDef.material]);
            }
            if (primitiveDef.mode !== void 0) {
              primitive.setMode(primitiveDef.mode);
            }
            for (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {
              primitive.setAttribute(semantic, context.accessors[index]);
            }
            if (primitiveDef.indices !== void 0) {
              primitive.setIndices(context.accessors[primitiveDef.indices]);
            }
            const targetNames = meshDef.extras && meshDef.extras.targetNames || [];
            const targetDefs = primitiveDef.targets || [];
            targetDefs.forEach((targetDef, targetIndex) => {
              const targetName = targetNames[targetIndex] || targetIndex.toString();
              const target = document2.createPrimitiveTarget(targetName);
              for (const [semantic, accessorIndex] of Object.entries(targetDef)) {
                target.setAttribute(semantic, context.accessors[accessorIndex]);
              }
              primitive.addTarget(target);
            });
            mesh.addPrimitive(primitive);
          });
          return mesh;
        });
        const cameraDefs = json.cameras || [];
        context.cameras = cameraDefs.map((cameraDef) => {
          const camera = document2.createCamera(cameraDef.name).setType(cameraDef.type);
          if (cameraDef.extras) camera.setExtras(cameraDef.extras);
          if (cameraDef.type === Camera.Type.PERSPECTIVE) {
            const perspectiveDef = cameraDef.perspective;
            camera.setYFov(perspectiveDef.yfov);
            camera.setZNear(perspectiveDef.znear);
            if (perspectiveDef.zfar !== void 0) {
              camera.setZFar(perspectiveDef.zfar);
            }
            if (perspectiveDef.aspectRatio !== void 0) {
              camera.setAspectRatio(perspectiveDef.aspectRatio);
            }
          } else {
            const orthoDef = cameraDef.orthographic;
            camera.setZNear(orthoDef.znear).setZFar(orthoDef.zfar).setXMag(orthoDef.xmag).setYMag(orthoDef.ymag);
          }
          return camera;
        });
        const nodeDefs = json.nodes || [];
        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.NODE)).forEach((extension) => extension.preread(context, PropertyType.NODE));
        context.nodes = nodeDefs.map((nodeDef) => {
          const node = document2.createNode(nodeDef.name);
          if (nodeDef.extras) node.setExtras(nodeDef.extras);
          if (nodeDef.translation !== void 0) {
            node.setTranslation(nodeDef.translation);
          }
          if (nodeDef.rotation !== void 0) {
            node.setRotation(nodeDef.rotation);
          }
          if (nodeDef.scale !== void 0) {
            node.setScale(nodeDef.scale);
          }
          if (nodeDef.matrix !== void 0) {
            const translation = [0, 0, 0];
            const rotation = [0, 0, 0, 1];
            const scale = [1, 1, 1];
            MathUtils.decompose(nodeDef.matrix, translation, rotation, scale);
            node.setTranslation(translation);
            node.setRotation(rotation);
            node.setScale(scale);
          }
          if (nodeDef.weights !== void 0) {
            node.setWeights(nodeDef.weights);
          }
          return node;
        });
        const skinDefs = json.skins || [];
        context.skins = skinDefs.map((skinDef) => {
          const skin = document2.createSkin(skinDef.name);
          if (skinDef.extras) skin.setExtras(skinDef.extras);
          if (skinDef.inverseBindMatrices !== void 0) {
            skin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);
          }
          if (skinDef.skeleton !== void 0) {
            skin.setSkeleton(context.nodes[skinDef.skeleton]);
          }
          for (const nodeIndex of skinDef.joints) {
            skin.addJoint(context.nodes[nodeIndex]);
          }
          return skin;
        });
        nodeDefs.map((nodeDef, nodeIndex) => {
          const node = context.nodes[nodeIndex];
          const children = nodeDef.children || [];
          children.forEach((childIndex) => node.addChild(context.nodes[childIndex]));
          if (nodeDef.mesh !== void 0) node.setMesh(context.meshes[nodeDef.mesh]);
          if (nodeDef.camera !== void 0) node.setCamera(context.cameras[nodeDef.camera]);
          if (nodeDef.skin !== void 0) node.setSkin(context.skins[nodeDef.skin]);
        });
        const animationDefs = json.animations || [];
        context.animations = animationDefs.map((animationDef) => {
          const animation2 = document2.createAnimation(animationDef.name);
          if (animationDef.extras) animation2.setExtras(animationDef.extras);
          const samplerDefs = animationDef.samplers || [];
          const samplers = samplerDefs.map((samplerDef) => {
            const sampler = document2.createAnimationSampler().setInput(context.accessors[samplerDef.input]).setOutput(context.accessors[samplerDef.output]).setInterpolation(samplerDef.interpolation || AnimationSampler.Interpolation.LINEAR);
            if (samplerDef.extras) sampler.setExtras(samplerDef.extras);
            animation2.addSampler(sampler);
            return sampler;
          });
          const channels = animationDef.channels || [];
          channels.forEach((channelDef) => {
            const channel = document2.createAnimationChannel().setSampler(samplers[channelDef.sampler]).setTargetPath(channelDef.target.path);
            if (channelDef.target.node !== void 0) channel.setTargetNode(context.nodes[channelDef.target.node]);
            if (channelDef.extras) channel.setExtras(channelDef.extras);
            animation2.addChannel(channel);
          });
          return animation2;
        });
        const sceneDefs = json.scenes || [];
        document2.getRoot().listExtensionsUsed().filter((extension) => extension.prereadTypes.includes(PropertyType.SCENE)).forEach((extension) => extension.preread(context, PropertyType.SCENE));
        context.scenes = sceneDefs.map((sceneDef) => {
          const scene = document2.createScene(sceneDef.name);
          if (sceneDef.extras) scene.setExtras(sceneDef.extras);
          const children = sceneDef.nodes || [];
          children.map((nodeIndex) => context.nodes[nodeIndex]).forEach((node) => scene.addChild(node));
          return scene;
        });
        if (json.scene !== void 0) {
          document2.getRoot().setDefaultScene(context.scenes[json.scene]);
        }
        document2.getRoot().listExtensionsUsed().forEach((extension) => extension.read(context));
        accessorDefs.forEach((accessorDef, index) => {
          const accessor = context.accessors[index];
          const hasSparseValues = !!accessorDef.sparse;
          const isZeroFilled = !accessorDef.bufferView && !accessor.getArray();
          if (hasSparseValues || isZeroFilled) {
            accessor.setSparse(true).setArray(getSparseArray(accessorDef, context));
          }
        });
        return document2;
      }
      static validate(jsonDoc, options) {
        const json = jsonDoc.json;
        if (json.asset.version !== "2.0") {
          throw new Error(`Unsupported glTF version, "${json.asset.version}".`);
        }
        if (json.extensionsRequired) {
          for (const extensionName of json.extensionsRequired) {
            if (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {
              throw new Error(`Missing required extension, "${extensionName}".`);
            }
          }
        }
        if (json.extensionsUsed) {
          for (const extensionName of json.extensionsUsed) {
            if (!options.extensions.find((extension) => extension.EXTENSION_NAME === extensionName)) {
              options.logger.warn(`Missing optional extension, "${extensionName}".`);
            }
          }
        }
      }
    };
    (function(BufferViewTarget2) {
      BufferViewTarget2[BufferViewTarget2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      BufferViewTarget2[BufferViewTarget2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
    })(BufferViewTarget || (BufferViewTarget = {}));
    WriterContext = class {
      constructor(_doc, jsonDoc, options) {
        this._doc = void 0;
        this.jsonDoc = void 0;
        this.options = void 0;
        this.accessorIndexMap = /* @__PURE__ */ new Map();
        this.animationIndexMap = /* @__PURE__ */ new Map();
        this.bufferIndexMap = /* @__PURE__ */ new Map();
        this.cameraIndexMap = /* @__PURE__ */ new Map();
        this.skinIndexMap = /* @__PURE__ */ new Map();
        this.materialIndexMap = /* @__PURE__ */ new Map();
        this.meshIndexMap = /* @__PURE__ */ new Map();
        this.nodeIndexMap = /* @__PURE__ */ new Map();
        this.imageIndexMap = /* @__PURE__ */ new Map();
        this.textureDefIndexMap = /* @__PURE__ */ new Map();
        this.textureInfoDefMap = /* @__PURE__ */ new Map();
        this.samplerDefIndexMap = /* @__PURE__ */ new Map();
        this.sceneIndexMap = /* @__PURE__ */ new Map();
        this.imageBufferViews = [];
        this.otherBufferViews = /* @__PURE__ */ new Map();
        this.otherBufferViewsIndexMap = /* @__PURE__ */ new Map();
        this.extensionData = {};
        this.bufferURIGenerator = void 0;
        this.imageURIGenerator = void 0;
        this.logger = void 0;
        this._accessorUsageMap = /* @__PURE__ */ new Map();
        this.accessorUsageGroupedByParent = /* @__PURE__ */ new Set(["ARRAY_BUFFER"]);
        this.accessorParents = /* @__PURE__ */ new Map();
        this._doc = _doc;
        this.jsonDoc = jsonDoc;
        this.options = options;
        const root = _doc.getRoot();
        const numBuffers = root.listBuffers().length;
        const numImages = root.listTextures().length;
        this.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, () => options.basename || "buffer");
        this.imageURIGenerator = new UniqueURIGenerator(numImages > 1, (texture) => getSlot(_doc, texture) || options.basename || "texture");
        this.logger = _doc.getLogger();
      }
      /**
       * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If
       * possible, Texture and Sampler definitions are shared.
       */
      createTextureInfoDef(texture, textureInfo) {
        const samplerDef = {
          magFilter: textureInfo.getMagFilter() || void 0,
          minFilter: textureInfo.getMinFilter() || void 0,
          wrapS: textureInfo.getWrapS(),
          wrapT: textureInfo.getWrapT()
        };
        const samplerKey = JSON.stringify(samplerDef);
        if (!this.samplerDefIndexMap.has(samplerKey)) {
          this.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers.length);
          this.jsonDoc.json.samplers.push(samplerDef);
        }
        const textureDef = {
          source: this.imageIndexMap.get(texture),
          sampler: this.samplerDefIndexMap.get(samplerKey)
        };
        const textureKey = JSON.stringify(textureDef);
        if (!this.textureDefIndexMap.has(textureKey)) {
          this.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures.length);
          this.jsonDoc.json.textures.push(textureDef);
        }
        const textureInfoDef = {
          index: this.textureDefIndexMap.get(textureKey)
        };
        if (textureInfo.getTexCoord() !== 0) {
          textureInfoDef.texCoord = textureInfo.getTexCoord();
        }
        if (Object.keys(textureInfo.getExtras()).length > 0) {
          textureInfoDef.extras = textureInfo.getExtras();
        }
        this.textureInfoDefMap.set(textureInfo, textureInfoDef);
        return textureInfoDef;
      }
      createPropertyDef(property) {
        const def = {};
        if (property.getName()) {
          def.name = property.getName();
        }
        if (Object.keys(property.getExtras()).length > 0) {
          def.extras = property.getExtras();
        }
        return def;
      }
      createAccessorDef(accessor) {
        const accessorDef = this.createPropertyDef(accessor);
        accessorDef.type = accessor.getType();
        accessorDef.componentType = accessor.getComponentType();
        accessorDef.count = accessor.getCount();
        const needsBounds = this._doc.getGraph().listParentEdges(accessor).some((edge) => edge.getName() === "attributes" && edge.getAttributes().key === "POSITION" || edge.getName() === "input");
        if (needsBounds) {
          accessorDef.max = accessor.getMax([]).map(Math.fround);
          accessorDef.min = accessor.getMin([]).map(Math.fround);
        }
        if (accessor.getNormalized()) {
          accessorDef.normalized = accessor.getNormalized();
        }
        return accessorDef;
      }
      createImageData(imageDef, data, texture) {
        if (this.options.format === Format.GLB) {
          this.imageBufferViews.push(data);
          imageDef.bufferView = this.jsonDoc.json.bufferViews.length;
          this.jsonDoc.json.bufferViews.push({
            buffer: 0,
            byteOffset: -1,
            // determined while iterating buffers, in Writer.ts.
            byteLength: data.byteLength
          });
        } else {
          const extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());
          imageDef.uri = this.imageURIGenerator.createURI(texture, extension);
          this.assignResourceURI(imageDef.uri, data, false);
        }
      }
      assignResourceURI(uri, data, throwOnConflict) {
        const resources = this.jsonDoc.resources;
        if (!(uri in resources)) {
          resources[uri] = data;
          return;
        }
        if (data === resources[uri]) {
          this.logger.warn(`Duplicate resource URI, "${uri}".`);
          return;
        }
        const conflictMessage = `Resource URI "${uri}" already assigned to different data.`;
        if (!throwOnConflict) {
          this.logger.warn(conflictMessage);
          return;
        }
        throw new Error(conflictMessage);
      }
      /**
       * Returns implicit usage type of the given accessor, related to grouping accessors into
       * buffer views. Usage is a superset of buffer view target, including ARRAY_BUFFER and
       * ELEMENT_ARRAY_BUFFER, but also usages that do not match GPU buffer view targets such as
       * IBMs. Additional usages are defined by extensions, like `EXT_mesh_gpu_instancing`.
       */
      getAccessorUsage(accessor) {
        const cachedUsage = this._accessorUsageMap.get(accessor);
        if (cachedUsage) return cachedUsage;
        if (accessor.getSparse()) return BufferViewUsage$1.SPARSE;
        for (const edge of this._doc.getGraph().listParentEdges(accessor)) {
          const {
            usage
          } = edge.getAttributes();
          if (usage) return usage;
          if (edge.getParent().propertyType !== PropertyType.ROOT) {
            this.logger.warn(`Missing attribute ".usage" on edge, "${edge.getName()}".`);
          }
        }
        return BufferViewUsage$1.OTHER;
      }
      /**
       * Sets usage for the given accessor. Some accessor types must be grouped into
       * buffer views with like accessors. This includes the specified buffer view "targets", but
       * also implicit usage like IBMs or instanced mesh attributes. If unspecified, an accessor
       * will be grouped with other accessors of unspecified usage.
       */
      addAccessorToUsageGroup(accessor, usage) {
        const prevUsage = this._accessorUsageMap.get(accessor);
        if (prevUsage && prevUsage !== usage) {
          throw new Error(`Accessor with usage "${prevUsage}" cannot be reused as "${usage}".`);
        }
        this._accessorUsageMap.set(accessor, usage);
        return this;
      }
    };
    WriterContext.BufferViewTarget = BufferViewTarget;
    WriterContext.BufferViewUsage = BufferViewUsage$1;
    WriterContext.USAGE_TO_TARGET = {
      [BufferViewUsage$1.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,
      [BufferViewUsage$1.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER
    };
    UniqueURIGenerator = class {
      constructor(multiple, basename) {
        this.multiple = void 0;
        this.basename = void 0;
        this.counter = {};
        this.multiple = multiple;
        this.basename = basename;
      }
      createURI(object, extension) {
        if (object.getURI()) {
          return object.getURI();
        } else if (!this.multiple) {
          return `${this.basename(object)}.${extension}`;
        } else {
          const basename = this.basename(object);
          this.counter[basename] = this.counter[basename] || 1;
          return `${basename}_${this.counter[basename]++}.${extension}`;
        }
      }
    };
    ({
      BufferViewUsage
    } = WriterContext);
    ({
      UNSIGNED_INT,
      UNSIGNED_SHORT,
      UNSIGNED_BYTE
    } = Accessor.ComponentType);
    SUPPORTED_PREWRITE_TYPES = /* @__PURE__ */ new Set([PropertyType.ACCESSOR, PropertyType.BUFFER, PropertyType.MATERIAL, PropertyType.MESH]);
    GLTFWriter = class {
      static write(doc, options) {
        const graph = doc.getGraph();
        const root = doc.getRoot();
        const json = {
          asset: _extends2({
            generator: `glTF-Transform ${VERSION}`
          }, root.getAsset()),
          extras: _extends2({}, root.getExtras())
        };
        const jsonDoc = {
          json,
          resources: {}
        };
        const context = new WriterContext(doc, jsonDoc, options);
        const logger = options.logger || Logger.DEFAULT_INSTANCE;
        const extensionsRegistered = new Set(options.extensions.map((ext) => ext.EXTENSION_NAME));
        const extensionsUsed = doc.getRoot().listExtensionsUsed().filter((ext) => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);
        const extensionsRequired = doc.getRoot().listExtensionsRequired().filter((ext) => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);
        if (extensionsUsed.length < doc.getRoot().listExtensionsUsed().length) {
          logger.warn("Some extensions were not registered for I/O, and will not be written.");
        }
        for (const extension of extensionsUsed) {
          const unsupportedHooks = extension.prewriteTypes.filter((type) => !SUPPORTED_PREWRITE_TYPES.has(type));
          if (unsupportedHooks.length) {
            logger.warn(`Prewrite hooks for some types (${unsupportedHooks.join()}), requested by extension ${extension.extensionName}, are unsupported. Please file an issue or a PR.`);
          }
          for (const key of extension.writeDependencies) {
            extension.install(key, options.dependencies[key]);
          }
        }
        function concatAccessors(accessors, bufferIndex, bufferByteOffset, bufferViewTarget) {
          const buffers = [];
          let byteLength = 0;
          for (const accessor of accessors) {
            const accessorDef = context.createAccessorDef(accessor);
            accessorDef.bufferView = json.bufferViews.length;
            const accessorArray = accessor.getArray();
            const data = BufferUtils.pad(BufferUtils.toView(accessorArray));
            accessorDef.byteOffset = byteLength;
            byteLength += data.byteLength;
            buffers.push(data);
            context.accessorIndexMap.set(accessor, json.accessors.length);
            json.accessors.push(accessorDef);
          }
          const bufferViewData = BufferUtils.concat(buffers);
          const bufferViewDef = {
            buffer: bufferIndex,
            byteOffset: bufferByteOffset,
            byteLength: bufferViewData.byteLength
          };
          if (bufferViewTarget) bufferViewDef.target = bufferViewTarget;
          json.bufferViews.push(bufferViewDef);
          return {
            buffers,
            byteLength
          };
        }
        function interleaveAccessors(accessors, bufferIndex, bufferByteOffset) {
          const vertexCount = accessors[0].getCount();
          let byteStride = 0;
          for (const accessor of accessors) {
            const accessorDef = context.createAccessorDef(accessor);
            accessorDef.bufferView = json.bufferViews.length;
            accessorDef.byteOffset = byteStride;
            const elementSize = accessor.getElementSize();
            const componentSize = accessor.getComponentSize();
            byteStride += BufferUtils.padNumber(elementSize * componentSize);
            context.accessorIndexMap.set(accessor, json.accessors.length);
            json.accessors.push(accessorDef);
          }
          const byteLength = vertexCount * byteStride;
          const buffer = new ArrayBuffer(byteLength);
          const view = new DataView(buffer);
          for (let i = 0; i < vertexCount; i++) {
            let vertexByteOffset = 0;
            for (const accessor of accessors) {
              const elementSize = accessor.getElementSize();
              const componentSize = accessor.getComponentSize();
              const componentType = accessor.getComponentType();
              const array = accessor.getArray();
              for (let j = 0; j < elementSize; j++) {
                const viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;
                const value2 = array[i * elementSize + j];
                switch (componentType) {
                  case Accessor.ComponentType.FLOAT:
                    view.setFloat32(viewByteOffset, value2, true);
                    break;
                  case Accessor.ComponentType.BYTE:
                    view.setInt8(viewByteOffset, value2);
                    break;
                  case Accessor.ComponentType.SHORT:
                    view.setInt16(viewByteOffset, value2, true);
                    break;
                  case Accessor.ComponentType.UNSIGNED_BYTE:
                    view.setUint8(viewByteOffset, value2);
                    break;
                  case Accessor.ComponentType.UNSIGNED_SHORT:
                    view.setUint16(viewByteOffset, value2, true);
                    break;
                  case Accessor.ComponentType.UNSIGNED_INT:
                    view.setUint32(viewByteOffset, value2, true);
                    break;
                  default:
                    throw new Error("Unexpected component type: " + componentType);
                }
              }
              vertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);
            }
          }
          const bufferViewDef = {
            buffer: bufferIndex,
            byteOffset: bufferByteOffset,
            byteLength,
            byteStride,
            target: WriterContext.BufferViewTarget.ARRAY_BUFFER
          };
          json.bufferViews.push(bufferViewDef);
          return {
            byteLength,
            buffers: [new Uint8Array(buffer)]
          };
        }
        function concatSparseAccessors(accessors, bufferIndex, bufferByteOffset) {
          const buffers = [];
          let byteLength = 0;
          const sparseData = /* @__PURE__ */ new Map();
          let maxIndex = -Infinity;
          let needSparseWarning = false;
          for (const accessor of accessors) {
            const accessorDef = context.createAccessorDef(accessor);
            json.accessors.push(accessorDef);
            context.accessorIndexMap.set(accessor, json.accessors.length - 1);
            const indices = [];
            const values = [];
            const el = [];
            const base = new Array(accessor.getElementSize()).fill(0);
            for (let i = 0, il = accessor.getCount(); i < il; i++) {
              accessor.getElement(i, el);
              if (MathUtils.eq(el, base, 0)) continue;
              maxIndex = Math.max(i, maxIndex);
              indices.push(i);
              for (let j = 0; j < el.length; j++) values.push(el[j]);
            }
            const count = indices.length;
            const data = {
              accessorDef,
              count
            };
            sparseData.set(accessor, data);
            if (count === 0) continue;
            if (count > accessor.getCount() / 2) {
              needSparseWarning = true;
            }
            const ValueArray = ComponentTypeToTypedArray[accessor.getComponentType()];
            data.indices = indices;
            data.values = new ValueArray(values);
          }
          if (!Number.isFinite(maxIndex)) {
            return {
              buffers,
              byteLength
            };
          }
          if (needSparseWarning) {
            logger.warn(`Some sparse accessors have >50% non-zero elements, which may increase file size.`);
          }
          const IndexArray = maxIndex < 255 ? Uint8Array : maxIndex < 65535 ? Uint16Array : Uint32Array;
          const IndexComponentType = maxIndex < 255 ? UNSIGNED_BYTE : maxIndex < 65535 ? UNSIGNED_SHORT : UNSIGNED_INT;
          const indicesBufferViewDef = {
            buffer: bufferIndex,
            byteOffset: bufferByteOffset + byteLength,
            byteLength: 0
          };
          for (const accessor of accessors) {
            const data = sparseData.get(accessor);
            if (data.count === 0) continue;
            data.indicesByteOffset = indicesBufferViewDef.byteLength;
            const buffer = BufferUtils.pad(BufferUtils.toView(new IndexArray(data.indices)));
            buffers.push(buffer);
            byteLength += buffer.byteLength;
            indicesBufferViewDef.byteLength += buffer.byteLength;
          }
          json.bufferViews.push(indicesBufferViewDef);
          const indicesBufferViewIndex = json.bufferViews.length - 1;
          const valuesBufferViewDef = {
            buffer: bufferIndex,
            byteOffset: bufferByteOffset + byteLength,
            byteLength: 0
          };
          for (const accessor of accessors) {
            const data = sparseData.get(accessor);
            if (data.count === 0) continue;
            data.valuesByteOffset = valuesBufferViewDef.byteLength;
            const buffer = BufferUtils.pad(BufferUtils.toView(data.values));
            buffers.push(buffer);
            byteLength += buffer.byteLength;
            valuesBufferViewDef.byteLength += buffer.byteLength;
          }
          json.bufferViews.push(valuesBufferViewDef);
          const valuesBufferViewIndex = json.bufferViews.length - 1;
          for (const accessor of accessors) {
            const data = sparseData.get(accessor);
            if (data.count === 0) continue;
            data.accessorDef.sparse = {
              count: data.count,
              indices: {
                bufferView: indicesBufferViewIndex,
                byteOffset: data.indicesByteOffset,
                componentType: IndexComponentType
              },
              values: {
                bufferView: valuesBufferViewIndex,
                byteOffset: data.valuesByteOffset
              }
            };
          }
          return {
            buffers,
            byteLength
          };
        }
        json.accessors = [];
        json.bufferViews = [];
        json.samplers = [];
        json.textures = [];
        json.images = root.listTextures().map((texture, textureIndex) => {
          const imageDef = context.createPropertyDef(texture);
          if (texture.getMimeType()) {
            imageDef.mimeType = texture.getMimeType();
          }
          const image = texture.getImage();
          if (image) {
            context.createImageData(imageDef, image, texture);
          }
          context.imageIndexMap.set(texture, textureIndex);
          return imageDef;
        });
        extensionsUsed.filter((extension) => extension.prewriteTypes.includes(PropertyType.ACCESSOR)).forEach((extension) => extension.prewrite(context, PropertyType.ACCESSOR));
        root.listAccessors().forEach((accessor) => {
          const groupByParent = context.accessorUsageGroupedByParent;
          const accessorParents = context.accessorParents;
          if (context.accessorIndexMap.has(accessor)) return;
          const usage = context.getAccessorUsage(accessor);
          context.addAccessorToUsageGroup(accessor, usage);
          if (groupByParent.has(usage)) {
            const parent = graph.listParents(accessor).find((parent2) => parent2.propertyType !== PropertyType.ROOT);
            accessorParents.set(accessor, parent);
          }
        });
        extensionsUsed.filter((extension) => extension.prewriteTypes.includes(PropertyType.BUFFER)).forEach((extension) => extension.prewrite(context, PropertyType.BUFFER));
        const needsBuffer = root.listAccessors().length > 0 || context.otherBufferViews.size > 0 || root.listTextures().length > 0 && options.format === Format.GLB;
        if (needsBuffer && root.listBuffers().length === 0) {
          throw new Error("Buffer required for Document resources, but none was found.");
        }
        json.buffers = [];
        root.listBuffers().forEach((buffer, index) => {
          const bufferDef = context.createPropertyDef(buffer);
          const groupByParent = context.accessorUsageGroupedByParent;
          const accessors = buffer.listParents().filter((property) => property instanceof Accessor);
          const uniqueParents = new Set(accessors.map((accessor) => context.accessorParents.get(accessor)));
          const parentToIndex = new Map(Array.from(uniqueParents).map((parent, index2) => [parent, index2]));
          const accessorGroups = {};
          for (const accessor of accessors) {
            var _key;
            if (context.accessorIndexMap.has(accessor)) continue;
            const usage = context.getAccessorUsage(accessor);
            let key = usage;
            if (groupByParent.has(usage)) {
              const parent = context.accessorParents.get(accessor);
              key += `:${parentToIndex.get(parent)}`;
            }
            accessorGroups[_key = key] || (accessorGroups[_key] = {
              usage,
              accessors: []
            });
            accessorGroups[key].accessors.push(accessor);
          }
          const buffers = [];
          const bufferIndex = json.buffers.length;
          let bufferByteLength = 0;
          for (const {
            usage,
            accessors: groupAccessors
          } of Object.values(accessorGroups)) {
            if (usage === BufferViewUsage.ARRAY_BUFFER && options.vertexLayout === VertexLayout.INTERLEAVED) {
              const result = interleaveAccessors(groupAccessors, bufferIndex, bufferByteLength);
              bufferByteLength += result.byteLength;
              for (const _buffer of result.buffers) {
                buffers.push(_buffer);
              }
            } else if (usage === BufferViewUsage.ARRAY_BUFFER) {
              for (const accessor of groupAccessors) {
                const result = interleaveAccessors([accessor], bufferIndex, bufferByteLength);
                bufferByteLength += result.byteLength;
                for (const _buffer2 of result.buffers) {
                  buffers.push(_buffer2);
                }
              }
            } else if (usage === BufferViewUsage.SPARSE) {
              const result = concatSparseAccessors(groupAccessors, bufferIndex, bufferByteLength);
              bufferByteLength += result.byteLength;
              for (const _buffer3 of result.buffers) {
                buffers.push(_buffer3);
              }
            } else if (usage === BufferViewUsage.ELEMENT_ARRAY_BUFFER) {
              const target = WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER;
              const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength, target);
              bufferByteLength += result.byteLength;
              for (const _buffer4 of result.buffers) {
                buffers.push(_buffer4);
              }
            } else {
              const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength);
              bufferByteLength += result.byteLength;
              for (const _buffer5 of result.buffers) {
                buffers.push(_buffer5);
              }
            }
          }
          if (context.imageBufferViews.length && index === 0) {
            for (let i = 0; i < context.imageBufferViews.length; i++) {
              json.bufferViews[json.images[i].bufferView].byteOffset = bufferByteLength;
              bufferByteLength += context.imageBufferViews[i].byteLength;
              buffers.push(context.imageBufferViews[i]);
              if (bufferByteLength % 8) {
                const imagePadding = 8 - bufferByteLength % 8;
                bufferByteLength += imagePadding;
                buffers.push(new Uint8Array(imagePadding));
              }
            }
          }
          if (context.otherBufferViews.has(buffer)) {
            for (const data of context.otherBufferViews.get(buffer)) {
              json.bufferViews.push({
                buffer: bufferIndex,
                byteOffset: bufferByteLength,
                byteLength: data.byteLength
              });
              context.otherBufferViewsIndexMap.set(data, json.bufferViews.length - 1);
              bufferByteLength += data.byteLength;
              buffers.push(data);
            }
          }
          if (bufferByteLength) {
            let uri;
            if (options.format === Format.GLB) {
              uri = GLB_BUFFER;
            } else {
              uri = context.bufferURIGenerator.createURI(buffer, "bin");
              bufferDef.uri = uri;
            }
            bufferDef.byteLength = bufferByteLength;
            context.assignResourceURI(uri, BufferUtils.concat(buffers), true);
          }
          json.buffers.push(bufferDef);
          context.bufferIndexMap.set(buffer, index);
        });
        if (root.listAccessors().find((a) => !a.getBuffer())) {
          logger.warn("Skipped writing one or more Accessors: no Buffer assigned.");
        }
        extensionsUsed.filter((extension) => extension.prewriteTypes.includes(PropertyType.MATERIAL)).forEach((extension) => extension.prewrite(context, PropertyType.MATERIAL));
        json.materials = root.listMaterials().map((material, index) => {
          const materialDef = context.createPropertyDef(material);
          if (material.getAlphaMode() !== Material.AlphaMode.OPAQUE) {
            materialDef.alphaMode = material.getAlphaMode();
          }
          if (material.getAlphaMode() === Material.AlphaMode.MASK) {
            materialDef.alphaCutoff = material.getAlphaCutoff();
          }
          if (material.getDoubleSided()) materialDef.doubleSided = true;
          materialDef.pbrMetallicRoughness = {};
          if (!MathUtils.eq(material.getBaseColorFactor(), [1, 1, 1, 1])) {
            materialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();
          }
          if (!MathUtils.eq(material.getEmissiveFactor(), [0, 0, 0])) {
            materialDef.emissiveFactor = material.getEmissiveFactor();
          }
          if (material.getRoughnessFactor() !== 1) {
            materialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();
          }
          if (material.getMetallicFactor() !== 1) {
            materialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();
          }
          if (material.getBaseColorTexture()) {
            const texture = material.getBaseColorTexture();
            const textureInfo = material.getBaseColorTextureInfo();
            materialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);
          }
          if (material.getEmissiveTexture()) {
            const texture = material.getEmissiveTexture();
            const textureInfo = material.getEmissiveTextureInfo();
            materialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);
          }
          if (material.getNormalTexture()) {
            const texture = material.getNormalTexture();
            const textureInfo = material.getNormalTextureInfo();
            const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);
            if (material.getNormalScale() !== 1) {
              textureInfoDef.scale = material.getNormalScale();
            }
            materialDef.normalTexture = textureInfoDef;
          }
          if (material.getOcclusionTexture()) {
            const texture = material.getOcclusionTexture();
            const textureInfo = material.getOcclusionTextureInfo();
            const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);
            if (material.getOcclusionStrength() !== 1) {
              textureInfoDef.strength = material.getOcclusionStrength();
            }
            materialDef.occlusionTexture = textureInfoDef;
          }
          if (material.getMetallicRoughnessTexture()) {
            const texture = material.getMetallicRoughnessTexture();
            const textureInfo = material.getMetallicRoughnessTextureInfo();
            materialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);
          }
          context.materialIndexMap.set(material, index);
          return materialDef;
        });
        extensionsUsed.filter((extension) => extension.prewriteTypes.includes(PropertyType.MESH)).forEach((extension) => extension.prewrite(context, PropertyType.MESH));
        json.meshes = root.listMeshes().map((mesh, index) => {
          const meshDef = context.createPropertyDef(mesh);
          let targetNames = null;
          meshDef.primitives = mesh.listPrimitives().map((primitive) => {
            const primitiveDef = {
              attributes: {}
            };
            primitiveDef.mode = primitive.getMode();
            const material = primitive.getMaterial();
            if (material) {
              primitiveDef.material = context.materialIndexMap.get(material);
            }
            if (Object.keys(primitive.getExtras()).length) {
              primitiveDef.extras = primitive.getExtras();
            }
            const indices = primitive.getIndices();
            if (indices) {
              primitiveDef.indices = context.accessorIndexMap.get(indices);
            }
            for (const semantic of primitive.listSemantics()) {
              primitiveDef.attributes[semantic] = context.accessorIndexMap.get(primitive.getAttribute(semantic));
            }
            for (const target of primitive.listTargets()) {
              const targetDef = {};
              for (const semantic of target.listSemantics()) {
                targetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic));
              }
              primitiveDef.targets = primitiveDef.targets || [];
              primitiveDef.targets.push(targetDef);
            }
            if (primitive.listTargets().length && !targetNames) {
              targetNames = primitive.listTargets().map((target) => target.getName());
            }
            return primitiveDef;
          });
          if (mesh.getWeights().length) {
            meshDef.weights = mesh.getWeights();
          }
          if (targetNames) {
            meshDef.extras = meshDef.extras || {};
            meshDef.extras["targetNames"] = targetNames;
          }
          context.meshIndexMap.set(mesh, index);
          return meshDef;
        });
        json.cameras = root.listCameras().map((camera, index) => {
          const cameraDef = context.createPropertyDef(camera);
          cameraDef.type = camera.getType();
          if (cameraDef.type === Camera.Type.PERSPECTIVE) {
            cameraDef.perspective = {
              znear: camera.getZNear(),
              zfar: camera.getZFar(),
              yfov: camera.getYFov()
            };
            const aspectRatio = camera.getAspectRatio();
            if (aspectRatio !== null) {
              cameraDef.perspective.aspectRatio = aspectRatio;
            }
          } else {
            cameraDef.orthographic = {
              znear: camera.getZNear(),
              zfar: camera.getZFar(),
              xmag: camera.getXMag(),
              ymag: camera.getYMag()
            };
          }
          context.cameraIndexMap.set(camera, index);
          return cameraDef;
        });
        json.nodes = root.listNodes().map((node, index) => {
          const nodeDef = context.createPropertyDef(node);
          if (!MathUtils.eq(node.getTranslation(), [0, 0, 0])) {
            nodeDef.translation = node.getTranslation();
          }
          if (!MathUtils.eq(node.getRotation(), [0, 0, 0, 1])) {
            nodeDef.rotation = node.getRotation();
          }
          if (!MathUtils.eq(node.getScale(), [1, 1, 1])) {
            nodeDef.scale = node.getScale();
          }
          if (node.getWeights().length) {
            nodeDef.weights = node.getWeights();
          }
          context.nodeIndexMap.set(node, index);
          return nodeDef;
        });
        json.skins = root.listSkins().map((skin, index) => {
          const skinDef = context.createPropertyDef(skin);
          const inverseBindMatrices = skin.getInverseBindMatrices();
          if (inverseBindMatrices) {
            skinDef.inverseBindMatrices = context.accessorIndexMap.get(inverseBindMatrices);
          }
          const skeleton = skin.getSkeleton();
          if (skeleton) {
            skinDef.skeleton = context.nodeIndexMap.get(skeleton);
          }
          skinDef.joints = skin.listJoints().map((joint) => context.nodeIndexMap.get(joint));
          context.skinIndexMap.set(skin, index);
          return skinDef;
        });
        root.listNodes().forEach((node, index) => {
          const nodeDef = json.nodes[index];
          const mesh = node.getMesh();
          if (mesh) {
            nodeDef.mesh = context.meshIndexMap.get(mesh);
          }
          const camera = node.getCamera();
          if (camera) {
            nodeDef.camera = context.cameraIndexMap.get(camera);
          }
          const skin = node.getSkin();
          if (skin) {
            nodeDef.skin = context.skinIndexMap.get(skin);
          }
          if (node.listChildren().length > 0) {
            nodeDef.children = node.listChildren().map((node2) => context.nodeIndexMap.get(node2));
          }
        });
        json.animations = root.listAnimations().map((animation2, index) => {
          const animationDef = context.createPropertyDef(animation2);
          const samplerIndexMap = /* @__PURE__ */ new Map();
          animationDef.samplers = animation2.listSamplers().map((sampler, samplerIndex) => {
            const samplerDef = context.createPropertyDef(sampler);
            samplerDef.input = context.accessorIndexMap.get(sampler.getInput());
            samplerDef.output = context.accessorIndexMap.get(sampler.getOutput());
            samplerDef.interpolation = sampler.getInterpolation();
            samplerIndexMap.set(sampler, samplerIndex);
            return samplerDef;
          });
          animationDef.channels = animation2.listChannels().map((channel) => {
            const channelDef = context.createPropertyDef(channel);
            channelDef.sampler = samplerIndexMap.get(channel.getSampler());
            channelDef.target = {
              node: context.nodeIndexMap.get(channel.getTargetNode()),
              path: channel.getTargetPath()
            };
            return channelDef;
          });
          context.animationIndexMap.set(animation2, index);
          return animationDef;
        });
        json.scenes = root.listScenes().map((scene, index) => {
          const sceneDef = context.createPropertyDef(scene);
          sceneDef.nodes = scene.listChildren().map((node) => context.nodeIndexMap.get(node));
          context.sceneIndexMap.set(scene, index);
          return sceneDef;
        });
        const defaultScene = root.getDefaultScene();
        if (defaultScene) {
          json.scene = root.listScenes().indexOf(defaultScene);
        }
        json.extensionsUsed = extensionsUsed.map((ext) => ext.extensionName);
        json.extensionsRequired = extensionsRequired.map((ext) => ext.extensionName);
        extensionsUsed.forEach((extension) => extension.write(context));
        clean(json);
        return jsonDoc;
      }
    };
    (function(ChunkType2) {
      ChunkType2[ChunkType2["JSON"] = 1313821514] = "JSON";
      ChunkType2[ChunkType2["BIN"] = 5130562] = "BIN";
    })(ChunkType || (ChunkType = {}));
    PlatformIO = class {
      constructor() {
        this._logger = Logger.DEFAULT_INSTANCE;
        this._extensions = /* @__PURE__ */ new Set();
        this._dependencies = {};
        this._vertexLayout = VertexLayout.INTERLEAVED;
        this.lastReadBytes = 0;
        this.lastWriteBytes = 0;
      }
      /** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */
      setLogger(logger) {
        this._logger = logger;
        return this;
      }
      /** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */
      registerExtensions(extensions) {
        for (const extension of extensions) {
          this._extensions.add(extension);
          extension.register();
        }
        return this;
      }
      /** Registers dependencies used (e.g. by extensions) in the I/O process. */
      registerDependencies(dependencies) {
        Object.assign(this._dependencies, dependencies);
        return this;
      }
      /**
       * Sets the vertex layout method used by this I/O instance. Defaults to
       * VertexLayout.INTERLEAVED.
       */
      setVertexLayout(layout) {
        this._vertexLayout = layout;
        return this;
      }
      /**********************************************************************************************
       * Public Read API.
       */
      /** Reads a {@link Document} from the given URI. */
      async read(uri) {
        return await this.readJSON(await this.readAsJSON(uri));
      }
      /** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */
      async readAsJSON(uri) {
        const view = await this.readURI(uri, "view");
        this.lastReadBytes = view.byteLength;
        const jsonDoc = isGLB(view) ? this._binaryToJSON(view) : {
          json: JSON.parse(BufferUtils.decodeText(view)),
          resources: {}
        };
        await this._readResourcesExternal(jsonDoc, this.dirname(uri));
        this._readResourcesInternal(jsonDoc);
        return jsonDoc;
      }
      /** Converts glTF-formatted JSON and a resource map to a {@link Document}. */
      async readJSON(jsonDoc) {
        jsonDoc = this._copyJSON(jsonDoc);
        this._readResourcesInternal(jsonDoc);
        return GLTFReader.read(jsonDoc, {
          extensions: Array.from(this._extensions),
          dependencies: this._dependencies,
          logger: this._logger
        });
      }
      /** Converts a GLB-formatted Uint8Array to a {@link JSONDocument}. */
      async binaryToJSON(glb) {
        const jsonDoc = this._binaryToJSON(BufferUtils.assertView(glb));
        this._readResourcesInternal(jsonDoc);
        const json = jsonDoc.json;
        if (json.buffers && json.buffers.some((bufferDef) => isExternalBuffer(jsonDoc, bufferDef))) {
          throw new Error("Cannot resolve external buffers with binaryToJSON().");
        } else if (json.images && json.images.some((imageDef) => isExternalImage(jsonDoc, imageDef))) {
          throw new Error("Cannot resolve external images with binaryToJSON().");
        }
        return jsonDoc;
      }
      /** Converts a GLB-formatted Uint8Array to a {@link Document}. */
      async readBinary(glb) {
        return this.readJSON(await this.binaryToJSON(BufferUtils.assertView(glb)));
      }
      /**********************************************************************************************
       * Public Write API.
       */
      /** Converts a {@link Document} to glTF-formatted JSON and a resource map. */
      async writeJSON(doc, _options = {}) {
        if (_options.format === Format.GLB && doc.getRoot().listBuffers().length > 1) {
          throw new Error("GLB must have 0\u20131 buffers.");
        }
        return GLTFWriter.write(doc, {
          format: _options.format || Format.GLTF,
          basename: _options.basename || "",
          logger: this._logger,
          vertexLayout: this._vertexLayout,
          dependencies: _extends2({}, this._dependencies),
          extensions: Array.from(this._extensions)
        });
      }
      /** Converts a {@link Document} to a GLB-formatted Uint8Array. */
      async writeBinary(doc) {
        const {
          json,
          resources
        } = await this.writeJSON(doc, {
          format: Format.GLB
        });
        const header = new Uint32Array([1179937895, 2, 12]);
        const jsonText = JSON.stringify(json);
        const jsonChunkData = BufferUtils.pad(BufferUtils.encodeText(jsonText), 32);
        const jsonChunkHeader = BufferUtils.toView(new Uint32Array([jsonChunkData.byteLength, 1313821514]));
        const jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);
        header[header.length - 1] += jsonChunk.byteLength;
        const binBuffer = Object.values(resources)[0];
        if (!binBuffer || !binBuffer.byteLength) {
          return BufferUtils.concat([BufferUtils.toView(header), jsonChunk]);
        }
        const binChunkData = BufferUtils.pad(binBuffer, 0);
        const binChunkHeader = BufferUtils.toView(new Uint32Array([binChunkData.byteLength, 5130562]));
        const binChunk = BufferUtils.concat([binChunkHeader, binChunkData]);
        header[header.length - 1] += binChunk.byteLength;
        return BufferUtils.concat([BufferUtils.toView(header), jsonChunk, binChunk]);
      }
      /**********************************************************************************************
       * Internal.
       */
      async _readResourcesExternal(jsonDoc, base) {
        var _this = this;
        const images = jsonDoc.json.images || [];
        const buffers = jsonDoc.json.buffers || [];
        const pendingResources = [...images, ...buffers].map(async function(resource) {
          const uri = resource.uri;
          if (!uri || uri.match(/data:/)) return Promise.resolve();
          jsonDoc.resources[uri] = await _this.readURI(_this.resolve(base, uri), "view");
          _this.lastReadBytes += jsonDoc.resources[uri].byteLength;
        });
        await Promise.all(pendingResources);
      }
      _readResourcesInternal(jsonDoc) {
        function resolveResource(resource) {
          if (!resource.uri) return;
          if (resource.uri in jsonDoc.resources) {
            BufferUtils.assertView(jsonDoc.resources[resource.uri]);
            return;
          }
          if (resource.uri.match(/data:/)) {
            const resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;
            jsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);
            resource.uri = resourceUUID;
          }
        }
        const images = jsonDoc.json.images || [];
        images.forEach((image) => {
          if (image.bufferView === void 0 && image.uri === void 0) {
            throw new Error("Missing resource URI or buffer view.");
          }
          resolveResource(image);
        });
        const buffers = jsonDoc.json.buffers || [];
        buffers.forEach(resolveResource);
      }
      /**
       * Creates a shallow copy of glTF-formatted {@link JSONDocument}.
       *
       * Images, Buffers, and Resources objects are deep copies so that PlatformIO can safely
       * modify them during the parsing process. Other properties are shallow copies, and buffers
       * are passed by reference.
       */
      _copyJSON(jsonDoc) {
        const {
          images,
          buffers
        } = jsonDoc.json;
        jsonDoc = {
          json: _extends2({}, jsonDoc.json),
          resources: _extends2({}, jsonDoc.resources)
        };
        if (images) {
          jsonDoc.json.images = images.map((image) => _extends2({}, image));
        }
        if (buffers) {
          jsonDoc.json.buffers = buffers.map((buffer) => _extends2({}, buffer));
        }
        return jsonDoc;
      }
      /** Internal version of binaryToJSON; does not warn about external resources. */
      _binaryToJSON(glb) {
        if (!isGLB(glb)) {
          throw new Error("Invalid glTF 2.0 binary.");
        }
        const jsonChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + 12, 2);
        if (jsonChunkHeader[1] !== ChunkType.JSON) {
          throw new Error("Missing required GLB JSON chunk.");
        }
        const jsonByteOffset = 20;
        const jsonByteLength = jsonChunkHeader[0];
        const jsonText = BufferUtils.decodeText(BufferUtils.toView(glb, jsonByteOffset, jsonByteLength));
        const json = JSON.parse(jsonText);
        const binByteOffset = jsonByteOffset + jsonByteLength;
        if (glb.byteLength <= binByteOffset) {
          return {
            json,
            resources: {}
          };
        }
        const binChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + binByteOffset, 2);
        if (binChunkHeader[1] !== ChunkType.BIN) {
          return {
            json,
            resources: {}
          };
        }
        const binByteLength = binChunkHeader[0];
        const binBuffer = BufferUtils.toView(glb, binByteOffset + 8, binByteLength);
        return {
          json,
          resources: {
            [GLB_BUFFER]: binBuffer
          }
        };
      }
    };
    WebIO = class extends PlatformIO {
      /**
       * Constructs a new WebIO service. Instances are reusable.
       * @param fetchConfig Configuration object for Fetch API.
       */
      constructor(fetchConfig = HTTPUtils.DEFAULT_INIT) {
        super();
        this._fetchConfig = void 0;
        this._fetchConfig = fetchConfig;
      }
      async readURI(uri, type) {
        const response = await fetch(uri, this._fetchConfig);
        switch (type) {
          case "view":
            return new Uint8Array(await response.arrayBuffer());
          case "text":
            return response.text();
        }
      }
      resolve(base, path) {
        return HTTPUtils.resolve(base, path);
      }
      dirname(uri) {
        return HTTPUtils.dirname(uri);
      }
    };
  }
});

// lib/math.ts
function euler2quat(rotation) {
  const cr = cos(rotation[2] * 0.5 * TAU / 360);
  const sr = sin(rotation[2] * 0.5 * TAU / 360);
  const cp = cos(rotation[1] * 0.5 * TAU / 360);
  const sp = sin(rotation[1] * 0.5 * TAU / 360);
  const cy = cos(rotation[0] * 0.5 * TAU / 360);
  const sy = sin(rotation[0] * 0.5 * TAU / 360);
  const q = [0, 0, 0, 0];
  q[3] = cr * cp * cy + sr * sp * sy;
  q[2] = sr * cp * cy - cr * sp * sy;
  q[1] = cr * sp * cy + sr * cp * sy;
  q[0] = cr * cp * sy - sr * sp * cy;
  return q;
}
var cos, sin, PI, TAU;
var init_math = __esm({
  "lib/math.ts"() {
    "use strict";
    ({ cos, sin, PI } = Math);
    TAU = PI * 2;
  }
});

// lib/animation.ts
function cleanup() {
  manifold2morph.clear();
  animationMode = "loop";
  animationDuration = 1;
  animationFPS = 30;
}
function addMotion(doc, type, node, out) {
  const motion = node[type];
  if (motion == null) {
    return null;
  }
  if (typeof motion !== "function") {
    return motion;
  }
  const nFrames = timesAccessor.getCount();
  const nEl = type == "rotation" ? 4 : 3;
  const frames = new Float32Array(nEl * nFrames);
  for (let i = 0; i < nFrames; ++i) {
    const x = i / (nFrames - 1);
    const m = motion(
      animationMode !== "ping-pong" ? x : (1 - Math.cos(x * 2 * Math.PI)) / 2
    );
    frames.set(nEl === 4 ? euler2quat(m) : m, nEl * i);
  }
  const framesAccessor = doc.createAccessor(node.name + " " + type + " frames").setBuffer(doc.getRoot().listBuffers()[0]).setArray(frames).setType(nEl === 4 ? Accessor.Type.VEC4 : Accessor.Type.VEC3);
  const sampler = doc.createAnimationSampler().setInput(timesAccessor).setOutput(framesAccessor).setInterpolation("LINEAR");
  const channel = doc.createAnimationChannel().setTargetPath(type).setTargetNode(out).setSampler(sampler);
  animation.addSampler(sampler);
  animation.addChannel(channel);
  hasAnimation = true;
  return motion(0);
}
function setMorph(doc, node, manifold) {
  if (manifold2morph.has(manifold)) {
    const channel = doc.createAnimationChannel().setTargetPath("weights").setTargetNode(node).setSampler(weightsSampler);
    animation.addChannel(channel);
    hasAnimation = true;
  }
}
function morphStart(manifoldMesh, morph) {
  const inputPositions = [];
  if (morph == null) {
    return inputPositions;
  }
  for (let i = 0; i < manifoldMesh.numVert; ++i) {
    for (let j = 0; j < 3; ++j)
      inputPositions[i * 3 + j] = manifoldMesh.vertProperties[i * manifoldMesh.numProp + j];
  }
  if (morph.start) {
    for (let i = 0; i < manifoldMesh.numVert; ++i) {
      const vertProp = manifoldMesh.vertProperties;
      const offset = i * manifoldMesh.numProp;
      const pos = inputPositions.slice(offset, offset + 3);
      morph.start(pos);
      for (let j = 0; j < 3; ++j) vertProp[offset + j] = pos[j];
    }
  }
  return inputPositions;
}
function morphEnd(doc, manifoldMesh, mesh, inputPositions, morph) {
  if (morph == null) {
    return;
  }
  mesh.setWeights([0]);
  mesh.listPrimitives().forEach((primitive, i) => {
    if (morph.end) {
      for (let i2 = 0; i2 < manifoldMesh.numVert; ++i2) {
        const pos = inputPositions.slice(3 * i2, 3 * (i2 + 1));
        morph.end(pos);
        inputPositions.splice(3 * i2, 3, ...pos);
      }
    }
    const startPosition = primitive.getAttribute("POSITION").getArray();
    const array = new Float32Array(startPosition.length);
    const offset = manifoldMesh.runIndex[i];
    for (let j = 0; j < array.length; ++j) {
      array[j] = inputPositions[offset + j] - startPosition[j];
    }
    const morphAccessor = doc.createAccessor(mesh.getName() + " morph target").setBuffer(doc.getRoot().listBuffers()[0]).setArray(array).setType(Accessor.Type.VEC3);
    const morphTarget = doc.createPrimitiveTarget().setAttribute("POSITION", morphAccessor);
    primitive.addTarget(morphTarget);
  });
}
function addAnimationToDoc(doc) {
  animation = doc.createAnimation("");
  hasAnimation = false;
  const nFrames = Math.round(animationDuration * animationFPS) + 1;
  const times = new Float32Array(nFrames);
  const weights = new Float32Array(nFrames);
  for (let i = 0; i < nFrames; ++i) {
    const x = i / (nFrames - 1);
    times[i] = x * animationDuration;
    weights[i] = animationMode !== "ping-pong" ? x : (1 - Math.cos(x * 2 * Math.PI)) / 2;
  }
  timesAccessor = doc.createAccessor("animation times").setBuffer(doc.createBuffer()).setArray(times).setType(Accessor.Type.SCALAR);
  weightsAccessor = doc.createAccessor("animation weights").setBuffer(doc.getRoot().listBuffers()[0]).setArray(weights).setType(Accessor.Type.SCALAR);
  weightsSampler = doc.createAnimationSampler().setInput(timesAccessor).setOutput(weightsAccessor).setInterpolation("LINEAR");
  animation.addSampler(weightsSampler);
}
function cleanupAnimationInDoc() {
  if (!hasAnimation) {
    timesAccessor.dispose();
    weightsAccessor.dispose();
    weightsSampler.dispose();
    animation.dispose();
  }
}
var animationMode, animationDuration, animationFPS, setAnimationMode, getAnimationMode, setAnimationDuration, getAnimationDuration, setAnimationFPS, getAnimationFPS, manifold2morph, animation, timesAccessor, weightsAccessor, weightsSampler, hasAnimation, getMorph, setMorphStart, setMorphEnd;
var init_animation = __esm({
  "lib/animation.ts"() {
    "use strict";
    init_index_modern();
    init_math();
    animationMode = "loop";
    animationDuration = 1;
    animationFPS = 30;
    setAnimationMode = (mode) => {
      animationMode = mode;
    };
    getAnimationMode = () => animationMode;
    setAnimationDuration = (duration) => {
      animationDuration = duration;
    };
    getAnimationDuration = () => animationDuration;
    setAnimationFPS = (fps) => {
      animationFPS = fps;
    };
    getAnimationFPS = () => animationFPS;
    manifold2morph = /* @__PURE__ */ new Map();
    getMorph = (manifold) => manifold2morph.get(manifold);
    setMorphStart = (manifold, func) => {
      const morph = manifold2morph.get(manifold);
      if (morph != null) {
        morph.start = func;
      } else {
        manifold2morph.set(manifold, { start: func });
      }
    };
    setMorphEnd = (manifold, func) => {
      const morph = manifold2morph.get(manifold);
      if (morph != null) {
        morph.end = func;
      } else {
        manifold2morph.set(manifold, { end: func });
      }
    };
  }
});

// node_modules/esbuild-wasm/lib/browser.js
var require_browser = __commonJS({
  "node_modules/esbuild-wasm/lib/browser.js"(exports, module) {
    ((module2) => {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export2 = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var __async = (__this, __arguments, generator) => {
        return new Promise((resolve, reject) => {
          var fulfilled = (value2) => {
            try {
              step(generator.next(value2));
            } catch (e) {
              reject(e);
            }
          };
          var rejected = (value2) => {
            try {
              step(generator.throw(value2));
            } catch (e) {
              reject(e);
            }
          };
          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
          step((generator = generator.apply(__this, __arguments)).next());
        });
      };
      var browser_exports = {};
      __export2(browser_exports, {
        analyzeMetafile: () => analyzeMetafile,
        analyzeMetafileSync: () => analyzeMetafileSync,
        build: () => build2,
        buildSync: () => buildSync,
        context: () => context,
        default: () => browser_default,
        formatMessages: () => formatMessages,
        formatMessagesSync: () => formatMessagesSync,
        initialize: () => initialize2,
        stop: () => stop,
        transform: () => transform,
        transformSync: () => transformSync,
        version: () => version
      });
      module2.exports = __toCommonJS(browser_exports);
      function encodePacket(packet) {
        let visit = (value2) => {
          if (value2 === null) {
            bb.write8(0);
          } else if (typeof value2 === "boolean") {
            bb.write8(1);
            bb.write8(+value2);
          } else if (typeof value2 === "number") {
            bb.write8(2);
            bb.write32(value2 | 0);
          } else if (typeof value2 === "string") {
            bb.write8(3);
            bb.write(encodeUTF8(value2));
          } else if (value2 instanceof Uint8Array) {
            bb.write8(4);
            bb.write(value2);
          } else if (value2 instanceof Array) {
            bb.write8(5);
            bb.write32(value2.length);
            for (let item of value2) {
              visit(item);
            }
          } else {
            let keys = Object.keys(value2);
            bb.write8(6);
            bb.write32(keys.length);
            for (let key of keys) {
              bb.write(encodeUTF8(key));
              visit(value2[key]);
            }
          }
        };
        let bb = new ByteBuffer();
        bb.write32(0);
        bb.write32(packet.id << 1 | +!packet.isRequest);
        visit(packet.value);
        writeUInt32LE(bb.buf, bb.len - 4, 0);
        return bb.buf.subarray(0, bb.len);
      }
      function decodePacket(bytes) {
        let visit = () => {
          switch (bb.read8()) {
            case 0:
              return null;
            case 1:
              return !!bb.read8();
            case 2:
              return bb.read32();
            case 3:
              return decodeUTF8(bb.read());
            case 4:
              return bb.read();
            case 5: {
              let count = bb.read32();
              let value22 = [];
              for (let i = 0; i < count; i++) {
                value22.push(visit());
              }
              return value22;
            }
            case 6: {
              let count = bb.read32();
              let value22 = {};
              for (let i = 0; i < count; i++) {
                value22[decodeUTF8(bb.read())] = visit();
              }
              return value22;
            }
            default:
              throw new Error("Invalid packet");
          }
        };
        let bb = new ByteBuffer(bytes);
        let id = bb.read32();
        let isRequest = (id & 1) === 0;
        id >>>= 1;
        let value2 = visit();
        if (bb.ptr !== bytes.length) {
          throw new Error("Invalid packet");
        }
        return { id, isRequest, value: value2 };
      }
      var ByteBuffer = class {
        constructor(buf = new Uint8Array(1024)) {
          this.buf = buf;
          this.len = 0;
          this.ptr = 0;
        }
        _write(delta) {
          if (this.len + delta > this.buf.length) {
            let clone = new Uint8Array((this.len + delta) * 2);
            clone.set(this.buf);
            this.buf = clone;
          }
          this.len += delta;
          return this.len - delta;
        }
        write8(value2) {
          let offset = this._write(1);
          this.buf[offset] = value2;
        }
        write32(value2) {
          let offset = this._write(4);
          writeUInt32LE(this.buf, value2, offset);
        }
        write(bytes) {
          let offset = this._write(4 + bytes.length);
          writeUInt32LE(this.buf, bytes.length, offset);
          this.buf.set(bytes, offset + 4);
        }
        _read(delta) {
          if (this.ptr + delta > this.buf.length) {
            throw new Error("Invalid packet");
          }
          this.ptr += delta;
          return this.ptr - delta;
        }
        read8() {
          return this.buf[this._read(1)];
        }
        read32() {
          return readUInt32LE(this.buf, this._read(4));
        }
        read() {
          let length2 = this.read32();
          let bytes = new Uint8Array(length2);
          let ptr = this._read(bytes.length);
          bytes.set(this.buf.subarray(ptr, ptr + length2));
          return bytes;
        }
      };
      var encodeUTF8;
      var decodeUTF8;
      var encodeInvariant;
      if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
        let encoder = new TextEncoder();
        let decoder = new TextDecoder();
        encodeUTF8 = (text) => encoder.encode(text);
        decodeUTF8 = (bytes) => decoder.decode(bytes);
        encodeInvariant = 'new TextEncoder().encode("")';
      } else if (typeof Buffer !== "undefined") {
        encodeUTF8 = (text) => Buffer.from(text);
        decodeUTF8 = (bytes) => {
          let { buffer, byteOffset, byteLength } = bytes;
          return Buffer.from(buffer, byteOffset, byteLength).toString();
        };
        encodeInvariant = 'Buffer.from("")';
      } else {
        throw new Error("No UTF-8 codec found");
      }
      if (!(encodeUTF8("") instanceof Uint8Array))
        throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
      function readUInt32LE(buffer, offset) {
        return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
      }
      function writeUInt32LE(buffer, value2, offset) {
        buffer[offset++] = value2;
        buffer[offset++] = value2 >> 8;
        buffer[offset++] = value2 >> 16;
        buffer[offset++] = value2 >> 24;
      }
      var quote = JSON.stringify;
      var buildLogLevelDefault = "warning";
      var transformLogLevelDefault = "silent";
      function validateAndJoinStringArray(values, what) {
        const toJoin = [];
        for (const value2 of values) {
          validateStringValue(value2, what);
          if (value2.indexOf(",") >= 0) throw new Error(`Invalid ${what}: ${value2}`);
          toJoin.push(value2);
        }
        return toJoin.join(",");
      }
      var canBeAnything = () => null;
      var mustBeBoolean = (value2) => typeof value2 === "boolean" ? null : "a boolean";
      var mustBeString = (value2) => typeof value2 === "string" ? null : "a string";
      var mustBeRegExp = (value2) => value2 instanceof RegExp ? null : "a RegExp object";
      var mustBeInteger = (value2) => typeof value2 === "number" && value2 === (value2 | 0) ? null : "an integer";
      var mustBeValidPortNumber = (value2) => typeof value2 === "number" && value2 === (value2 | 0) && value2 >= 0 && value2 <= 65535 ? null : "a valid port number";
      var mustBeFunction = (value2) => typeof value2 === "function" ? null : "a function";
      var mustBeArray = (value2) => Array.isArray(value2) ? null : "an array";
      var mustBeArrayOfStrings = (value2) => Array.isArray(value2) && value2.every((x) => typeof x === "string") ? null : "an array of strings";
      var mustBeObject = (value2) => typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "an object";
      var mustBeEntryPoints = (value2) => typeof value2 === "object" && value2 !== null ? null : "an array or an object";
      var mustBeWebAssemblyModule = (value2) => value2 instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
      var mustBeObjectOrNull = (value2) => typeof value2 === "object" && !Array.isArray(value2) ? null : "an object or null";
      var mustBeStringOrBoolean = (value2) => typeof value2 === "string" || typeof value2 === "boolean" ? null : "a string or a boolean";
      var mustBeStringOrObject = (value2) => typeof value2 === "string" || typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "a string or an object";
      var mustBeStringOrArrayOfStrings = (value2) => typeof value2 === "string" || Array.isArray(value2) && value2.every((x) => typeof x === "string") ? null : "a string or an array of strings";
      var mustBeStringOrUint8Array = (value2) => typeof value2 === "string" || value2 instanceof Uint8Array ? null : "a string or a Uint8Array";
      var mustBeStringOrURL = (value2) => typeof value2 === "string" || value2 instanceof URL ? null : "a string or a URL";
      function getFlag(object, keys, key, mustBeFn) {
        let value2 = object[key];
        keys[key + ""] = true;
        if (value2 === void 0) return void 0;
        let mustBe = mustBeFn(value2);
        if (mustBe !== null) throw new Error(`${quote(key)} must be ${mustBe}`);
        return value2;
      }
      function checkForInvalidFlags(object, keys, where) {
        for (let key in object) {
          if (!(key in keys)) {
            throw new Error(`Invalid option ${where}: ${quote(key)}`);
          }
        }
      }
      function validateInitializeOptions(options) {
        let keys = /* @__PURE__ */ Object.create(null);
        let wasmURL = getFlag(options, keys, "wasmURL", mustBeStringOrURL);
        let wasmModule = getFlag(options, keys, "wasmModule", mustBeWebAssemblyModule);
        let worker = getFlag(options, keys, "worker", mustBeBoolean);
        checkForInvalidFlags(options, keys, "in initialize() call");
        return {
          wasmURL,
          wasmModule,
          worker
        };
      }
      function validateMangleCache(mangleCache) {
        let validated;
        if (mangleCache !== void 0) {
          validated = /* @__PURE__ */ Object.create(null);
          for (let key in mangleCache) {
            let value2 = mangleCache[key];
            if (typeof value2 === "string" || value2 === false) {
              validated[key] = value2;
            } else {
              throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
            }
          }
        }
        return validated;
      }
      function pushLogFlags(flags, options, keys, isTTY, logLevelDefault) {
        let color = getFlag(options, keys, "color", mustBeBoolean);
        let logLevel = getFlag(options, keys, "logLevel", mustBeString);
        let logLimit = getFlag(options, keys, "logLimit", mustBeInteger);
        if (color !== void 0) flags.push(`--color=${color}`);
        else if (isTTY) flags.push(`--color=true`);
        flags.push(`--log-level=${logLevel || logLevelDefault}`);
        flags.push(`--log-limit=${logLimit || 0}`);
      }
      function validateStringValue(value2, what, key) {
        if (typeof value2 !== "string") {
          throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value2} instead`);
        }
        return value2;
      }
      function pushCommonFlags(flags, options, keys) {
        let legalComments = getFlag(options, keys, "legalComments", mustBeString);
        let sourceRoot = getFlag(options, keys, "sourceRoot", mustBeString);
        let sourcesContent = getFlag(options, keys, "sourcesContent", mustBeBoolean);
        let target = getFlag(options, keys, "target", mustBeStringOrArrayOfStrings);
        let format = getFlag(options, keys, "format", mustBeString);
        let globalName = getFlag(options, keys, "globalName", mustBeString);
        let mangleProps = getFlag(options, keys, "mangleProps", mustBeRegExp);
        let reserveProps = getFlag(options, keys, "reserveProps", mustBeRegExp);
        let mangleQuoted = getFlag(options, keys, "mangleQuoted", mustBeBoolean);
        let minify = getFlag(options, keys, "minify", mustBeBoolean);
        let minifySyntax = getFlag(options, keys, "minifySyntax", mustBeBoolean);
        let minifyWhitespace = getFlag(options, keys, "minifyWhitespace", mustBeBoolean);
        let minifyIdentifiers = getFlag(options, keys, "minifyIdentifiers", mustBeBoolean);
        let lineLimit = getFlag(options, keys, "lineLimit", mustBeInteger);
        let drop = getFlag(options, keys, "drop", mustBeArrayOfStrings);
        let dropLabels = getFlag(options, keys, "dropLabels", mustBeArrayOfStrings);
        let charset = getFlag(options, keys, "charset", mustBeString);
        let treeShaking = getFlag(options, keys, "treeShaking", mustBeBoolean);
        let ignoreAnnotations = getFlag(options, keys, "ignoreAnnotations", mustBeBoolean);
        let jsx = getFlag(options, keys, "jsx", mustBeString);
        let jsxFactory = getFlag(options, keys, "jsxFactory", mustBeString);
        let jsxFragment = getFlag(options, keys, "jsxFragment", mustBeString);
        let jsxImportSource = getFlag(options, keys, "jsxImportSource", mustBeString);
        let jsxDev = getFlag(options, keys, "jsxDev", mustBeBoolean);
        let jsxSideEffects = getFlag(options, keys, "jsxSideEffects", mustBeBoolean);
        let define2 = getFlag(options, keys, "define", mustBeObject);
        let logOverride = getFlag(options, keys, "logOverride", mustBeObject);
        let supported = getFlag(options, keys, "supported", mustBeObject);
        let pure = getFlag(options, keys, "pure", mustBeArrayOfStrings);
        let keepNames = getFlag(options, keys, "keepNames", mustBeBoolean);
        let platform = getFlag(options, keys, "platform", mustBeString);
        let tsconfigRaw = getFlag(options, keys, "tsconfigRaw", mustBeStringOrObject);
        let absPaths = getFlag(options, keys, "absPaths", mustBeArrayOfStrings);
        if (legalComments) flags.push(`--legal-comments=${legalComments}`);
        if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);
        if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);
        if (target) flags.push(`--target=${validateAndJoinStringArray(Array.isArray(target) ? target : [target], "target")}`);
        if (format) flags.push(`--format=${format}`);
        if (globalName) flags.push(`--global-name=${globalName}`);
        if (platform) flags.push(`--platform=${platform}`);
        if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
        if (minify) flags.push("--minify");
        if (minifySyntax) flags.push("--minify-syntax");
        if (minifyWhitespace) flags.push("--minify-whitespace");
        if (minifyIdentifiers) flags.push("--minify-identifiers");
        if (lineLimit) flags.push(`--line-limit=${lineLimit}`);
        if (charset) flags.push(`--charset=${charset}`);
        if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);
        if (ignoreAnnotations) flags.push(`--ignore-annotations`);
        if (drop) for (let what of drop) flags.push(`--drop:${validateStringValue(what, "drop")}`);
        if (dropLabels) flags.push(`--drop-labels=${validateAndJoinStringArray(dropLabels, "drop label")}`);
        if (absPaths) flags.push(`--abs-paths=${validateAndJoinStringArray(absPaths, "abs paths")}`);
        if (mangleProps) flags.push(`--mangle-props=${jsRegExpToGoRegExp(mangleProps)}`);
        if (reserveProps) flags.push(`--reserve-props=${jsRegExpToGoRegExp(reserveProps)}`);
        if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);
        if (jsx) flags.push(`--jsx=${jsx}`);
        if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);
        if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);
        if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);
        if (jsxDev) flags.push(`--jsx-dev`);
        if (jsxSideEffects) flags.push(`--jsx-side-effects`);
        if (define2) {
          for (let key in define2) {
            if (key.indexOf("=") >= 0) throw new Error(`Invalid define: ${key}`);
            flags.push(`--define:${key}=${validateStringValue(define2[key], "define", key)}`);
          }
        }
        if (logOverride) {
          for (let key in logOverride) {
            if (key.indexOf("=") >= 0) throw new Error(`Invalid log override: ${key}`);
            flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
          }
        }
        if (supported) {
          for (let key in supported) {
            if (key.indexOf("=") >= 0) throw new Error(`Invalid supported: ${key}`);
            const value2 = supported[key];
            if (typeof value2 !== "boolean") throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value2} instead`);
            flags.push(`--supported:${key}=${value2}`);
          }
        }
        if (pure) for (let fn of pure) flags.push(`--pure:${validateStringValue(fn, "pure")}`);
        if (keepNames) flags.push(`--keep-names`);
      }
      function flagsForBuildOptions(callName, options, isTTY, logLevelDefault, writeDefault) {
        var _a2;
        let flags = [];
        let entries = [];
        let keys = /* @__PURE__ */ Object.create(null);
        let stdinContents = null;
        let stdinResolveDir = null;
        pushLogFlags(flags, options, keys, isTTY, logLevelDefault);
        pushCommonFlags(flags, options, keys);
        let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
        let bundle = getFlag(options, keys, "bundle", mustBeBoolean);
        let splitting = getFlag(options, keys, "splitting", mustBeBoolean);
        let preserveSymlinks = getFlag(options, keys, "preserveSymlinks", mustBeBoolean);
        let metafile = getFlag(options, keys, "metafile", mustBeBoolean);
        let outfile = getFlag(options, keys, "outfile", mustBeString);
        let outdir = getFlag(options, keys, "outdir", mustBeString);
        let outbase = getFlag(options, keys, "outbase", mustBeString);
        let tsconfig = getFlag(options, keys, "tsconfig", mustBeString);
        let resolveExtensions = getFlag(options, keys, "resolveExtensions", mustBeArrayOfStrings);
        let nodePathsInput = getFlag(options, keys, "nodePaths", mustBeArrayOfStrings);
        let mainFields = getFlag(options, keys, "mainFields", mustBeArrayOfStrings);
        let conditions = getFlag(options, keys, "conditions", mustBeArrayOfStrings);
        let external = getFlag(options, keys, "external", mustBeArrayOfStrings);
        let packages = getFlag(options, keys, "packages", mustBeString);
        let alias = getFlag(options, keys, "alias", mustBeObject);
        let loader = getFlag(options, keys, "loader", mustBeObject);
        let outExtension = getFlag(options, keys, "outExtension", mustBeObject);
        let publicPath = getFlag(options, keys, "publicPath", mustBeString);
        let entryNames = getFlag(options, keys, "entryNames", mustBeString);
        let chunkNames = getFlag(options, keys, "chunkNames", mustBeString);
        let assetNames = getFlag(options, keys, "assetNames", mustBeString);
        let inject = getFlag(options, keys, "inject", mustBeArrayOfStrings);
        let banner = getFlag(options, keys, "banner", mustBeObject);
        let footer = getFlag(options, keys, "footer", mustBeObject);
        let entryPoints = getFlag(options, keys, "entryPoints", mustBeEntryPoints);
        let absWorkingDir = getFlag(options, keys, "absWorkingDir", mustBeString);
        let stdin = getFlag(options, keys, "stdin", mustBeObject);
        let write = (_a2 = getFlag(options, keys, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
        let allowOverwrite = getFlag(options, keys, "allowOverwrite", mustBeBoolean);
        let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
        keys.plugins = true;
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
        if (bundle) flags.push("--bundle");
        if (allowOverwrite) flags.push("--allow-overwrite");
        if (splitting) flags.push("--splitting");
        if (preserveSymlinks) flags.push("--preserve-symlinks");
        if (metafile) flags.push(`--metafile`);
        if (outfile) flags.push(`--outfile=${outfile}`);
        if (outdir) flags.push(`--outdir=${outdir}`);
        if (outbase) flags.push(`--outbase=${outbase}`);
        if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);
        if (packages) flags.push(`--packages=${packages}`);
        if (resolveExtensions) flags.push(`--resolve-extensions=${validateAndJoinStringArray(resolveExtensions, "resolve extension")}`);
        if (publicPath) flags.push(`--public-path=${publicPath}`);
        if (entryNames) flags.push(`--entry-names=${entryNames}`);
        if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);
        if (assetNames) flags.push(`--asset-names=${assetNames}`);
        if (mainFields) flags.push(`--main-fields=${validateAndJoinStringArray(mainFields, "main field")}`);
        if (conditions) flags.push(`--conditions=${validateAndJoinStringArray(conditions, "condition")}`);
        if (external) for (let name of external) flags.push(`--external:${validateStringValue(name, "external")}`);
        if (alias) {
          for (let old in alias) {
            if (old.indexOf("=") >= 0) throw new Error(`Invalid package name in alias: ${old}`);
            flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
          }
        }
        if (banner) {
          for (let type in banner) {
            if (type.indexOf("=") >= 0) throw new Error(`Invalid banner file type: ${type}`);
            flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
          }
        }
        if (footer) {
          for (let type in footer) {
            if (type.indexOf("=") >= 0) throw new Error(`Invalid footer file type: ${type}`);
            flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
          }
        }
        if (inject) for (let path of inject) flags.push(`--inject:${validateStringValue(path, "inject")}`);
        if (loader) {
          for (let ext in loader) {
            if (ext.indexOf("=") >= 0) throw new Error(`Invalid loader extension: ${ext}`);
            flags.push(`--loader:${ext}=${validateStringValue(loader[ext], "loader", ext)}`);
          }
        }
        if (outExtension) {
          for (let ext in outExtension) {
            if (ext.indexOf("=") >= 0) throw new Error(`Invalid out extension: ${ext}`);
            flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext], "out extension", ext)}`);
          }
        }
        if (entryPoints) {
          if (Array.isArray(entryPoints)) {
            for (let i = 0, n = entryPoints.length; i < n; i++) {
              let entryPoint = entryPoints[i];
              if (typeof entryPoint === "object" && entryPoint !== null) {
                let entryPointKeys = /* @__PURE__ */ Object.create(null);
                let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
                let output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
                checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
                if (input === void 0) throw new Error('Missing property "in" for entry point at index ' + i);
                if (output === void 0) throw new Error('Missing property "out" for entry point at index ' + i);
                entries.push([output, input]);
              } else {
                entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
              }
            }
          } else {
            for (let key in entryPoints) {
              entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
            }
          }
        }
        if (stdin) {
          let stdinKeys = /* @__PURE__ */ Object.create(null);
          let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
          let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
          let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
          let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
          checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
          if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
          if (loader2) flags.push(`--loader=${loader2}`);
          if (resolveDir) stdinResolveDir = resolveDir;
          if (typeof contents === "string") stdinContents = encodeUTF8(contents);
          else if (contents instanceof Uint8Array) stdinContents = contents;
        }
        let nodePaths = [];
        if (nodePathsInput) {
          for (let value2 of nodePathsInput) {
            value2 += "";
            nodePaths.push(value2);
          }
        }
        return {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          nodePaths,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      function flagsForTransformOptions(callName, options, isTTY, logLevelDefault) {
        let flags = [];
        let keys = /* @__PURE__ */ Object.create(null);
        pushLogFlags(flags, options, keys, isTTY, logLevelDefault);
        pushCommonFlags(flags, options, keys);
        let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
        let sourcefile = getFlag(options, keys, "sourcefile", mustBeString);
        let loader = getFlag(options, keys, "loader", mustBeString);
        let banner = getFlag(options, keys, "banner", mustBeString);
        let footer = getFlag(options, keys, "footer", mustBeString);
        let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
        checkForInvalidFlags(options, keys, `in ${callName}() call`);
        if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
        if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
        if (loader) flags.push(`--loader=${loader}`);
        if (banner) flags.push(`--banner=${banner}`);
        if (footer) flags.push(`--footer=${footer}`);
        return {
          flags,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      function createChannel(streamIn) {
        const requestCallbacksByKey = {};
        const closeData = { didClose: false, reason: "" };
        let responseCallbacks = {};
        let nextRequestID = 0;
        let nextBuildKey = 0;
        let stdout = new Uint8Array(16 * 1024);
        let stdoutUsed = 0;
        let readFromStdout = (chunk) => {
          let limit = stdoutUsed + chunk.length;
          if (limit > stdout.length) {
            let swap = new Uint8Array(limit * 2);
            swap.set(stdout);
            stdout = swap;
          }
          stdout.set(chunk, stdoutUsed);
          stdoutUsed += chunk.length;
          let offset = 0;
          while (offset + 4 <= stdoutUsed) {
            let length2 = readUInt32LE(stdout, offset);
            if (offset + 4 + length2 > stdoutUsed) {
              break;
            }
            offset += 4;
            handleIncomingPacket(stdout.subarray(offset, offset + length2));
            offset += length2;
          }
          if (offset > 0) {
            stdout.copyWithin(0, offset, stdoutUsed);
            stdoutUsed -= offset;
          }
        };
        let afterClose = (error) => {
          closeData.didClose = true;
          if (error) closeData.reason = ": " + (error.message || error);
          const text = "The service was stopped" + closeData.reason;
          for (let id in responseCallbacks) {
            responseCallbacks[id](text, null);
          }
          responseCallbacks = {};
        };
        let sendRequest = (refs, value2, callback) => {
          if (closeData.didClose) return callback("The service is no longer running" + closeData.reason, null);
          let id = nextRequestID++;
          responseCallbacks[id] = (error, response) => {
            try {
              callback(error, response);
            } finally {
              if (refs) refs.unref();
            }
          };
          if (refs) refs.ref();
          streamIn.writeToStdin(encodePacket({ id, isRequest: true, value: value2 }));
        };
        let sendResponse = (id, value2) => {
          if (closeData.didClose) throw new Error("The service is no longer running" + closeData.reason);
          streamIn.writeToStdin(encodePacket({ id, isRequest: false, value: value2 }));
        };
        let handleRequest = (id, request) => __async(null, null, function* () {
          try {
            if (request.command === "ping") {
              sendResponse(id, {});
              return;
            }
            if (typeof request.key === "number") {
              const requestCallbacks = requestCallbacksByKey[request.key];
              if (!requestCallbacks) {
                return;
              }
              const callback = requestCallbacks[request.command];
              if (callback) {
                yield callback(id, request);
                return;
              }
            }
            throw new Error(`Invalid command: ` + request.command);
          } catch (e) {
            const errors = [extractErrorMessageV8(e, streamIn, null, void 0, "")];
            try {
              sendResponse(id, { errors });
            } catch (e2) {
            }
          }
        });
        let isFirstPacket = true;
        let handleIncomingPacket = (bytes) => {
          if (isFirstPacket) {
            isFirstPacket = false;
            let binaryVersion = String.fromCharCode(...bytes);
            if (binaryVersion !== "0.25.11") {
              throw new Error(`Cannot start service: Host version "${"0.25.11"}" does not match binary version ${quote(binaryVersion)}`);
            }
            return;
          }
          let packet = decodePacket(bytes);
          if (packet.isRequest) {
            handleRequest(packet.id, packet.value);
          } else {
            let callback = responseCallbacks[packet.id];
            delete responseCallbacks[packet.id];
            if (packet.value.error) callback(packet.value.error, {});
            else callback(null, packet.value);
          }
        };
        let buildOrContext = ({ callName, refs, options, isTTY, defaultWD, callback }) => {
          let refCount = 0;
          const buildKey = nextBuildKey++;
          const requestCallbacks = {};
          const buildRefs = {
            ref() {
              if (++refCount === 1) {
                if (refs) refs.ref();
              }
            },
            unref() {
              if (--refCount === 0) {
                delete requestCallbacksByKey[buildKey];
                if (refs) refs.unref();
              }
            }
          };
          requestCallbacksByKey[buildKey] = requestCallbacks;
          buildRefs.ref();
          buildOrContextImpl(
            callName,
            buildKey,
            sendRequest,
            sendResponse,
            buildRefs,
            streamIn,
            requestCallbacks,
            options,
            isTTY,
            defaultWD,
            (err2, res) => {
              try {
                callback(err2, res);
              } finally {
                buildRefs.unref();
              }
            }
          );
        };
        let transform2 = ({ callName, refs, input, options, isTTY, fs, callback }) => {
          const details = createObjectStash();
          let start = (inputPath) => {
            try {
              if (typeof input !== "string" && !(input instanceof Uint8Array))
                throw new Error('The input to "transform" must be a string or a Uint8Array');
              let {
                flags,
                mangleCache
              } = flagsForTransformOptions(callName, options, isTTY, transformLogLevelDefault);
              let request = {
                command: "transform",
                flags,
                inputFS: inputPath !== null,
                input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
              };
              if (mangleCache) request.mangleCache = mangleCache;
              sendRequest(refs, request, (error, response) => {
                if (error) return callback(new Error(error), null);
                let errors = replaceDetailsInMessages(response.errors, details);
                let warnings = replaceDetailsInMessages(response.warnings, details);
                let outstanding = 1;
                let next = () => {
                  if (--outstanding === 0) {
                    let result = {
                      warnings,
                      code: response.code,
                      map: response.map,
                      mangleCache: void 0,
                      legalComments: void 0
                    };
                    if ("legalComments" in response) result.legalComments = response == null ? void 0 : response.legalComments;
                    if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;
                    callback(null, result);
                  }
                };
                if (errors.length > 0) return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
                if (response.codeFS) {
                  outstanding++;
                  fs.readFile(response.code, (err2, contents) => {
                    if (err2 !== null) {
                      callback(err2, null);
                    } else {
                      response.code = contents;
                      next();
                    }
                  });
                }
                if (response.mapFS) {
                  outstanding++;
                  fs.readFile(response.map, (err2, contents) => {
                    if (err2 !== null) {
                      callback(err2, null);
                    } else {
                      response.map = contents;
                      next();
                    }
                  });
                }
                next();
              });
            } catch (e) {
              let flags = [];
              try {
                pushLogFlags(flags, options, {}, isTTY, transformLogLevelDefault);
              } catch (e2) {
              }
              const error = extractErrorMessageV8(e, streamIn, details, void 0, "");
              sendRequest(refs, { command: "error", flags, error }, () => {
                error.detail = details.load(error.detail);
                callback(failureErrorWithLog("Transform failed", [error], []), null);
              });
            }
          };
          if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
            let next = start;
            start = () => fs.writeFile(input, next);
          }
          start(null);
        };
        let formatMessages2 = ({ callName, refs, messages, options, callback }) => {
          if (!options) throw new Error(`Missing second argument in ${callName}() call`);
          let keys = {};
          let kind = getFlag(options, keys, "kind", mustBeString);
          let color = getFlag(options, keys, "color", mustBeBoolean);
          let terminalWidth = getFlag(options, keys, "terminalWidth", mustBeInteger);
          checkForInvalidFlags(options, keys, `in ${callName}() call`);
          if (kind === void 0) throw new Error(`Missing "kind" in ${callName}() call`);
          if (kind !== "error" && kind !== "warning") throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
          let request = {
            command: "format-msgs",
            messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
            isWarning: kind === "warning"
          };
          if (color !== void 0) request.color = color;
          if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;
          sendRequest(refs, request, (error, response) => {
            if (error) return callback(new Error(error), null);
            callback(null, response.messages);
          });
        };
        let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {
          if (options === void 0) options = {};
          let keys = {};
          let color = getFlag(options, keys, "color", mustBeBoolean);
          let verbose = getFlag(options, keys, "verbose", mustBeBoolean);
          checkForInvalidFlags(options, keys, `in ${callName}() call`);
          let request = {
            command: "analyze-metafile",
            metafile
          };
          if (color !== void 0) request.color = color;
          if (verbose !== void 0) request.verbose = verbose;
          sendRequest(refs, request, (error, response) => {
            if (error) return callback(new Error(error), null);
            callback(null, response.result);
          });
        };
        return {
          readFromStdout,
          afterClose,
          service: {
            buildOrContext,
            transform: transform2,
            formatMessages: formatMessages2,
            analyzeMetafile: analyzeMetafile2
          }
        };
      }
      function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY, defaultWD, callback) {
        const details = createObjectStash();
        const isContext = callName === "context";
        const handleError = (e, pluginName) => {
          const flags = [];
          try {
            pushLogFlags(flags, options, {}, isTTY, buildLogLevelDefault);
          } catch (e2) {
          }
          const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
          sendRequest(refs, { command: "error", flags, error: message }, () => {
            message.detail = details.load(message.detail);
            callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
          });
        };
        let plugins;
        if (typeof options === "object") {
          const value2 = options.plugins;
          if (value2 !== void 0) {
            if (!Array.isArray(value2)) return handleError(new Error(`"plugins" must be an array`), "");
            plugins = value2;
          }
        }
        if (plugins && plugins.length > 0) {
          if (streamIn.isSync) return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
          handlePlugins(
            buildKey,
            sendRequest,
            sendResponse,
            refs,
            streamIn,
            requestCallbacks,
            options,
            plugins,
            details
          ).then(
            (result) => {
              if (!result.ok) return handleError(result.error, result.pluginName);
              try {
                buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
              } catch (e) {
                handleError(e, "");
              }
            },
            (e) => handleError(e, "")
          );
          return;
        }
        try {
          buildOrContextContinue(null, (result, done) => done([], []), () => {
          });
        } catch (e) {
          handleError(e, "");
        }
        function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
          const writeDefault = streamIn.hasFS;
          const {
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir,
            nodePaths,
            mangleCache
          } = flagsForBuildOptions(callName, options, isTTY, buildLogLevelDefault, writeDefault);
          if (write && !streamIn.hasFS) throw new Error(`The "write" option is unavailable in this environment`);
          const request = {
            command: "build",
            key: buildKey,
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir: absWorkingDir || defaultWD,
            nodePaths,
            context: isContext
          };
          if (requestPlugins) request.plugins = requestPlugins;
          if (mangleCache) request.mangleCache = mangleCache;
          const buildResponseToResult = (response, callback2) => {
            const result = {
              errors: replaceDetailsInMessages(response.errors, details),
              warnings: replaceDetailsInMessages(response.warnings, details),
              outputFiles: void 0,
              metafile: void 0,
              mangleCache: void 0
            };
            const originalErrors = result.errors.slice();
            const originalWarnings = result.warnings.slice();
            if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);
            if (response.metafile) result.metafile = JSON.parse(response.metafile);
            if (response.mangleCache) result.mangleCache = response.mangleCache;
            if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
            runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
              if (originalErrors.length > 0 || onEndErrors.length > 0) {
                const error = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
                return callback2(error, null, onEndErrors, onEndWarnings);
              }
              callback2(null, result, onEndErrors, onEndWarnings);
            });
          };
          let latestResultPromise;
          let provideLatestResult;
          if (isContext)
            requestCallbacks["on-end"] = (id, request2) => new Promise((resolve) => {
              buildResponseToResult(request2, (err2, result, onEndErrors, onEndWarnings) => {
                const response = {
                  errors: onEndErrors,
                  warnings: onEndWarnings
                };
                if (provideLatestResult) provideLatestResult(err2, result);
                latestResultPromise = void 0;
                provideLatestResult = void 0;
                sendResponse(id, response);
                resolve();
              });
            });
          sendRequest(refs, request, (error, response) => {
            if (error) return callback(new Error(error), null);
            if (!isContext) {
              return buildResponseToResult(response, (err2, res) => {
                scheduleOnDisposeCallbacks();
                return callback(err2, res);
              });
            }
            if (response.errors.length > 0) {
              return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
            }
            let didDispose = false;
            const result = {
              rebuild: () => {
                if (!latestResultPromise) latestResultPromise = new Promise((resolve, reject) => {
                  let settlePromise;
                  provideLatestResult = (err2, result2) => {
                    if (!settlePromise) settlePromise = () => err2 ? reject(err2) : resolve(result2);
                  };
                  const triggerAnotherBuild = () => {
                    const request2 = {
                      command: "rebuild",
                      key: buildKey
                    };
                    sendRequest(refs, request2, (error2, response2) => {
                      if (error2) {
                        reject(new Error(error2));
                      } else if (settlePromise) {
                        settlePromise();
                      } else {
                        triggerAnotherBuild();
                      }
                    });
                  };
                  triggerAnotherBuild();
                });
                return latestResultPromise;
              },
              watch: (options2 = {}) => new Promise((resolve, reject) => {
                if (!streamIn.hasFS) throw new Error(`Cannot use the "watch" API in this environment`);
                const keys = {};
                const delay = getFlag(options2, keys, "delay", mustBeInteger);
                checkForInvalidFlags(options2, keys, `in watch() call`);
                const request2 = {
                  command: "watch",
                  key: buildKey
                };
                if (delay) request2.delay = delay;
                sendRequest(refs, request2, (error2) => {
                  if (error2) reject(new Error(error2));
                  else resolve(void 0);
                });
              }),
              serve: (options2 = {}) => new Promise((resolve, reject) => {
                if (!streamIn.hasFS) throw new Error(`Cannot use the "serve" API in this environment`);
                const keys = {};
                const port = getFlag(options2, keys, "port", mustBeValidPortNumber);
                const host = getFlag(options2, keys, "host", mustBeString);
                const servedir = getFlag(options2, keys, "servedir", mustBeString);
                const keyfile = getFlag(options2, keys, "keyfile", mustBeString);
                const certfile = getFlag(options2, keys, "certfile", mustBeString);
                const fallback = getFlag(options2, keys, "fallback", mustBeString);
                const cors = getFlag(options2, keys, "cors", mustBeObject);
                const onRequest = getFlag(options2, keys, "onRequest", mustBeFunction);
                checkForInvalidFlags(options2, keys, `in serve() call`);
                const request2 = {
                  command: "serve",
                  key: buildKey,
                  onRequest: !!onRequest
                };
                if (port !== void 0) request2.port = port;
                if (host !== void 0) request2.host = host;
                if (servedir !== void 0) request2.servedir = servedir;
                if (keyfile !== void 0) request2.keyfile = keyfile;
                if (certfile !== void 0) request2.certfile = certfile;
                if (fallback !== void 0) request2.fallback = fallback;
                if (cors) {
                  const corsKeys = {};
                  const origin = getFlag(cors, corsKeys, "origin", mustBeStringOrArrayOfStrings);
                  checkForInvalidFlags(cors, corsKeys, `on "cors" object`);
                  if (Array.isArray(origin)) request2.corsOrigin = origin;
                  else if (origin !== void 0) request2.corsOrigin = [origin];
                }
                sendRequest(refs, request2, (error2, response2) => {
                  if (error2) return reject(new Error(error2));
                  if (onRequest) {
                    requestCallbacks["serve-request"] = (id, request3) => {
                      onRequest(request3.args);
                      sendResponse(id, {});
                    };
                  }
                  resolve(response2);
                });
              }),
              cancel: () => new Promise((resolve) => {
                if (didDispose) return resolve();
                const request2 = {
                  command: "cancel",
                  key: buildKey
                };
                sendRequest(refs, request2, () => {
                  resolve();
                });
              }),
              dispose: () => new Promise((resolve) => {
                if (didDispose) return resolve();
                didDispose = true;
                const request2 = {
                  command: "dispose",
                  key: buildKey
                };
                sendRequest(refs, request2, () => {
                  resolve();
                  scheduleOnDisposeCallbacks();
                  refs.unref();
                });
              })
            };
            refs.ref();
            callback(null, result);
          });
        }
      }
      var handlePlugins = (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => __async(null, null, function* () {
        let onStartCallbacks = [];
        let onEndCallbacks = [];
        let onResolveCallbacks = {};
        let onLoadCallbacks = {};
        let onDisposeCallbacks = [];
        let nextCallbackID = 0;
        let i = 0;
        let requestPlugins = [];
        let isSetupDone = false;
        plugins = [...plugins];
        for (let item of plugins) {
          let keys = {};
          if (typeof item !== "object") throw new Error(`Plugin at index ${i} must be an object`);
          const name = getFlag(item, keys, "name", mustBeString);
          if (typeof name !== "string" || name === "") throw new Error(`Plugin at index ${i} is missing a name`);
          try {
            let setup = getFlag(item, keys, "setup", mustBeFunction);
            if (typeof setup !== "function") throw new Error(`Plugin is missing a setup function`);
            checkForInvalidFlags(item, keys, `on plugin ${quote(name)}`);
            let plugin = {
              name,
              onStart: false,
              onEnd: false,
              onResolve: [],
              onLoad: []
            };
            i++;
            let resolve = (path, options = {}) => {
              if (!isSetupDone) throw new Error('Cannot call "resolve" before plugin setup has completed');
              if (typeof path !== "string") throw new Error(`The path to resolve must be a string`);
              let keys2 = /* @__PURE__ */ Object.create(null);
              let pluginName = getFlag(options, keys2, "pluginName", mustBeString);
              let importer = getFlag(options, keys2, "importer", mustBeString);
              let namespace = getFlag(options, keys2, "namespace", mustBeString);
              let resolveDir = getFlag(options, keys2, "resolveDir", mustBeString);
              let kind = getFlag(options, keys2, "kind", mustBeString);
              let pluginData = getFlag(options, keys2, "pluginData", canBeAnything);
              let importAttributes = getFlag(options, keys2, "with", mustBeObject);
              checkForInvalidFlags(options, keys2, "in resolve() call");
              return new Promise((resolve2, reject) => {
                const request = {
                  command: "resolve",
                  path,
                  key: buildKey,
                  pluginName: name
                };
                if (pluginName != null) request.pluginName = pluginName;
                if (importer != null) request.importer = importer;
                if (namespace != null) request.namespace = namespace;
                if (resolveDir != null) request.resolveDir = resolveDir;
                if (kind != null) request.kind = kind;
                else throw new Error(`Must specify "kind" when calling "resolve"`);
                if (pluginData != null) request.pluginData = details.store(pluginData);
                if (importAttributes != null) request.with = sanitizeStringMap(importAttributes, "with");
                sendRequest(refs, request, (error, response) => {
                  if (error !== null) reject(new Error(error));
                  else resolve2({
                    errors: replaceDetailsInMessages(response.errors, details),
                    warnings: replaceDetailsInMessages(response.warnings, details),
                    path: response.path,
                    external: response.external,
                    sideEffects: response.sideEffects,
                    namespace: response.namespace,
                    suffix: response.suffix,
                    pluginData: details.load(response.pluginData)
                  });
                });
              });
            };
            let promise = setup({
              initialOptions,
              resolve,
              onStart(callback) {
                let registeredText = `This error came from the "onStart" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
                onStartCallbacks.push({ name, callback, note: registeredNote });
                plugin.onStart = true;
              },
              onEnd(callback) {
                let registeredText = `This error came from the "onEnd" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
                onEndCallbacks.push({ name, callback, note: registeredNote });
                plugin.onEnd = true;
              },
              onResolve(options, callback) {
                let registeredText = `This error came from the "onResolve" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
                let keys2 = {};
                let filter = getFlag(options, keys2, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys2, "namespace", mustBeString);
                checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${quote(name)}`);
                if (filter == null) throw new Error(`onResolve() call is missing a filter`);
                let id = nextCallbackID++;
                onResolveCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onResolve.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
              },
              onLoad(options, callback) {
                let registeredText = `This error came from the "onLoad" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
                let keys2 = {};
                let filter = getFlag(options, keys2, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys2, "namespace", mustBeString);
                checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${quote(name)}`);
                if (filter == null) throw new Error(`onLoad() call is missing a filter`);
                let id = nextCallbackID++;
                onLoadCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onLoad.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
              },
              onDispose(callback) {
                onDisposeCallbacks.push(callback);
              },
              esbuild: streamIn.esbuild
            });
            if (promise) yield promise;
            requestPlugins.push(plugin);
          } catch (e) {
            return { ok: false, error: e, pluginName: name };
          }
        }
        requestCallbacks["on-start"] = (id, request) => __async(null, null, function* () {
          details.clear();
          let response = { errors: [], warnings: [] };
          yield Promise.all(onStartCallbacks.map((_0) => __async(null, [_0], function* ({ name, callback, note }) {
            try {
              let result = yield callback();
              if (result != null) {
                if (typeof result !== "object") throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
                let keys = {};
                let errors = getFlag(result, keys, "errors", mustBeArray);
                let warnings = getFlag(result, keys, "warnings", mustBeArray);
                checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${quote(name)}`);
                if (errors != null) response.errors.push(...sanitizeMessages(errors, "errors", details, name, void 0));
                if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name, void 0));
              }
            } catch (e) {
              response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
            }
          })));
          sendResponse(id, response);
        });
        requestCallbacks["on-resolve"] = (id, request) => __async(null, null, function* () {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onResolveCallbacks[id2]);
              let result = yield callback({
                path: request.path,
                importer: request.importer,
                namespace: request.namespace,
                resolveDir: request.resolveDir,
                kind: request.kind,
                pluginData: details.load(request.pluginData),
                with: request.with
              });
              if (result != null) {
                if (typeof result !== "object") throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
                let keys = {};
                let pluginName = getFlag(result, keys, "pluginName", mustBeString);
                let path = getFlag(result, keys, "path", mustBeString);
                let namespace = getFlag(result, keys, "namespace", mustBeString);
                let suffix = getFlag(result, keys, "suffix", mustBeString);
                let external = getFlag(result, keys, "external", mustBeBoolean);
                let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
                let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
                let errors = getFlag(result, keys, "errors", mustBeArray);
                let warnings = getFlag(result, keys, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
                let watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
                checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${quote(name)}`);
                response.id = id2;
                if (pluginName != null) response.pluginName = pluginName;
                if (path != null) response.path = path;
                if (namespace != null) response.namespace = namespace;
                if (suffix != null) response.suffix = suffix;
                if (external != null) response.external = external;
                if (sideEffects != null) response.sideEffects = sideEffects;
                if (pluginData != null) response.pluginData = details.store(pluginData);
                if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
                if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e) {
              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        });
        requestCallbacks["on-load"] = (id, request) => __async(null, null, function* () {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onLoadCallbacks[id2]);
              let result = yield callback({
                path: request.path,
                namespace: request.namespace,
                suffix: request.suffix,
                pluginData: details.load(request.pluginData),
                with: request.with
              });
              if (result != null) {
                if (typeof result !== "object") throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
                let keys = {};
                let pluginName = getFlag(result, keys, "pluginName", mustBeString);
                let contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
                let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
                let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
                let loader = getFlag(result, keys, "loader", mustBeString);
                let errors = getFlag(result, keys, "errors", mustBeArray);
                let warnings = getFlag(result, keys, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
                let watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
                checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${quote(name)}`);
                response.id = id2;
                if (pluginName != null) response.pluginName = pluginName;
                if (contents instanceof Uint8Array) response.contents = contents;
                else if (contents != null) response.contents = encodeUTF8(contents);
                if (resolveDir != null) response.resolveDir = resolveDir;
                if (pluginData != null) response.pluginData = details.store(pluginData);
                if (loader != null) response.loader = loader;
                if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
                if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e) {
              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        });
        let runOnEndCallbacks = (result, done) => done([], []);
        if (onEndCallbacks.length > 0) {
          runOnEndCallbacks = (result, done) => {
            (() => __async(null, null, function* () {
              const onEndErrors = [];
              const onEndWarnings = [];
              for (const { name, callback, note } of onEndCallbacks) {
                let newErrors;
                let newWarnings;
                try {
                  const value2 = yield callback(result);
                  if (value2 != null) {
                    if (typeof value2 !== "object") throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
                    let keys = {};
                    let errors = getFlag(value2, keys, "errors", mustBeArray);
                    let warnings = getFlag(value2, keys, "warnings", mustBeArray);
                    checkForInvalidFlags(value2, keys, `from onEnd() callback in plugin ${quote(name)}`);
                    if (errors != null) newErrors = sanitizeMessages(errors, "errors", details, name, void 0);
                    if (warnings != null) newWarnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
                  }
                } catch (e) {
                  newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name)];
                }
                if (newErrors) {
                  onEndErrors.push(...newErrors);
                  try {
                    result.errors.push(...newErrors);
                  } catch (e) {
                  }
                }
                if (newWarnings) {
                  onEndWarnings.push(...newWarnings);
                  try {
                    result.warnings.push(...newWarnings);
                  } catch (e) {
                  }
                }
              }
              done(onEndErrors, onEndWarnings);
            }))();
          };
        }
        let scheduleOnDisposeCallbacks = () => {
          for (const cb of onDisposeCallbacks) {
            setTimeout(() => cb(), 0);
          }
        };
        isSetupDone = true;
        return {
          ok: true,
          requestPlugins,
          runOnEndCallbacks,
          scheduleOnDisposeCallbacks
        };
      });
      function createObjectStash() {
        const map = /* @__PURE__ */ new Map();
        let nextID = 0;
        return {
          clear() {
            map.clear();
          },
          load(id) {
            return map.get(id);
          },
          store(value2) {
            if (value2 === void 0) return -1;
            const id = nextID++;
            map.set(id, value2);
            return id;
          }
        };
      }
      function extractCallerV8(e, streamIn, ident) {
        let note;
        let tried = false;
        return () => {
          if (tried) return note;
          tried = true;
          try {
            let lines = (e.stack + "").split("\n");
            lines.splice(1, 1);
            let location2 = parseStackLinesV8(streamIn, lines, ident);
            if (location2) {
              note = { text: e.message, location: location2 };
              return note;
            }
          } catch (e2) {
          }
        };
      }
      function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
        let text = "Internal error";
        let location2 = null;
        try {
          text = (e && e.message || e) + "";
        } catch (e2) {
        }
        try {
          location2 = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
        } catch (e2) {
        }
        return { id: "", pluginName, text, location: location2, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
      }
      function parseStackLinesV8(streamIn, lines, ident) {
        let at = "    at ";
        if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
          for (let i = 1; i < lines.length; i++) {
            let line = lines[i];
            if (!line.startsWith(at)) continue;
            line = line.slice(at.length);
            while (true) {
              let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
              if (match) {
                line = match[1];
                continue;
              }
              match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
              if (match) {
                line = match[1];
                continue;
              }
              match = /^(\S+):(\d+):(\d+)$/.exec(line);
              if (match) {
                let contents;
                try {
                  contents = streamIn.readFileSync(match[1], "utf8");
                } catch (e) {
                  break;
                }
                let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
                let column = +match[3] - 1;
                let length2 = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
                return {
                  file: match[1],
                  namespace: "file",
                  line: +match[2],
                  column: encodeUTF8(lineText.slice(0, column)).length,
                  length: encodeUTF8(lineText.slice(column, column + length2)).length,
                  lineText: lineText + "\n" + lines.slice(1).join("\n"),
                  suggestion: ""
                };
              }
              break;
            }
          }
        }
        return null;
      }
      function failureErrorWithLog(text, errors, warnings) {
        let limit = 5;
        text += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
          if (i === limit) return "\n...";
          if (!e.location) return `
error: ${e.text}`;
          let { file, line, column } = e.location;
          let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
          return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
        }).join("");
        let error = new Error(text);
        for (const [key, value2] of [["errors", errors], ["warnings", warnings]]) {
          Object.defineProperty(error, key, {
            configurable: true,
            enumerable: true,
            get: () => value2,
            set: (value22) => Object.defineProperty(error, key, {
              configurable: true,
              enumerable: true,
              value: value22
            })
          });
        }
        return error;
      }
      function replaceDetailsInMessages(messages, stash) {
        for (const message of messages) {
          message.detail = stash.load(message.detail);
        }
        return messages;
      }
      function sanitizeLocation(location2, where, terminalWidth) {
        if (location2 == null) return null;
        let keys = {};
        let file = getFlag(location2, keys, "file", mustBeString);
        let namespace = getFlag(location2, keys, "namespace", mustBeString);
        let line = getFlag(location2, keys, "line", mustBeInteger);
        let column = getFlag(location2, keys, "column", mustBeInteger);
        let length2 = getFlag(location2, keys, "length", mustBeInteger);
        let lineText = getFlag(location2, keys, "lineText", mustBeString);
        let suggestion = getFlag(location2, keys, "suggestion", mustBeString);
        checkForInvalidFlags(location2, keys, where);
        if (lineText) {
          const relevantASCII = lineText.slice(
            0,
            (column && column > 0 ? column : 0) + (length2 && length2 > 0 ? length2 : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80)
          );
          if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
            lineText = relevantASCII;
          }
        }
        return {
          file: file || "",
          namespace: namespace || "",
          line: line || 0,
          column: column || 0,
          length: length2 || 0,
          lineText: lineText || "",
          suggestion: suggestion || ""
        };
      }
      function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {
        let messagesClone = [];
        let index = 0;
        for (const message of messages) {
          let keys = {};
          let id = getFlag(message, keys, "id", mustBeString);
          let pluginName = getFlag(message, keys, "pluginName", mustBeString);
          let text = getFlag(message, keys, "text", mustBeString);
          let location2 = getFlag(message, keys, "location", mustBeObjectOrNull);
          let notes = getFlag(message, keys, "notes", mustBeArray);
          let detail = getFlag(message, keys, "detail", canBeAnything);
          let where = `in element ${index} of "${property}"`;
          checkForInvalidFlags(message, keys, where);
          let notesClone = [];
          if (notes) {
            for (const note of notes) {
              let noteKeys = {};
              let noteText = getFlag(note, noteKeys, "text", mustBeString);
              let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
              checkForInvalidFlags(note, noteKeys, where);
              notesClone.push({
                text: noteText || "",
                location: sanitizeLocation(noteLocation, where, terminalWidth)
              });
            }
          }
          messagesClone.push({
            id: id || "",
            pluginName: pluginName || fallbackPluginName,
            text: text || "",
            location: sanitizeLocation(location2, where, terminalWidth),
            notes: notesClone,
            detail: stash ? stash.store(detail) : -1
          });
          index++;
        }
        return messagesClone;
      }
      function sanitizeStringArray(values, property) {
        const result = [];
        for (const value2 of values) {
          if (typeof value2 !== "string") throw new Error(`${quote(property)} must be an array of strings`);
          result.push(value2);
        }
        return result;
      }
      function sanitizeStringMap(map, property) {
        const result = /* @__PURE__ */ Object.create(null);
        for (const key in map) {
          const value2 = map[key];
          if (typeof value2 !== "string") throw new Error(`key ${quote(key)} in object ${quote(property)} must be a string`);
          result[key] = value2;
        }
        return result;
      }
      function convertOutputFiles({ path, contents, hash }) {
        let text = null;
        return {
          path,
          contents,
          hash,
          get text() {
            const binary = this.contents;
            if (text === null || binary !== contents) {
              contents = binary;
              text = decodeUTF8(binary);
            }
            return text;
          }
        };
      }
      function jsRegExpToGoRegExp(regexp) {
        let result = regexp.source;
        if (regexp.flags) result = `(?${regexp.flags})${result}`;
        return result;
      }
      var version = "0.25.11";
      var build2 = (options) => ensureServiceIsRunning().build(options);
      var context = (options) => ensureServiceIsRunning().context(options);
      var transform = (input, options) => ensureServiceIsRunning().transform(input, options);
      var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);
      var analyzeMetafile = (metafile, options) => ensureServiceIsRunning().analyzeMetafile(metafile, options);
      var buildSync = () => {
        throw new Error(`The "buildSync" API only works in node`);
      };
      var transformSync = () => {
        throw new Error(`The "transformSync" API only works in node`);
      };
      var formatMessagesSync = () => {
        throw new Error(`The "formatMessagesSync" API only works in node`);
      };
      var analyzeMetafileSync = () => {
        throw new Error(`The "analyzeMetafileSync" API only works in node`);
      };
      var stop = () => {
        if (stopService) stopService();
        return Promise.resolve();
      };
      var initializePromise;
      var stopService;
      var longLivedService;
      var ensureServiceIsRunning = () => {
        if (longLivedService) return longLivedService;
        if (initializePromise) throw new Error('You need to wait for the promise returned from "initialize" to be resolved before calling this');
        throw new Error('You need to call "initialize" before calling this');
      };
      var initialize2 = (options) => {
        options = validateInitializeOptions(options || {});
        let wasmURL = options.wasmURL;
        let wasmModule = options.wasmModule;
        let useWorker = options.worker !== false;
        if (!wasmURL && !wasmModule) throw new Error('Must provide either the "wasmURL" option or the "wasmModule" option');
        if (initializePromise) throw new Error('Cannot call "initialize" more than once');
        initializePromise = startRunningService(wasmURL || "", wasmModule, useWorker);
        initializePromise.catch(() => {
          initializePromise = void 0;
        });
        return initializePromise;
      };
      var startRunningService = (wasmURL, wasmModule, useWorker) => __async(null, null, function* () {
        let worker;
        let rejectAllWith;
        const rejectAllPromise = new Promise((resolve) => rejectAllWith = resolve);
        if (useWorker) {
          let blob = new Blob([`onmessage=${'((postMessage) => {\n      // Copyright 2018 The Go Authors. All rights reserved.\n      // Use of this source code is governed by a BSD-style\n      // license that can be found in the LICENSE file.\n      var __async = (__this, __arguments, generator) => {\n        return new Promise((resolve, reject) => {\n          var fulfilled = (value) => {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var rejected = (value) => {\n            try {\n              step(generator.throw(value));\n            } catch (e) {\n              reject(e);\n            }\n          };\n          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n          step((generator = generator.apply(__this, __arguments)).next());\n        });\n      };\n      let onmessage;\n      let globalThis = {};\n      for (let o = self; o; o = Object.getPrototypeOf(o))\n        for (let k of Object.getOwnPropertyNames(o))\n          if (!(k in globalThis))\n            Object.defineProperty(globalThis, k, { get: () => self[k] });\n      "use strict";\n      (() => {\n        const enosys = () => {\n          const err = new Error("not implemented");\n          err.code = "ENOSYS";\n          return err;\n        };\n        if (!globalThis.fs) {\n          let outputBuf = "";\n          globalThis.fs = {\n            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },\n            // unused\n            writeSync(fd, buf) {\n              outputBuf += decoder.decode(buf);\n              const nl = outputBuf.lastIndexOf("\\n");\n              if (nl != -1) {\n                console.log(outputBuf.substring(0, nl));\n                outputBuf = outputBuf.substring(nl + 1);\n              }\n              return buf.length;\n            },\n            write(fd, buf, offset, length, position, callback) {\n              if (offset !== 0 || length !== buf.length || position !== null) {\n                callback(enosys());\n                return;\n              }\n              const n = this.writeSync(fd, buf);\n              callback(null, n);\n            },\n            chmod(path, mode, callback) {\n              callback(enosys());\n            },\n            chown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            close(fd, callback) {\n              callback(enosys());\n            },\n            fchmod(fd, mode, callback) {\n              callback(enosys());\n            },\n            fchown(fd, uid, gid, callback) {\n              callback(enosys());\n            },\n            fstat(fd, callback) {\n              callback(enosys());\n            },\n            fsync(fd, callback) {\n              callback(null);\n            },\n            ftruncate(fd, length, callback) {\n              callback(enosys());\n            },\n            lchown(path, uid, gid, callback) {\n              callback(enosys());\n            },\n            link(path, link, callback) {\n              callback(enosys());\n            },\n            lstat(path, callback) {\n              callback(enosys());\n            },\n            mkdir(path, perm, callback) {\n              callback(enosys());\n            },\n            open(path, flags, mode, callback) {\n              callback(enosys());\n            },\n            read(fd, buffer, offset, length, position, callback) {\n              callback(enosys());\n            },\n            readdir(path, callback) {\n              callback(enosys());\n            },\n            readlink(path, callback) {\n              callback(enosys());\n            },\n            rename(from, to, callback) {\n              callback(enosys());\n            },\n            rmdir(path, callback) {\n              callback(enosys());\n            },\n            stat(path, callback) {\n              callback(enosys());\n            },\n            symlink(path, link, callback) {\n              callback(enosys());\n            },\n            truncate(path, length, callback) {\n              callback(enosys());\n            },\n            unlink(path, callback) {\n              callback(enosys());\n            },\n            utimes(path, atime, mtime, callback) {\n              callback(enosys());\n            }\n          };\n        }\n        if (!globalThis.process) {\n          globalThis.process = {\n            getuid() {\n              return -1;\n            },\n            getgid() {\n              return -1;\n            },\n            geteuid() {\n              return -1;\n            },\n            getegid() {\n              return -1;\n            },\n            getgroups() {\n              throw enosys();\n            },\n            pid: -1,\n            ppid: -1,\n            umask() {\n              throw enosys();\n            },\n            cwd() {\n              throw enosys();\n            },\n            chdir() {\n              throw enosys();\n            }\n          };\n        }\n        if (!globalThis.crypto) {\n          throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");\n        }\n        if (!globalThis.performance) {\n          throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");\n        }\n        if (!globalThis.TextEncoder) {\n          throw new Error("globalThis.TextEncoder is not available, polyfill required");\n        }\n        if (!globalThis.TextDecoder) {\n          throw new Error("globalThis.TextDecoder is not available, polyfill required");\n        }\n        const encoder = new TextEncoder("utf-8");\n        const decoder = new TextDecoder("utf-8");\n        globalThis.Go = class {\n          constructor() {\n            this.argv = ["js"];\n            this.env = {};\n            this.exit = (code) => {\n              if (code !== 0) {\n                console.warn("exit code:", code);\n              }\n            };\n            this._exitPromise = new Promise((resolve) => {\n              this._resolveExitPromise = resolve;\n            });\n            this._pendingEvent = null;\n            this._scheduledTimeouts = /* @__PURE__ */ new Map();\n            this._nextCallbackTimeoutID = 1;\n            const setInt64 = (addr, v) => {\n              this.mem.setUint32(addr + 0, v, true);\n              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);\n            };\n            const setInt32 = (addr, v) => {\n              this.mem.setUint32(addr + 0, v, true);\n            };\n            const getInt64 = (addr) => {\n              const low = this.mem.getUint32(addr + 0, true);\n              const high = this.mem.getInt32(addr + 4, true);\n              return low + high * 4294967296;\n            };\n            const loadValue = (addr) => {\n              const f = this.mem.getFloat64(addr, true);\n              if (f === 0) {\n                return void 0;\n              }\n              if (!isNaN(f)) {\n                return f;\n              }\n              const id = this.mem.getUint32(addr, true);\n              return this._values[id];\n            };\n            const storeValue = (addr, v) => {\n              const nanHead = 2146959360;\n              if (typeof v === "number" && v !== 0) {\n                if (isNaN(v)) {\n                  this.mem.setUint32(addr + 4, nanHead, true);\n                  this.mem.setUint32(addr, 0, true);\n                  return;\n                }\n                this.mem.setFloat64(addr, v, true);\n                return;\n              }\n              if (v === void 0) {\n                this.mem.setFloat64(addr, 0, true);\n                return;\n              }\n              let id = this._ids.get(v);\n              if (id === void 0) {\n                id = this._idPool.pop();\n                if (id === void 0) {\n                  id = this._values.length;\n                }\n                this._values[id] = v;\n                this._goRefCounts[id] = 0;\n                this._ids.set(v, id);\n              }\n              this._goRefCounts[id]++;\n              let typeFlag = 0;\n              switch (typeof v) {\n                case "object":\n                  if (v !== null) {\n                    typeFlag = 1;\n                  }\n                  break;\n                case "string":\n                  typeFlag = 2;\n                  break;\n                case "symbol":\n                  typeFlag = 3;\n                  break;\n                case "function":\n                  typeFlag = 4;\n                  break;\n              }\n              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);\n              this.mem.setUint32(addr, id, true);\n            };\n            const loadSlice = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return new Uint8Array(this._inst.exports.mem.buffer, array, len);\n            };\n            const loadSliceOfValues = (addr) => {\n              const array = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              const a = new Array(len);\n              for (let i = 0; i < len; i++) {\n                a[i] = loadValue(array + i * 8);\n              }\n              return a;\n            };\n            const loadString = (addr) => {\n              const saddr = getInt64(addr + 0);\n              const len = getInt64(addr + 8);\n              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));\n            };\n            const timeOrigin = Date.now() - performance.now();\n            this.importObject = {\n              _gotest: {\n                add: (a, b) => a + b\n              },\n              gojs: {\n                // Go\'s SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)\n                // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported\n                // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).\n                // This changes the SP, thus we have to update the SP used by the imported function.\n                // func wasmExit(code int32)\n                "runtime.wasmExit": (sp) => {\n                  sp >>>= 0;\n                  const code = this.mem.getInt32(sp + 8, true);\n                  this.exited = true;\n                  delete this._inst;\n                  delete this._values;\n                  delete this._goRefCounts;\n                  delete this._ids;\n                  delete this._idPool;\n                  this.exit(code);\n                },\n                // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)\n                "runtime.wasmWrite": (sp) => {\n                  sp >>>= 0;\n                  const fd = getInt64(sp + 8);\n                  const p = getInt64(sp + 16);\n                  const n = this.mem.getInt32(sp + 24, true);\n                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));\n                },\n                // func resetMemoryDataView()\n                "runtime.resetMemoryDataView": (sp) => {\n                  sp >>>= 0;\n                  this.mem = new DataView(this._inst.exports.mem.buffer);\n                },\n                // func nanotime1() int64\n                "runtime.nanotime1": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);\n                },\n                // func walltime() (sec int64, nsec int32)\n                "runtime.walltime": (sp) => {\n                  sp >>>= 0;\n                  const msec = (/* @__PURE__ */ new Date()).getTime();\n                  setInt64(sp + 8, msec / 1e3);\n                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);\n                },\n                // func scheduleTimeoutEvent(delay int64) int32\n                "runtime.scheduleTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this._nextCallbackTimeoutID;\n                  this._nextCallbackTimeoutID++;\n                  this._scheduledTimeouts.set(id, setTimeout(\n                    () => {\n                      this._resume();\n                      while (this._scheduledTimeouts.has(id)) {\n                        console.warn("scheduleTimeoutEvent: missed timeout event");\n                        this._resume();\n                      }\n                    },\n                    getInt64(sp + 8)\n                  ));\n                  this.mem.setInt32(sp + 16, id, true);\n                },\n                // func clearTimeoutEvent(id int32)\n                "runtime.clearTimeoutEvent": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getInt32(sp + 8, true);\n                  clearTimeout(this._scheduledTimeouts.get(id));\n                  this._scheduledTimeouts.delete(id);\n                },\n                // func getRandomData(r []byte)\n                "runtime.getRandomData": (sp) => {\n                  sp >>>= 0;\n                  crypto.getRandomValues(loadSlice(sp + 8));\n                },\n                // func finalizeRef(v ref)\n                "syscall/js.finalizeRef": (sp) => {\n                  sp >>>= 0;\n                  const id = this.mem.getUint32(sp + 8, true);\n                  this._goRefCounts[id]--;\n                  if (this._goRefCounts[id] === 0) {\n                    const v = this._values[id];\n                    this._values[id] = null;\n                    this._ids.delete(v);\n                    this._idPool.push(id);\n                  }\n                },\n                // func stringVal(value string) ref\n                "syscall/js.stringVal": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, loadString(sp + 8));\n                },\n                // func valueGet(v ref, p string) ref\n                "syscall/js.valueGet": (sp) => {\n                  sp >>>= 0;\n                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));\n                  sp = this._inst.exports.getsp() >>> 0;\n                  storeValue(sp + 32, result);\n                },\n                // func valueSet(v ref, p string, x ref)\n                "syscall/js.valueSet": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));\n                },\n                // func valueDelete(v ref, p string)\n                "syscall/js.valueDelete": (sp) => {\n                  sp >>>= 0;\n                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));\n                },\n                // func valueIndex(v ref, i int) ref\n                "syscall/js.valueIndex": (sp) => {\n                  sp >>>= 0;\n                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));\n                },\n                // valueSetIndex(v ref, i int, x ref)\n                "syscall/js.valueSetIndex": (sp) => {\n                  sp >>>= 0;\n                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));\n                },\n                // func valueCall(v ref, m string, args []ref) (ref, bool)\n                "syscall/js.valueCall": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const m = Reflect.get(v, loadString(sp + 16));\n                    const args = loadSliceOfValues(sp + 32);\n                    const result = Reflect.apply(m, v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, result);\n                    this.mem.setUint8(sp + 64, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 56, err);\n                    this.mem.setUint8(sp + 64, 0);\n                  }\n                },\n                // func valueInvoke(v ref, args []ref) (ref, bool)\n                "syscall/js.valueInvoke": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.apply(v, void 0, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                // func valueNew(v ref, args []ref) (ref, bool)\n                "syscall/js.valueNew": (sp) => {\n                  sp >>>= 0;\n                  try {\n                    const v = loadValue(sp + 8);\n                    const args = loadSliceOfValues(sp + 16);\n                    const result = Reflect.construct(v, args);\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, result);\n                    this.mem.setUint8(sp + 48, 1);\n                  } catch (err) {\n                    sp = this._inst.exports.getsp() >>> 0;\n                    storeValue(sp + 40, err);\n                    this.mem.setUint8(sp + 48, 0);\n                  }\n                },\n                // func valueLength(v ref) int\n                "syscall/js.valueLength": (sp) => {\n                  sp >>>= 0;\n                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));\n                },\n                // valuePrepareString(v ref) (ref, int)\n                "syscall/js.valuePrepareString": (sp) => {\n                  sp >>>= 0;\n                  const str = encoder.encode(String(loadValue(sp + 8)));\n                  storeValue(sp + 16, str);\n                  setInt64(sp + 24, str.length);\n                },\n                // valueLoadString(v ref, b []byte)\n                "syscall/js.valueLoadString": (sp) => {\n                  sp >>>= 0;\n                  const str = loadValue(sp + 8);\n                  loadSlice(sp + 16).set(str);\n                },\n                // func valueInstanceOf(v ref, t ref) bool\n                "syscall/js.valueInstanceOf": (sp) => {\n                  sp >>>= 0;\n                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);\n                },\n                // func copyBytesToGo(dst []byte, src ref) (int, bool)\n                "syscall/js.copyBytesToGo": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadSlice(sp + 8);\n                  const src = loadValue(sp + 32);\n                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                // func copyBytesToJS(dst ref, src []byte) (int, bool)\n                "syscall/js.copyBytesToJS": (sp) => {\n                  sp >>>= 0;\n                  const dst = loadValue(sp + 8);\n                  const src = loadSlice(sp + 16);\n                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {\n                    this.mem.setUint8(sp + 48, 0);\n                    return;\n                  }\n                  const toCopy = src.subarray(0, dst.length);\n                  dst.set(toCopy);\n                  setInt64(sp + 40, toCopy.length);\n                  this.mem.setUint8(sp + 48, 1);\n                },\n                "debug": (value) => {\n                  console.log(value);\n                }\n              }\n            };\n          }\n          run(instance) {\n            return __async(this, null, function* () {\n              if (!(instance instanceof WebAssembly.Instance)) {\n                throw new Error("Go.run: WebAssembly.Instance expected");\n              }\n              this._inst = instance;\n              this.mem = new DataView(this._inst.exports.mem.buffer);\n              this._values = [\n                // JS values that Go currently has references to, indexed by reference id\n                NaN,\n                0,\n                null,\n                true,\n                false,\n                globalThis,\n                this\n              ];\n              this._goRefCounts = new Array(this._values.length).fill(Infinity);\n              this._ids = /* @__PURE__ */ new Map([\n                // mapping from JS values to reference ids\n                [0, 1],\n                [null, 2],\n                [true, 3],\n                [false, 4],\n                [globalThis, 5],\n                [this, 6]\n              ]);\n              this._idPool = [];\n              this.exited = false;\n              let offset = 4096;\n              const strPtr = (str) => {\n                const ptr = offset;\n                const bytes = encoder.encode(str + "\\0");\n                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);\n                offset += bytes.length;\n                if (offset % 8 !== 0) {\n                  offset += 8 - offset % 8;\n                }\n                return ptr;\n              };\n              const argc = this.argv.length;\n              const argvPtrs = [];\n              this.argv.forEach((arg) => {\n                argvPtrs.push(strPtr(arg));\n              });\n              argvPtrs.push(0);\n              const keys = Object.keys(this.env).sort();\n              keys.forEach((key) => {\n                argvPtrs.push(strPtr(`${key}=${this.env[key]}`));\n              });\n              argvPtrs.push(0);\n              const argv = offset;\n              argvPtrs.forEach((ptr) => {\n                this.mem.setUint32(offset, ptr, true);\n                this.mem.setUint32(offset + 4, 0, true);\n                offset += 8;\n              });\n              const wasmMinDataAddr = 4096 + 8192;\n              if (offset >= wasmMinDataAddr) {\n                throw new Error("total length of command line and environment variables exceeds limit");\n              }\n              this._inst.exports.run(argc, argv);\n              if (this.exited) {\n                this._resolveExitPromise();\n              }\n              yield this._exitPromise;\n            });\n          }\n          _resume() {\n            if (this.exited) {\n              throw new Error("Go program has already exited");\n            }\n            this._inst.exports.resume();\n            if (this.exited) {\n              this._resolveExitPromise();\n            }\n          }\n          _makeFuncWrapper(id) {\n            const go = this;\n            return function() {\n              const event = { id, this: this, args: arguments };\n              go._pendingEvent = event;\n              go._resume();\n              return event.result;\n            };\n          }\n        };\n      })();\n      onmessage = ({ data: wasm }) => {\n        let decoder = new TextDecoder();\n        let fs = globalThis.fs;\n        let stderr = "";\n        fs.writeSync = (fd, buffer) => {\n          if (fd === 1) {\n            postMessage(buffer);\n          } else if (fd === 2) {\n            stderr += decoder.decode(buffer);\n            let parts = stderr.split("\\n");\n            if (parts.length > 1) console.log(parts.slice(0, -1).join("\\n"));\n            stderr = parts[parts.length - 1];\n          } else {\n            throw new Error("Bad write");\n          }\n          return buffer.length;\n        };\n        let stdin = [];\n        let resumeStdin;\n        let stdinPos = 0;\n        onmessage = ({ data }) => {\n          if (data.length > 0) {\n            stdin.push(data);\n            if (resumeStdin) resumeStdin();\n          }\n          return go;\n        };\n        fs.read = (fd, buffer, offset, length, position, callback) => {\n          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {\n            throw new Error("Bad read");\n          }\n          if (stdin.length === 0) {\n            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);\n            return;\n          }\n          let first = stdin[0];\n          let count = Math.max(0, Math.min(length, first.length - stdinPos));\n          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);\n          stdinPos += count;\n          if (stdinPos === first.length) {\n            stdin.shift();\n            stdinPos = 0;\n          }\n          callback(null, count);\n        };\n        let go = new globalThis.Go();\n        go.argv = ["", `--service=${"0.25.11"}`];\n        tryToInstantiateModule(wasm, go).then(\n          (instance) => {\n            postMessage(null);\n            go.run(instance);\n          },\n          (error) => {\n            postMessage(error);\n          }\n        );\n        return go;\n      };\n      function tryToInstantiateModule(wasm, go) {\n        return __async(this, null, function* () {\n          if (wasm instanceof WebAssembly.Module) {\n            return WebAssembly.instantiate(wasm, go.importObject);\n          }\n          const res = yield fetch(wasm);\n          if (!res.ok) throw new Error(`Failed to download ${JSON.stringify(wasm)}`);\n          if ("instantiateStreaming" in WebAssembly && /^application\\/wasm($|;)/i.test(res.headers.get("Content-Type") || "")) {\n            const result2 = yield WebAssembly.instantiateStreaming(res, go.importObject);\n            return result2.instance;\n          }\n          const bytes = yield res.arrayBuffer();\n          const result = yield WebAssembly.instantiate(bytes, go.importObject);\n          return result.instance;\n        });\n      }\n      return (m) => onmessage(m);\n    })'}(postMessage)`], { type: "text/javascript" });
          worker = new Worker(URL.createObjectURL(blob));
        } else {
          let onmessage2 = ((postMessage2) => {
            var __async2 = (__this, __arguments, generator) => {
              return new Promise((resolve, reject) => {
                var fulfilled = (value2) => {
                  try {
                    step(generator.next(value2));
                  } catch (e) {
                    reject(e);
                  }
                };
                var rejected = (value2) => {
                  try {
                    step(generator.throw(value2));
                  } catch (e) {
                    reject(e);
                  }
                };
                var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
                step((generator = generator.apply(__this, __arguments)).next());
              });
            };
            let onmessage3;
            let globalThis2 = {};
            for (let o = self; o; o = Object.getPrototypeOf(o))
              for (let k of Object.getOwnPropertyNames(o))
                if (!(k in globalThis2))
                  Object.defineProperty(globalThis2, k, { get: () => self[k] });
            "use strict";
            (() => {
              const enosys = () => {
                const err2 = new Error("not implemented");
                err2.code = "ENOSYS";
                return err2;
              };
              if (!globalThis2.fs) {
                let outputBuf = "";
                globalThis2.fs = {
                  constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },
                  // unused
                  writeSync(fd2, buf) {
                    outputBuf += decoder.decode(buf);
                    const nl = outputBuf.lastIndexOf("\n");
                    if (nl != -1) {
                      console.log(outputBuf.substring(0, nl));
                      outputBuf = outputBuf.substring(nl + 1);
                    }
                    return buf.length;
                  },
                  write(fd2, buf, offset, length2, position, callback) {
                    if (offset !== 0 || length2 !== buf.length || position !== null) {
                      callback(enosys());
                      return;
                    }
                    const n = this.writeSync(fd2, buf);
                    callback(null, n);
                  },
                  chmod(path, mode, callback) {
                    callback(enosys());
                  },
                  chown(path, uid, gid, callback) {
                    callback(enosys());
                  },
                  close(fd2, callback) {
                    callback(enosys());
                  },
                  fchmod(fd2, mode, callback) {
                    callback(enosys());
                  },
                  fchown(fd2, uid, gid, callback) {
                    callback(enosys());
                  },
                  fstat(fd2, callback) {
                    callback(enosys());
                  },
                  fsync(fd2, callback) {
                    callback(null);
                  },
                  ftruncate(fd2, length2, callback) {
                    callback(enosys());
                  },
                  lchown(path, uid, gid, callback) {
                    callback(enosys());
                  },
                  link(path, link, callback) {
                    callback(enosys());
                  },
                  lstat(path, callback) {
                    callback(enosys());
                  },
                  mkdir(path, perm, callback) {
                    callback(enosys());
                  },
                  open(path, flags, mode, callback) {
                    callback(enosys());
                  },
                  read(fd2, buffer, offset, length2, position, callback) {
                    callback(enosys());
                  },
                  readdir(path, callback) {
                    callback(enosys());
                  },
                  readlink(path, callback) {
                    callback(enosys());
                  },
                  rename(from, to, callback) {
                    callback(enosys());
                  },
                  rmdir(path, callback) {
                    callback(enosys());
                  },
                  stat(path, callback) {
                    callback(enosys());
                  },
                  symlink(path, link, callback) {
                    callback(enosys());
                  },
                  truncate(path, length2, callback) {
                    callback(enosys());
                  },
                  unlink(path, callback) {
                    callback(enosys());
                  },
                  utimes(path, atime, mtime, callback) {
                    callback(enosys());
                  }
                };
              }
              if (!globalThis2.process) {
                globalThis2.process = {
                  getuid() {
                    return -1;
                  },
                  getgid() {
                    return -1;
                  },
                  geteuid() {
                    return -1;
                  },
                  getegid() {
                    return -1;
                  },
                  getgroups() {
                    throw enosys();
                  },
                  pid: -1,
                  ppid: -1,
                  umask() {
                    throw enosys();
                  },
                  cwd() {
                    throw enosys();
                  },
                  chdir() {
                    throw enosys();
                  }
                };
              }
              if (!globalThis2.crypto) {
                throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");
              }
              if (!globalThis2.performance) {
                throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");
              }
              if (!globalThis2.TextEncoder) {
                throw new Error("globalThis.TextEncoder is not available, polyfill required");
              }
              if (!globalThis2.TextDecoder) {
                throw new Error("globalThis.TextDecoder is not available, polyfill required");
              }
              const encoder = new TextEncoder("utf-8");
              const decoder = new TextDecoder("utf-8");
              globalThis2.Go = class {
                constructor() {
                  this.argv = ["js"];
                  this.env = {};
                  this.exit = (code) => {
                    if (code !== 0) {
                      console.warn("exit code:", code);
                    }
                  };
                  this._exitPromise = new Promise((resolve) => {
                    this._resolveExitPromise = resolve;
                  });
                  this._pendingEvent = null;
                  this._scheduledTimeouts = /* @__PURE__ */ new Map();
                  this._nextCallbackTimeoutID = 1;
                  const setInt64 = (addr, v) => {
                    this.mem.setUint32(addr + 0, v, true);
                    this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);
                  };
                  const setInt32 = (addr, v) => {
                    this.mem.setUint32(addr + 0, v, true);
                  };
                  const getInt64 = (addr) => {
                    const low = this.mem.getUint32(addr + 0, true);
                    const high = this.mem.getInt32(addr + 4, true);
                    return low + high * 4294967296;
                  };
                  const loadValue = (addr) => {
                    const f = this.mem.getFloat64(addr, true);
                    if (f === 0) {
                      return void 0;
                    }
                    if (!isNaN(f)) {
                      return f;
                    }
                    const id = this.mem.getUint32(addr, true);
                    return this._values[id];
                  };
                  const storeValue = (addr, v) => {
                    const nanHead = 2146959360;
                    if (typeof v === "number" && v !== 0) {
                      if (isNaN(v)) {
                        this.mem.setUint32(addr + 4, nanHead, true);
                        this.mem.setUint32(addr, 0, true);
                        return;
                      }
                      this.mem.setFloat64(addr, v, true);
                      return;
                    }
                    if (v === void 0) {
                      this.mem.setFloat64(addr, 0, true);
                      return;
                    }
                    let id = this._ids.get(v);
                    if (id === void 0) {
                      id = this._idPool.pop();
                      if (id === void 0) {
                        id = this._values.length;
                      }
                      this._values[id] = v;
                      this._goRefCounts[id] = 0;
                      this._ids.set(v, id);
                    }
                    this._goRefCounts[id]++;
                    let typeFlag = 0;
                    switch (typeof v) {
                      case "object":
                        if (v !== null) {
                          typeFlag = 1;
                        }
                        break;
                      case "string":
                        typeFlag = 2;
                        break;
                      case "symbol":
                        typeFlag = 3;
                        break;
                      case "function":
                        typeFlag = 4;
                        break;
                    }
                    this.mem.setUint32(addr + 4, nanHead | typeFlag, true);
                    this.mem.setUint32(addr, id, true);
                  };
                  const loadSlice = (addr) => {
                    const array = getInt64(addr + 0);
                    const len = getInt64(addr + 8);
                    return new Uint8Array(this._inst.exports.mem.buffer, array, len);
                  };
                  const loadSliceOfValues = (addr) => {
                    const array = getInt64(addr + 0);
                    const len = getInt64(addr + 8);
                    const a = new Array(len);
                    for (let i = 0; i < len; i++) {
                      a[i] = loadValue(array + i * 8);
                    }
                    return a;
                  };
                  const loadString = (addr) => {
                    const saddr = getInt64(addr + 0);
                    const len = getInt64(addr + 8);
                    return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));
                  };
                  const timeOrigin = Date.now() - performance.now();
                  this.importObject = {
                    _gotest: {
                      add: (a, b) => a + b
                    },
                    gojs: {
                      // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)
                      // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported
                      // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).
                      // This changes the SP, thus we have to update the SP used by the imported function.
                      // func wasmExit(code int32)
                      "runtime.wasmExit": (sp) => {
                        sp >>>= 0;
                        const code = this.mem.getInt32(sp + 8, true);
                        this.exited = true;
                        delete this._inst;
                        delete this._values;
                        delete this._goRefCounts;
                        delete this._ids;
                        delete this._idPool;
                        this.exit(code);
                      },
                      // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)
                      "runtime.wasmWrite": (sp) => {
                        sp >>>= 0;
                        const fd2 = getInt64(sp + 8);
                        const p = getInt64(sp + 16);
                        const n = this.mem.getInt32(sp + 24, true);
                        globalThis2.fs.writeSync(fd2, new Uint8Array(this._inst.exports.mem.buffer, p, n));
                      },
                      // func resetMemoryDataView()
                      "runtime.resetMemoryDataView": (sp) => {
                        sp >>>= 0;
                        this.mem = new DataView(this._inst.exports.mem.buffer);
                      },
                      // func nanotime1() int64
                      "runtime.nanotime1": (sp) => {
                        sp >>>= 0;
                        setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);
                      },
                      // func walltime() (sec int64, nsec int32)
                      "runtime.walltime": (sp) => {
                        sp >>>= 0;
                        const msec = (/* @__PURE__ */ new Date()).getTime();
                        setInt64(sp + 8, msec / 1e3);
                        this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);
                      },
                      // func scheduleTimeoutEvent(delay int64) int32
                      "runtime.scheduleTimeoutEvent": (sp) => {
                        sp >>>= 0;
                        const id = this._nextCallbackTimeoutID;
                        this._nextCallbackTimeoutID++;
                        this._scheduledTimeouts.set(id, setTimeout(
                          () => {
                            this._resume();
                            while (this._scheduledTimeouts.has(id)) {
                              console.warn("scheduleTimeoutEvent: missed timeout event");
                              this._resume();
                            }
                          },
                          getInt64(sp + 8)
                        ));
                        this.mem.setInt32(sp + 16, id, true);
                      },
                      // func clearTimeoutEvent(id int32)
                      "runtime.clearTimeoutEvent": (sp) => {
                        sp >>>= 0;
                        const id = this.mem.getInt32(sp + 8, true);
                        clearTimeout(this._scheduledTimeouts.get(id));
                        this._scheduledTimeouts.delete(id);
                      },
                      // func getRandomData(r []byte)
                      "runtime.getRandomData": (sp) => {
                        sp >>>= 0;
                        crypto.getRandomValues(loadSlice(sp + 8));
                      },
                      // func finalizeRef(v ref)
                      "syscall/js.finalizeRef": (sp) => {
                        sp >>>= 0;
                        const id = this.mem.getUint32(sp + 8, true);
                        this._goRefCounts[id]--;
                        if (this._goRefCounts[id] === 0) {
                          const v = this._values[id];
                          this._values[id] = null;
                          this._ids.delete(v);
                          this._idPool.push(id);
                        }
                      },
                      // func stringVal(value string) ref
                      "syscall/js.stringVal": (sp) => {
                        sp >>>= 0;
                        storeValue(sp + 24, loadString(sp + 8));
                      },
                      // func valueGet(v ref, p string) ref
                      "syscall/js.valueGet": (sp) => {
                        sp >>>= 0;
                        const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));
                        sp = this._inst.exports.getsp() >>> 0;
                        storeValue(sp + 32, result);
                      },
                      // func valueSet(v ref, p string, x ref)
                      "syscall/js.valueSet": (sp) => {
                        sp >>>= 0;
                        Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));
                      },
                      // func valueDelete(v ref, p string)
                      "syscall/js.valueDelete": (sp) => {
                        sp >>>= 0;
                        Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));
                      },
                      // func valueIndex(v ref, i int) ref
                      "syscall/js.valueIndex": (sp) => {
                        sp >>>= 0;
                        storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));
                      },
                      // valueSetIndex(v ref, i int, x ref)
                      "syscall/js.valueSetIndex": (sp) => {
                        sp >>>= 0;
                        Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));
                      },
                      // func valueCall(v ref, m string, args []ref) (ref, bool)
                      "syscall/js.valueCall": (sp) => {
                        sp >>>= 0;
                        try {
                          const v = loadValue(sp + 8);
                          const m = Reflect.get(v, loadString(sp + 16));
                          const args = loadSliceOfValues(sp + 32);
                          const result = Reflect.apply(m, v, args);
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 56, result);
                          this.mem.setUint8(sp + 64, 1);
                        } catch (err2) {
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 56, err2);
                          this.mem.setUint8(sp + 64, 0);
                        }
                      },
                      // func valueInvoke(v ref, args []ref) (ref, bool)
                      "syscall/js.valueInvoke": (sp) => {
                        sp >>>= 0;
                        try {
                          const v = loadValue(sp + 8);
                          const args = loadSliceOfValues(sp + 16);
                          const result = Reflect.apply(v, void 0, args);
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 40, result);
                          this.mem.setUint8(sp + 48, 1);
                        } catch (err2) {
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 40, err2);
                          this.mem.setUint8(sp + 48, 0);
                        }
                      },
                      // func valueNew(v ref, args []ref) (ref, bool)
                      "syscall/js.valueNew": (sp) => {
                        sp >>>= 0;
                        try {
                          const v = loadValue(sp + 8);
                          const args = loadSliceOfValues(sp + 16);
                          const result = Reflect.construct(v, args);
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 40, result);
                          this.mem.setUint8(sp + 48, 1);
                        } catch (err2) {
                          sp = this._inst.exports.getsp() >>> 0;
                          storeValue(sp + 40, err2);
                          this.mem.setUint8(sp + 48, 0);
                        }
                      },
                      // func valueLength(v ref) int
                      "syscall/js.valueLength": (sp) => {
                        sp >>>= 0;
                        setInt64(sp + 16, parseInt(loadValue(sp + 8).length));
                      },
                      // valuePrepareString(v ref) (ref, int)
                      "syscall/js.valuePrepareString": (sp) => {
                        sp >>>= 0;
                        const str = encoder.encode(String(loadValue(sp + 8)));
                        storeValue(sp + 16, str);
                        setInt64(sp + 24, str.length);
                      },
                      // valueLoadString(v ref, b []byte)
                      "syscall/js.valueLoadString": (sp) => {
                        sp >>>= 0;
                        const str = loadValue(sp + 8);
                        loadSlice(sp + 16).set(str);
                      },
                      // func valueInstanceOf(v ref, t ref) bool
                      "syscall/js.valueInstanceOf": (sp) => {
                        sp >>>= 0;
                        this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);
                      },
                      // func copyBytesToGo(dst []byte, src ref) (int, bool)
                      "syscall/js.copyBytesToGo": (sp) => {
                        sp >>>= 0;
                        const dst = loadSlice(sp + 8);
                        const src = loadValue(sp + 32);
                        if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {
                          this.mem.setUint8(sp + 48, 0);
                          return;
                        }
                        const toCopy = src.subarray(0, dst.length);
                        dst.set(toCopy);
                        setInt64(sp + 40, toCopy.length);
                        this.mem.setUint8(sp + 48, 1);
                      },
                      // func copyBytesToJS(dst ref, src []byte) (int, bool)
                      "syscall/js.copyBytesToJS": (sp) => {
                        sp >>>= 0;
                        const dst = loadValue(sp + 8);
                        const src = loadSlice(sp + 16);
                        if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {
                          this.mem.setUint8(sp + 48, 0);
                          return;
                        }
                        const toCopy = src.subarray(0, dst.length);
                        dst.set(toCopy);
                        setInt64(sp + 40, toCopy.length);
                        this.mem.setUint8(sp + 48, 1);
                      },
                      "debug": (value2) => {
                        console.log(value2);
                      }
                    }
                  };
                }
                run(instance) {
                  return __async2(this, null, function* () {
                    if (!(instance instanceof WebAssembly.Instance)) {
                      throw new Error("Go.run: WebAssembly.Instance expected");
                    }
                    this._inst = instance;
                    this.mem = new DataView(this._inst.exports.mem.buffer);
                    this._values = [
                      // JS values that Go currently has references to, indexed by reference id
                      NaN,
                      0,
                      null,
                      true,
                      false,
                      globalThis2,
                      this
                    ];
                    this._goRefCounts = new Array(this._values.length).fill(Infinity);
                    this._ids = /* @__PURE__ */ new Map([
                      // mapping from JS values to reference ids
                      [0, 1],
                      [null, 2],
                      [true, 3],
                      [false, 4],
                      [globalThis2, 5],
                      [this, 6]
                    ]);
                    this._idPool = [];
                    this.exited = false;
                    let offset = 4096;
                    const strPtr = (str) => {
                      const ptr = offset;
                      const bytes = encoder.encode(str + "\0");
                      new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);
                      offset += bytes.length;
                      if (offset % 8 !== 0) {
                        offset += 8 - offset % 8;
                      }
                      return ptr;
                    };
                    const argc = this.argv.length;
                    const argvPtrs = [];
                    this.argv.forEach((arg) => {
                      argvPtrs.push(strPtr(arg));
                    });
                    argvPtrs.push(0);
                    const keys = Object.keys(this.env).sort();
                    keys.forEach((key) => {
                      argvPtrs.push(strPtr(`${key}=${this.env[key]}`));
                    });
                    argvPtrs.push(0);
                    const argv = offset;
                    argvPtrs.forEach((ptr) => {
                      this.mem.setUint32(offset, ptr, true);
                      this.mem.setUint32(offset + 4, 0, true);
                      offset += 8;
                    });
                    const wasmMinDataAddr = 4096 + 8192;
                    if (offset >= wasmMinDataAddr) {
                      throw new Error("total length of command line and environment variables exceeds limit");
                    }
                    this._inst.exports.run(argc, argv);
                    if (this.exited) {
                      this._resolveExitPromise();
                    }
                    yield this._exitPromise;
                  });
                }
                _resume() {
                  if (this.exited) {
                    throw new Error("Go program has already exited");
                  }
                  this._inst.exports.resume();
                  if (this.exited) {
                    this._resolveExitPromise();
                  }
                }
                _makeFuncWrapper(id) {
                  const go2 = this;
                  return function() {
                    const event = { id, this: this, args: arguments };
                    go2._pendingEvent = event;
                    go2._resume();
                    return event.result;
                  };
                }
              };
            })();
            onmessage3 = ({ data: wasm }) => {
              let decoder = new TextDecoder();
              let fs = globalThis2.fs;
              let stderr = "";
              fs.writeSync = (fd2, buffer) => {
                if (fd2 === 1) {
                  postMessage2(buffer);
                } else if (fd2 === 2) {
                  stderr += decoder.decode(buffer);
                  let parts = stderr.split("\n");
                  if (parts.length > 1) console.log(parts.slice(0, -1).join("\n"));
                  stderr = parts[parts.length - 1];
                } else {
                  throw new Error("Bad write");
                }
                return buffer.length;
              };
              let stdin = [];
              let resumeStdin;
              let stdinPos = 0;
              onmessage3 = ({ data }) => {
                if (data.length > 0) {
                  stdin.push(data);
                  if (resumeStdin) resumeStdin();
                }
                return go2;
              };
              fs.read = (fd2, buffer, offset, length2, position, callback) => {
                if (fd2 !== 0 || offset !== 0 || length2 !== buffer.length || position !== null) {
                  throw new Error("Bad read");
                }
                if (stdin.length === 0) {
                  resumeStdin = () => fs.read(fd2, buffer, offset, length2, position, callback);
                  return;
                }
                let first = stdin[0];
                let count = Math.max(0, Math.min(length2, first.length - stdinPos));
                buffer.set(first.subarray(stdinPos, stdinPos + count), offset);
                stdinPos += count;
                if (stdinPos === first.length) {
                  stdin.shift();
                  stdinPos = 0;
                }
                callback(null, count);
              };
              let go2 = new globalThis2.Go();
              go2.argv = ["", `--service=${"0.25.11"}`];
              tryToInstantiateModule(wasm, go2).then(
                (instance) => {
                  postMessage2(null);
                  go2.run(instance);
                },
                (error) => {
                  postMessage2(error);
                }
              );
              return go2;
            };
            function tryToInstantiateModule(wasm, go2) {
              return __async2(this, null, function* () {
                if (wasm instanceof WebAssembly.Module) {
                  return WebAssembly.instantiate(wasm, go2.importObject);
                }
                const res = yield fetch(wasm);
                if (!res.ok) throw new Error(`Failed to download ${JSON.stringify(wasm)}`);
                if ("instantiateStreaming" in WebAssembly && /^application\/wasm($|;)/i.test(res.headers.get("Content-Type") || "")) {
                  const result2 = yield WebAssembly.instantiateStreaming(res, go2.importObject);
                  return result2.instance;
                }
                const bytes = yield res.arrayBuffer();
                const result = yield WebAssembly.instantiate(bytes, go2.importObject);
                return result.instance;
              });
            }
            return (m) => onmessage3(m);
          })((data) => worker.onmessage({ data }));
          let go;
          worker = {
            onmessage: null,
            postMessage: (data) => setTimeout(() => {
              try {
                go = onmessage2({ data });
              } catch (error) {
                rejectAllWith(error);
              }
            }),
            terminate() {
              if (go)
                for (let timeout of go._scheduledTimeouts.values())
                  clearTimeout(timeout);
            }
          };
        }
        let firstMessageResolve;
        let firstMessageReject;
        const firstMessagePromise = new Promise((resolve, reject) => {
          firstMessageResolve = resolve;
          firstMessageReject = reject;
        });
        worker.onmessage = ({ data: error }) => {
          worker.onmessage = ({ data }) => readFromStdout(data);
          if (error) firstMessageReject(error);
          else firstMessageResolve();
        };
        worker.postMessage(wasmModule || new URL(wasmURL, location.href).toString());
        let { readFromStdout, service } = createChannel({
          writeToStdin(bytes) {
            worker.postMessage(bytes);
          },
          isSync: false,
          hasFS: false,
          esbuild: browser_exports
        });
        yield firstMessagePromise;
        stopService = () => {
          worker.terminate();
          initializePromise = void 0;
          stopService = void 0;
          longLivedService = void 0;
        };
        longLivedService = {
          build: (options) => new Promise((resolve, reject) => {
            rejectAllPromise.then(reject);
            service.buildOrContext({
              callName: "build",
              refs: null,
              options,
              isTTY: false,
              defaultWD: "/",
              callback: (err2, res) => err2 ? reject(err2) : resolve(res)
            });
          }),
          context: (options) => new Promise((resolve, reject) => {
            rejectAllPromise.then(reject);
            service.buildOrContext({
              callName: "context",
              refs: null,
              options,
              isTTY: false,
              defaultWD: "/",
              callback: (err2, res) => err2 ? reject(err2) : resolve(res)
            });
          }),
          transform: (input, options) => new Promise((resolve, reject) => {
            rejectAllPromise.then(reject);
            service.transform({
              callName: "transform",
              refs: null,
              input,
              options: options || {},
              isTTY: false,
              fs: {
                readFile(_, callback) {
                  callback(new Error("Internal error"), null);
                },
                writeFile(_, callback) {
                  callback(null);
                }
              },
              callback: (err2, res) => err2 ? reject(err2) : resolve(res)
            });
          }),
          formatMessages: (messages, options) => new Promise((resolve, reject) => {
            rejectAllPromise.then(reject);
            service.formatMessages({
              callName: "formatMessages",
              refs: null,
              messages,
              options,
              callback: (err2, res) => err2 ? reject(err2) : resolve(res)
            });
          }),
          analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => {
            rejectAllPromise.then(reject);
            service.analyzeMetafile({
              callName: "analyzeMetafile",
              refs: null,
              metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
              options,
              callback: (err2, res) => err2 ? reject(err2) : resolve(res)
            });
          })
        };
      });
      var browser_default = browser_exports;
    })(typeof module === "object" ? module : { set exports(x) {
      (typeof self !== "undefined" ? self : this).esbuild = x;
    } });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.resolveURI = factory());
    })(exports, (function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path) ? path : "/" + path, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path,
          query,
          hash,
          type: 7
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = 6;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = 5;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url;
      }
      function stripPathFilename(path) {
        if (path.endsWith("/.."))
          return path;
        const index = path.lastIndexOf("/");
        return path.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath(url, type) {
        const rel = type <= 4;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path = "";
        for (let i = 1; i < pointer; i++) {
          path += "/" + pieces[i];
        }
        if (!path || addTrailingSlash && !path.endsWith("/..")) {
          path += "/";
        }
        url.path = path;
      }
      function resolve(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url.hash = baseUrl.hash;
            // fall through
            case 2:
              url.query = baseUrl.query;
            // fall through
            case 3:
            case 4:
              mergePaths(url, baseUrl);
            // fall through
            case 5:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            // fall through
            case 6:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path = url.path.slice(1);
            if (!path)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path)) {
              return "./" + path + queryHash;
            }
            return path + queryHash;
          }
          case 5:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve;
    }));
  }
});

// node_modules/convert-source-map/index.js
var require_convert_source_map = __commonJS({
  "node_modules/convert-source-map/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "commentRegex", {
      get: function getCommentRegex() {
        return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
      }
    });
    Object.defineProperty(exports, "mapFileCommentRegex", {
      get: function getMapFileCommentRegex() {
        return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
      }
    });
    var decodeBase64;
    if (typeof Buffer !== "undefined") {
      if (typeof Buffer.from === "function") {
        decodeBase64 = decodeBase64WithBufferFrom;
      } else {
        decodeBase64 = decodeBase64WithNewBuffer;
      }
    } else {
      decodeBase64 = decodeBase64WithAtob;
    }
    function decodeBase64WithBufferFrom(base64) {
      return Buffer.from(base64, "base64").toString();
    }
    function decodeBase64WithNewBuffer(base64) {
      if (typeof value === "number") {
        throw new TypeError("The value to decode must not be of type number.");
      }
      return new Buffer(base64, "base64").toString();
    }
    function decodeBase64WithAtob(base64) {
      return decodeURIComponent(escape(atob(base64)));
    }
    function stripComment(sm) {
      return sm.split(",").pop();
    }
    function readFromFileMap(sm, read2) {
      var r = exports.mapFileCommentRegex.exec(sm);
      var filename = r[1] || r[2];
      try {
        var sm = read2(filename);
        if (sm != null && typeof sm.catch === "function") {
          return sm.catch(throwError);
        } else {
          return sm;
        }
      } catch (e) {
        throwError(e);
      }
      function throwError(e) {
        throw new Error("An error occurred while trying to read the map file at " + filename + "\n" + e.stack);
      }
    }
    function Converter(sm, opts) {
      opts = opts || {};
      if (opts.hasComment) {
        sm = stripComment(sm);
      }
      if (opts.encoding === "base64") {
        sm = decodeBase64(sm);
      } else if (opts.encoding === "uri") {
        sm = decodeURIComponent(sm);
      }
      if (opts.isJSON || opts.encoding) {
        sm = JSON.parse(sm);
      }
      this.sourcemap = sm;
    }
    Converter.prototype.toJSON = function(space) {
      return JSON.stringify(this.sourcemap, null, space);
    };
    if (typeof Buffer !== "undefined") {
      if (typeof Buffer.from === "function") {
        Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
      } else {
        Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
      }
    } else {
      Converter.prototype.toBase64 = encodeBase64WithBtoa;
    }
    function encodeBase64WithBufferFrom() {
      var json = this.toJSON();
      return Buffer.from(json, "utf8").toString("base64");
    }
    function encodeBase64WithNewBuffer() {
      var json = this.toJSON();
      if (typeof json === "number") {
        throw new TypeError("The json to encode must not be of type number.");
      }
      return new Buffer(json, "utf8").toString("base64");
    }
    function encodeBase64WithBtoa() {
      var json = this.toJSON();
      return btoa(unescape(encodeURIComponent(json)));
    }
    Converter.prototype.toURI = function() {
      var json = this.toJSON();
      return encodeURIComponent(json);
    };
    Converter.prototype.toComment = function(options) {
      var encoding, content, data;
      if (options != null && options.encoding === "uri") {
        encoding = "";
        content = this.toURI();
      } else {
        encoding = ";base64";
        content = this.toBase64();
      }
      data = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content;
      return options != null && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
    Converter.prototype.toObject = function() {
      return JSON.parse(this.toJSON());
    };
    Converter.prototype.addProperty = function(key, value2) {
      if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value2);
    };
    Converter.prototype.setProperty = function(key, value2) {
      this.sourcemap[key] = value2;
      return this;
    };
    Converter.prototype.getProperty = function(key) {
      return this.sourcemap[key];
    };
    exports.fromObject = function(obj) {
      return new Converter(obj);
    };
    exports.fromJSON = function(json) {
      return new Converter(json, { isJSON: true });
    };
    exports.fromURI = function(uri) {
      return new Converter(uri, { encoding: "uri" });
    };
    exports.fromBase64 = function(base64) {
      return new Converter(base64, { encoding: "base64" });
    };
    exports.fromComment = function(comment) {
      var m, encoding;
      comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
      m = exports.commentRegex.exec(comment);
      encoding = m && m[4] || "uri";
      return new Converter(comment, { encoding, hasComment: true });
    };
    function makeConverter(sm) {
      return new Converter(sm, { isJSON: true });
    }
    exports.fromMapFileComment = function(comment, read2) {
      if (typeof read2 === "string") {
        throw new Error(
          "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
        );
      }
      var sm = readFromFileMap(comment, read2);
      if (sm != null && typeof sm.then === "function") {
        return sm.then(makeConverter);
      } else {
        return makeConverter(sm);
      }
    };
    exports.fromSource = function(content) {
      var m = content.match(exports.commentRegex);
      return m ? exports.fromComment(m.pop()) : null;
    };
    exports.fromMapFileSource = function(content, read2) {
      if (typeof read2 === "string") {
        throw new Error(
          "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
        );
      }
      var m = content.match(exports.mapFileCommentRegex);
      return m ? exports.fromMapFileComment(m.pop(), read2) : null;
    };
    exports.removeComments = function(src) {
      return src.replace(exports.commentRegex, "");
    };
    exports.removeMapFileComments = function(src) {
      return src.replace(exports.mapFileCommentRegex, "");
    };
    exports.generateMapFileComment = function(file, options) {
      var data = "sourceMappingURL=" + file;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
  }
});

// node_modules/ktx-parse/dist/ktx-parse.modern.js
function createDefaultContainer() {
  return {
    vkFormat: VK_FORMAT_UNDEFINED,
    typeSize: 1,
    pixelWidth: 0,
    pixelHeight: 0,
    pixelDepth: 0,
    layerCount: 0,
    faceCount: 1,
    levelCount: 0,
    supercompressionScheme: KHR_SUPERCOMPRESSION_NONE,
    levels: [],
    dataFormatDescriptor: [{
      vendorId: KHR_DF_VENDORID_KHRONOS,
      descriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,
      versionNumber: KHR_DF_VERSION,
      colorModel: KHR_DF_MODEL_UNSPECIFIED,
      colorPrimaries: KHR_DF_PRIMARIES_BT709,
      transferFunction: KHR_DF_TRANSFER_SRGB,
      flags: KHR_DF_FLAG_ALPHA_STRAIGHT,
      texelBlockDimension: [0, 0, 0, 0],
      bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
      samples: []
    }],
    keyValue: {},
    globalData: null
  };
}
function decodeText(buffer) {
  return new TextDecoder().decode(buffer);
}
function read(data) {
  const id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);
  if (id[0] !== KTX2_ID[0] || // '´'
  id[1] !== KTX2_ID[1] || // 'K'
  id[2] !== KTX2_ID[2] || // 'T'
  id[3] !== KTX2_ID[3] || // 'X'
  id[4] !== KTX2_ID[4] || // ' '
  id[5] !== KTX2_ID[5] || // '2'
  id[6] !== KTX2_ID[6] || // '0'
  id[7] !== KTX2_ID[7] || // 'ª'
  id[8] !== KTX2_ID[8] || // '\r'
  id[9] !== KTX2_ID[9] || // '\n'
  id[10] !== KTX2_ID[10] || // '\x1A'
  id[11] !== KTX2_ID[11]) {
    throw new Error("Missing KTX 2.0 identifier.");
  }
  const container = createDefaultContainer();
  const headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;
  const headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);
  container.vkFormat = headerReader._nextUint32();
  container.typeSize = headerReader._nextUint32();
  container.pixelWidth = headerReader._nextUint32();
  container.pixelHeight = headerReader._nextUint32();
  container.pixelDepth = headerReader._nextUint32();
  container.layerCount = headerReader._nextUint32();
  container.faceCount = headerReader._nextUint32();
  container.levelCount = headerReader._nextUint32();
  container.supercompressionScheme = headerReader._nextUint32();
  const dfdByteOffset = headerReader._nextUint32();
  const dfdByteLength = headerReader._nextUint32();
  const kvdByteOffset = headerReader._nextUint32();
  const kvdByteLength = headerReader._nextUint32();
  const sgdByteOffset = headerReader._nextUint64();
  const sgdByteLength = headerReader._nextUint64();
  const levelByteLength = Math.max(container.levelCount, 1) * 3 * 8;
  const levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);
  for (let i = 0, il = Math.max(container.levelCount, 1); i < il; i++) {
    container.levels.push({
      levelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),
      uncompressedByteLength: levelReader._nextUint64()
    });
  }
  const dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);
  dfdReader._skip(4);
  const vendorId = dfdReader._nextUint16();
  const descriptorType = dfdReader._nextUint16();
  const versionNumber = dfdReader._nextUint16();
  const descriptorBlockSize = dfdReader._nextUint16();
  const colorModel = dfdReader._nextUint8();
  const colorPrimaries = dfdReader._nextUint8();
  const transferFunction = dfdReader._nextUint8();
  const flags = dfdReader._nextUint8();
  const texelBlockDimension = [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()];
  const bytesPlane = [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()];
  const samples = [];
  const dfd = {
    vendorId,
    descriptorType,
    versionNumber,
    colorModel,
    colorPrimaries,
    transferFunction,
    flags,
    texelBlockDimension,
    bytesPlane,
    samples
  };
  const sampleStart = 6;
  const sampleWords = 4;
  const numSamples = (descriptorBlockSize / 4 - sampleStart) / sampleWords;
  for (let i = 0; i < numSamples; i++) {
    const sample = {
      bitOffset: dfdReader._nextUint16(),
      bitLength: dfdReader._nextUint8(),
      channelType: dfdReader._nextUint8(),
      samplePosition: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
      sampleLower: Number.NEGATIVE_INFINITY,
      sampleUpper: Number.POSITIVE_INFINITY
    };
    if (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {
      sample.sampleLower = dfdReader._nextInt32();
      sample.sampleUpper = dfdReader._nextInt32();
    } else {
      sample.sampleLower = dfdReader._nextUint32();
      sample.sampleUpper = dfdReader._nextUint32();
    }
    dfd.samples[i] = sample;
  }
  container.dataFormatDescriptor.length = 0;
  container.dataFormatDescriptor.push(dfd);
  const kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);
  while (kvdReader._offset < kvdByteLength) {
    const keyValueByteLength = kvdReader._nextUint32();
    const keyData = kvdReader._scan(keyValueByteLength);
    const key = decodeText(keyData);
    container.keyValue[key] = kvdReader._nextUint8Array(keyValueByteLength - keyData.byteLength - 1);
    if (key.match(/^ktx/i)) {
      const text = decodeText(container.keyValue[key]);
      container.keyValue[key] = text.substring(0, text.lastIndexOf("\0"));
    }
    const kvPadding = keyValueByteLength % 4 ? 4 - keyValueByteLength % 4 : 0;
    kvdReader._skip(kvPadding);
  }
  if (sgdByteLength <= 0) return container;
  const sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);
  const endpointCount = sgdReader._nextUint16();
  const selectorCount = sgdReader._nextUint16();
  const endpointsByteLength = sgdReader._nextUint32();
  const selectorsByteLength = sgdReader._nextUint32();
  const tablesByteLength = sgdReader._nextUint32();
  const extendedByteLength = sgdReader._nextUint32();
  const imageDescs = [];
  for (let i = 0, il = Math.max(container.levelCount, 1); i < il; i++) {
    imageDescs.push({
      imageFlags: sgdReader._nextUint32(),
      rgbSliceByteOffset: sgdReader._nextUint32(),
      rgbSliceByteLength: sgdReader._nextUint32(),
      alphaSliceByteOffset: sgdReader._nextUint32(),
      alphaSliceByteLength: sgdReader._nextUint32()
    });
  }
  const endpointsByteOffset = sgdByteOffset + sgdReader._offset;
  const selectorsByteOffset = endpointsByteOffset + endpointsByteLength;
  const tablesByteOffset = selectorsByteOffset + selectorsByteLength;
  const extendedByteOffset = tablesByteOffset + tablesByteLength;
  const endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);
  const selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);
  const tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);
  const extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);
  container.globalData = {
    endpointCount,
    selectorCount,
    imageDescs,
    endpointsData,
    selectorsData,
    tablesData,
    extendedData
  };
  return container;
}
var KHR_SUPERCOMPRESSION_NONE, KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT, KHR_DF_VENDORID_KHRONOS, KHR_DF_VERSION, KHR_DF_MODEL_UNSPECIFIED, KHR_DF_MODEL_ETC1S, KHR_DF_MODEL_UASTC, KHR_DF_FLAG_ALPHA_STRAIGHT, KHR_DF_TRANSFER_SRGB, KHR_DF_PRIMARIES_BT709, KHR_DF_SAMPLE_DATATYPE_SIGNED, VK_FORMAT_UNDEFINED, BufferReader, NUL, KTX2_ID;
var init_ktx_parse_modern = __esm({
  "node_modules/ktx-parse/dist/ktx-parse.modern.js"() {
    KHR_SUPERCOMPRESSION_NONE = 0;
    KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0;
    KHR_DF_VENDORID_KHRONOS = 0;
    KHR_DF_VERSION = 2;
    KHR_DF_MODEL_UNSPECIFIED = 0;
    KHR_DF_MODEL_ETC1S = 163;
    KHR_DF_MODEL_UASTC = 166;
    KHR_DF_FLAG_ALPHA_STRAIGHT = 0;
    KHR_DF_TRANSFER_SRGB = 2;
    KHR_DF_PRIMARIES_BT709 = 1;
    KHR_DF_SAMPLE_DATATYPE_SIGNED = 64;
    VK_FORMAT_UNDEFINED = 0;
    BufferReader = class {
      constructor(data, byteOffset, byteLength, littleEndian) {
        this._dataView = void 0;
        this._littleEndian = void 0;
        this._offset = void 0;
        this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);
        this._littleEndian = littleEndian;
        this._offset = 0;
      }
      _nextUint8() {
        const value2 = this._dataView.getUint8(this._offset);
        this._offset += 1;
        return value2;
      }
      _nextUint16() {
        const value2 = this._dataView.getUint16(this._offset, this._littleEndian);
        this._offset += 2;
        return value2;
      }
      _nextUint32() {
        const value2 = this._dataView.getUint32(this._offset, this._littleEndian);
        this._offset += 4;
        return value2;
      }
      _nextUint64() {
        const left = this._dataView.getUint32(this._offset, this._littleEndian);
        const right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
        const value2 = left + 2 ** 32 * right;
        this._offset += 8;
        return value2;
      }
      _nextInt32() {
        const value2 = this._dataView.getInt32(this._offset, this._littleEndian);
        this._offset += 4;
        return value2;
      }
      _nextUint8Array(len) {
        const value2 = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, len);
        this._offset += len;
        return value2;
      }
      _skip(bytes) {
        this._offset += bytes;
        return this;
      }
      _scan(maxByteLength, term = 0) {
        const byteOffset = this._offset;
        let byteLength = 0;
        while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {
          byteLength++;
          this._offset++;
        }
        if (byteLength < maxByteLength) this._offset++;
        return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
      }
    };
    NUL = new Uint8Array([0]);
    KTX2_ID = [
      // '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
      171,
      75,
      84,
      88,
      32,
      50,
      48,
      187,
      13,
      10,
      26,
      10
    ];
  }
});

// node_modules/@gltf-transform/extensions/dist/index.modern.js
function _extends3() {
  return _extends3 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends3.apply(null, arguments);
}
function isFallbackBuffer(bufferDef) {
  if (!bufferDef.extensions || !bufferDef.extensions[EXT_MESHOPT_COMPRESSION]) return false;
  const fallbackDef = bufferDef.extensions[EXT_MESHOPT_COMPRESSION];
  return !!fallbackDef.fallback;
}
function prepareAccessor(accessor, encoder, mode, filterOptions) {
  const {
    filter,
    bits
  } = filterOptions;
  const result = {
    array: accessor.getArray(),
    byteStride: accessor.getElementSize() * accessor.getComponentSize(),
    componentType: accessor.getComponentType(),
    normalized: accessor.getNormalized()
  };
  if (mode !== MeshoptMode.ATTRIBUTES) return result;
  if (filter !== MeshoptFilter.NONE) {
    let array = accessor.getNormalized() ? decodeNormalizedIntArray(accessor) : new Float32Array(result.array);
    switch (filter) {
      case MeshoptFilter.EXPONENTIAL:
        result.byteStride = accessor.getElementSize() * 4;
        result.componentType = FLOAT;
        result.normalized = false;
        result.array = encoder.encodeFilterExp(array, accessor.getCount(), result.byteStride, bits);
        break;
      case MeshoptFilter.OCTAHEDRAL:
        result.byteStride = bits > 8 ? 8 : 4;
        result.componentType = bits > 8 ? SHORT : BYTE;
        result.normalized = true;
        array = accessor.getElementSize() === 3 ? padNormals(array) : array;
        result.array = encoder.encodeFilterOct(array, accessor.getCount(), result.byteStride, bits);
        break;
      case MeshoptFilter.QUATERNION:
        result.byteStride = 8;
        result.componentType = SHORT;
        result.normalized = true;
        result.array = encoder.encodeFilterQuat(array, accessor.getCount(), result.byteStride, bits);
        break;
      default:
        throw new Error("Invalid filter.");
    }
    result.min = accessor.getMin([]);
    result.max = accessor.getMax([]);
    if (accessor.getNormalized()) {
      result.min = result.min.map((v) => decodeNormalizedInt(v, accessor.getComponentType()));
      result.max = result.max.map((v) => decodeNormalizedInt(v, accessor.getComponentType()));
    }
    if (result.normalized) {
      result.min = result.min.map((v) => encodeNormalizedInt(v, result.componentType));
      result.max = result.max.map((v) => encodeNormalizedInt(v, result.componentType));
    }
  } else if (result.byteStride % 4) {
    result.array = padArrayElements(result.array, accessor.getElementSize());
    result.byteStride = result.array.byteLength / accessor.getCount();
  }
  return result;
}
function decodeNormalizedIntArray(attribute) {
  const componentType = attribute.getComponentType();
  const srcArray = attribute.getArray();
  const dstArray = new Float32Array(srcArray.length);
  for (let i = 0; i < srcArray.length; i++) {
    dstArray[i] = decodeNormalizedInt(srcArray[i], componentType);
  }
  return dstArray;
}
function padArrayElements(srcArray, elementSize) {
  const byteStride = BufferUtils.padNumber(srcArray.BYTES_PER_ELEMENT * elementSize);
  const elementStride = byteStride / srcArray.BYTES_PER_ELEMENT;
  const elementCount = srcArray.length / elementSize;
  const dstArray = new srcArray.constructor(elementCount * elementStride);
  for (let i = 0; i * elementSize < srcArray.length; i++) {
    for (let j = 0; j < elementSize; j++) {
      dstArray[i * elementStride + j] = srcArray[i * elementSize + j];
    }
  }
  return dstArray;
}
function padNormals(srcArray) {
  const dstArray = new Float32Array(srcArray.length * 4 / 3);
  for (let i = 0, il = srcArray.length / 3; i < il; i++) {
    dstArray[i * 4] = srcArray[i * 3];
    dstArray[i * 4 + 1] = srcArray[i * 3 + 1];
    dstArray[i * 4 + 2] = srcArray[i * 3 + 2];
  }
  return dstArray;
}
function getMeshoptMode(accessor, usage) {
  if (usage === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER) {
    const isTriangles = accessor.listParents().some((parent) => {
      return parent instanceof Primitive && parent.getMode() === Primitive.Mode.TRIANGLES;
    });
    return isTriangles ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES;
  }
  return MeshoptMode.ATTRIBUTES;
}
function getMeshoptFilter(accessor, doc) {
  const refs = doc.getGraph().listParentEdges(accessor).filter((edge) => !(edge.getParent() instanceof Root));
  for (const ref of refs) {
    const refName = ref.getName();
    const refKey = ref.getAttributes().key || "";
    const isDelta = ref.getParent().propertyType === PropertyType.PRIMITIVE_TARGET;
    if (refName === "indices") return {
      filter: MeshoptFilter.NONE
    };
    if (refName === "attributes") {
      if (refKey === "POSITION") return {
        filter: MeshoptFilter.NONE
      };
      if (refKey === "TEXCOORD_0") return {
        filter: MeshoptFilter.NONE
      };
      if (refKey.startsWith("JOINTS_")) return {
        filter: MeshoptFilter.NONE
      };
      if (refKey.startsWith("WEIGHTS_")) return {
        filter: MeshoptFilter.NONE
      };
      if (refKey === "NORMAL" || refKey === "TANGENT") {
        return isDelta ? {
          filter: MeshoptFilter.NONE
        } : {
          filter: MeshoptFilter.OCTAHEDRAL,
          bits: 8
        };
      }
    }
    if (refName === "output") {
      const targetPath = getTargetPath(accessor);
      if (targetPath === "rotation") return {
        filter: MeshoptFilter.QUATERNION,
        bits: 16
      };
      if (targetPath === "translation") return {
        filter: MeshoptFilter.EXPONENTIAL,
        bits: 12
      };
      if (targetPath === "scale") return {
        filter: MeshoptFilter.EXPONENTIAL,
        bits: 12
      };
      return {
        filter: MeshoptFilter.NONE
      };
    }
    if (refName === "input") return {
      filter: MeshoptFilter.NONE
    };
    if (refName === "inverseBindMatrices") return {
      filter: MeshoptFilter.NONE
    };
  }
  return {
    filter: MeshoptFilter.NONE
  };
}
function getTargetPath(accessor) {
  for (const sampler of accessor.listParents()) {
    if (!(sampler instanceof AnimationSampler)) continue;
    for (const channel of sampler.listParents()) {
      if (!(channel instanceof AnimationChannel)) continue;
      return channel.getTargetPath();
    }
  }
  return null;
}
function unbox(data, offset) {
  if (data.byteLength < 4 + offset) return null;
  const size = data.getUint32(offset);
  if (data.byteLength < size + offset || size < 8) return null;
  return {
    type: BufferUtils.decodeText(new Uint8Array(data.buffer, data.byteOffset + offset + 4, 4)),
    start: offset + 8,
    end: offset + size
  };
}
function decodeGeometry(decoder, data) {
  const buffer = new decoderModule.DecoderBuffer();
  try {
    buffer.Init(data, data.length);
    const geometryType = decoder.GetEncodedGeometryType(buffer);
    if (geometryType !== decoderModule.TRIANGULAR_MESH) {
      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Unknown geometry type.`);
    }
    const dracoMesh = new decoderModule.Mesh();
    const status = decoder.DecodeBufferToMesh(buffer, dracoMesh);
    if (!status.ok() || dracoMesh.ptr === 0) {
      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Decoding failure.`);
    }
    return dracoMesh;
  } finally {
    decoderModule.destroy(buffer);
  }
}
function decodeIndex(decoder, mesh) {
  const numFaces = mesh.num_faces();
  const numIndices = numFaces * 3;
  let ptr;
  let indices;
  if (mesh.num_points() <= 65534) {
    const byteLength = numIndices * Uint16Array.BYTES_PER_ELEMENT;
    ptr = decoderModule._malloc(byteLength);
    decoder.GetTrianglesUInt16Array(mesh, byteLength, ptr);
    indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();
  } else {
    const byteLength = numIndices * Uint32Array.BYTES_PER_ELEMENT;
    ptr = decoderModule._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);
    indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();
  }
  decoderModule._free(ptr);
  return indices;
}
function decodeAttribute(decoder, mesh, attribute, accessorDef) {
  const dataType = DATA_TYPE[accessorDef.componentType];
  const ArrayCtor = COMPONENT_ARRAY[accessorDef.componentType];
  const numComponents = attribute.num_components();
  const numPoints = mesh.num_points();
  const numValues = numPoints * numComponents;
  const byteLength = numValues * ArrayCtor.BYTES_PER_ELEMENT;
  const ptr = decoderModule._malloc(byteLength);
  decoder.GetAttributeDataArrayForAllPoints(mesh, attribute, dataType, byteLength, ptr);
  const array = new ArrayCtor(decoderModule.HEAPF32.buffer, ptr, numValues).slice();
  decoderModule._free(ptr);
  return array;
}
function initDecoderModule(_decoderModule) {
  decoderModule = _decoderModule;
  COMPONENT_ARRAY = {
    [Accessor.ComponentType.FLOAT]: Float32Array,
    [Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,
    [Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,
    [Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,
    [Accessor.ComponentType.SHORT]: Int16Array,
    [Accessor.ComponentType.BYTE]: Int8Array
  };
  DATA_TYPE = {
    [Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,
    [Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,
    [Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,
    [Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,
    [Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,
    [Accessor.ComponentType.BYTE]: decoderModule.DT_INT8
  };
}
function initEncoderModule(_encoderModule) {
  encoderModule = _encoderModule;
}
function encodeGeometry(prim, _options = DEFAULT_ENCODER_OPTIONS) {
  const options = _extends3({}, DEFAULT_ENCODER_OPTIONS, _options);
  options.quantizationBits = _extends3({}, DEFAULT_QUANTIZATION_BITS, _options.quantizationBits);
  const builder = new encoderModule.MeshBuilder();
  const mesh = new encoderModule.Mesh();
  const encoder = new encoderModule.ExpertEncoder(mesh);
  const attributeIDs = {};
  const dracoBuffer = new encoderModule.DracoInt8Array();
  const hasMorphTargets = prim.listTargets().length > 0;
  let hasSparseAttributes = false;
  for (const semantic of prim.listSemantics()) {
    const attribute = prim.getAttribute(semantic);
    if (attribute.getSparse()) {
      hasSparseAttributes = true;
      continue;
    }
    const attributeEnum = getAttributeEnum(semantic);
    const attributeID = addAttribute(builder, attribute.getComponentType(), mesh, encoderModule[attributeEnum], attribute.getCount(), attribute.getElementSize(), attribute.getArray());
    if (attributeID === -1) throw new Error(`Error compressing "${semantic}" attribute.`);
    attributeIDs[semantic] = attributeID;
    if (options.quantizationVolume === "mesh" || semantic !== "POSITION") {
      encoder.SetAttributeQuantization(attributeID, options.quantizationBits[attributeEnum]);
    } else if (typeof options.quantizationVolume === "object") {
      const {
        quantizationVolume
      } = options;
      const range = Math.max(quantizationVolume.max[0] - quantizationVolume.min[0], quantizationVolume.max[1] - quantizationVolume.min[1], quantizationVolume.max[2] - quantizationVolume.min[2]);
      encoder.SetAttributeExplicitQuantization(attributeID, options.quantizationBits[attributeEnum], attribute.getElementSize(), quantizationVolume.min, range);
    } else {
      throw new Error("Invalid quantization volume state.");
    }
  }
  const indices = prim.getIndices();
  if (!indices) throw new EncodingError("Primitive must have indices.");
  builder.AddFacesToMesh(mesh, indices.getCount() / 3, indices.getArray());
  encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);
  encoder.SetTrackEncodedProperties(true);
  if (options.method === EncoderMethod.SEQUENTIAL || hasMorphTargets || hasSparseAttributes) {
    encoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);
  } else {
    encoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);
  }
  const byteLength = encoder.EncodeToDracoBuffer(!(hasMorphTargets || hasSparseAttributes), dracoBuffer);
  if (byteLength <= 0) throw new EncodingError("Error applying Draco compression.");
  const data = new Uint8Array(byteLength);
  for (let i = 0; i < byteLength; ++i) {
    data[i] = dracoBuffer.GetValue(i);
  }
  const numVertices = encoder.GetNumberOfEncodedPoints();
  const numIndices = encoder.GetNumberOfEncodedFaces() * 3;
  encoderModule.destroy(dracoBuffer);
  encoderModule.destroy(mesh);
  encoderModule.destroy(builder);
  encoderModule.destroy(encoder);
  return {
    numVertices,
    numIndices,
    data,
    attributeIDs
  };
}
function getAttributeEnum(semantic) {
  if (semantic === "POSITION") {
    return AttributeEnum.POSITION;
  } else if (semantic === "NORMAL") {
    return AttributeEnum.NORMAL;
  } else if (semantic.startsWith("COLOR_")) {
    return AttributeEnum.COLOR;
  } else if (semantic.startsWith("TEXCOORD_")) {
    return AttributeEnum.TEX_COORD;
  }
  return AttributeEnum.GENERIC;
}
function addAttribute(builder, componentType, mesh, attribute, count, itemSize, array) {
  switch (componentType) {
    case Accessor.ComponentType.UNSIGNED_BYTE:
      return builder.AddUInt8Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.BYTE:
      return builder.AddInt8Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.UNSIGNED_SHORT:
      return builder.AddUInt16Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.SHORT:
      return builder.AddInt16Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.UNSIGNED_INT:
      return builder.AddUInt32Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.FLOAT:
      return builder.AddFloatAttribute(mesh, attribute, count, itemSize, array);
    default:
      throw new Error(`Unexpected component type, "${componentType}".`);
  }
}
function listDracoPrimitives(doc) {
  const logger = doc.getLogger();
  const included = /* @__PURE__ */ new Set();
  const excluded = /* @__PURE__ */ new Set();
  let nonIndexed = 0;
  let nonTriangles = 0;
  for (const mesh of doc.getRoot().listMeshes()) {
    for (const prim of mesh.listPrimitives()) {
      if (!prim.getIndices()) {
        excluded.add(prim);
        nonIndexed++;
      } else if (prim.getMode() !== Primitive.Mode.TRIANGLES) {
        excluded.add(prim);
        nonTriangles++;
      } else {
        included.add(prim);
      }
    }
  }
  if (nonIndexed > 0) {
    logger.warn(`[${KHR_DRACO_MESH_COMPRESSION}] Skipping Draco compression of ${nonIndexed} non-indexed primitives.`);
  }
  if (nonTriangles > 0) {
    logger.warn(`[${KHR_DRACO_MESH_COMPRESSION}] Skipping Draco compression of ${nonTriangles} non-TRIANGLES primitives.`);
  }
  const accessors = doc.getRoot().listAccessors();
  const accessorIndices = /* @__PURE__ */ new Map();
  for (let i = 0; i < accessors.length; i++) accessorIndices.set(accessors[i], i);
  const includedAccessors = /* @__PURE__ */ new Map();
  const includedHashKeys = /* @__PURE__ */ new Set();
  const primToHashKey = /* @__PURE__ */ new Map();
  for (const prim of Array.from(included)) {
    let hashKey = createHashKey(prim, accessorIndices);
    if (includedHashKeys.has(hashKey)) {
      primToHashKey.set(prim, hashKey);
      continue;
    }
    if (includedAccessors.has(prim.getIndices())) {
      const indices = prim.getIndices();
      const dstIndices = indices.clone();
      accessorIndices.set(dstIndices, doc.getRoot().listAccessors().length - 1);
      prim.swap(indices, dstIndices);
    }
    for (const attribute of prim.listAttributes()) {
      if (includedAccessors.has(attribute)) {
        const dstAttribute = attribute.clone();
        accessorIndices.set(dstAttribute, doc.getRoot().listAccessors().length - 1);
        prim.swap(attribute, dstAttribute);
      }
    }
    hashKey = createHashKey(prim, accessorIndices);
    includedHashKeys.add(hashKey);
    primToHashKey.set(prim, hashKey);
    includedAccessors.set(prim.getIndices(), hashKey);
    for (const attribute of prim.listAttributes()) {
      includedAccessors.set(attribute, hashKey);
    }
  }
  for (const accessor of Array.from(includedAccessors.keys())) {
    const parentTypes = new Set(accessor.listParents().map((prop) => prop.propertyType));
    if (parentTypes.size !== 2 || !parentTypes.has(PropertyType.PRIMITIVE) || !parentTypes.has(PropertyType.ROOT)) {
      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Compressed accessors must only be used as indices or vertex attributes.`);
    }
  }
  for (const prim of Array.from(included)) {
    const hashKey = primToHashKey.get(prim);
    const indices = prim.getIndices();
    if (includedAccessors.get(indices) !== hashKey || prim.listAttributes().some((attr) => includedAccessors.get(attr) !== hashKey)) {
      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Draco primitives must share all, or no, accessors.`);
    }
  }
  for (const prim of Array.from(excluded)) {
    const indices = prim.getIndices();
    if (includedAccessors.has(indices) || prim.listAttributes().some((attr) => includedAccessors.has(attr))) {
      throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Accessor cannot be shared by compressed and uncompressed primitives.`);
    }
  }
  return primToHashKey;
}
function createHashKey(prim, indexMap) {
  const hashElements = [];
  const indices = prim.getIndices();
  hashElements.push(indexMap.get(indices));
  for (const attribute of prim.listAttributes()) {
    hashElements.push(indexMap.get(attribute));
  }
  return hashElements.sort().join("|");
}
function copyJSON(object) {
  return JSON.parse(JSON.stringify(object));
}
var EXT_MESH_GPU_INSTANCING, EXT_MESHOPT_COMPRESSION, EXT_TEXTURE_WEBP, EXT_TEXTURE_AVIF, KHR_DRACO_MESH_COMPRESSION, KHR_LIGHTS_PUNCTUAL, KHR_MATERIALS_ANISOTROPY, KHR_MATERIALS_CLEARCOAT, KHR_MATERIALS_DIFFUSE_TRANSMISSION, KHR_MATERIALS_DISPERSION, KHR_MATERIALS_EMISSIVE_STRENGTH, KHR_MATERIALS_IOR, KHR_MATERIALS_IRIDESCENCE, KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, KHR_MATERIALS_SHEEN, KHR_MATERIALS_SPECULAR, KHR_MATERIALS_TRANSMISSION, KHR_MATERIALS_UNLIT, KHR_MATERIALS_VOLUME, KHR_MATERIALS_VARIANTS, KHR_MESH_QUANTIZATION, KHR_TEXTURE_BASISU, KHR_TEXTURE_TRANSFORM, KHR_XMP_JSON_LD, INSTANCE_ATTRIBUTE, InstancedMesh, EXTMeshGPUInstancing, EncoderMethod$1, MeshoptMode, MeshoptFilter, BYTE, SHORT, FLOAT, encodeNormalizedInt, decodeNormalizedInt, DEFAULT_ENCODER_OPTIONS$1, EXTMeshoptCompression, AVIFImageUtils, EXTTextureAVIF, WEBPImageUtils, EXTTextureWebP, decoderModule, COMPONENT_ARRAY, DATA_TYPE, encoderModule, EncoderMethod, AttributeEnum, DEFAULT_QUANTIZATION_BITS, DEFAULT_ENCODER_OPTIONS, EncodingError, KHRDracoMeshCompression, Light, KHRLightsPunctual, R$7, G$7, B$5, Anisotropy, KHRMaterialsAnisotropy, R$6, G$6, B$4, Clearcoat, KHRMaterialsClearcoat, R$5, G$5, B$3, A$3, DiffuseTransmission, KHRMaterialsDiffuseTransmission, Dispersion, KHRMaterialsDispersion, EmissiveStrength, KHRMaterialsEmissiveStrength, IOR, KHRMaterialsIOR, R$4, G$4, Iridescence, KHRMaterialsIridescence, R$3, G$3, B$2, A$2, PBRSpecularGlossiness, KHRMaterialsPBRSpecularGlossiness, R$2, G$2, B$1, A$1, Sheen, KHRMaterialsSheen, R$1, G$1, B2, A2, Specular, KHRMaterialsSpecular, R2, Transmission, KHRMaterialsTransmission, Unlit, KHRMaterialsUnlit, Mapping, MappingList, Variant, KHRMaterialsVariants, G2, Volume, KHRMaterialsVolume, KHRMeshQuantization, KTX2ImageUtils, KHRTextureBasisu, Transform, KHRTextureTransform, PARENT_TYPES, Packet, KHRXMP, KHRONOS_EXTENSIONS, ALL_EXTENSIONS;
var init_index_modern2 = __esm({
  "node_modules/@gltf-transform/extensions/dist/index.modern.js"() {
    init_index_modern();
    init_ktx_parse_modern();
    EXT_MESH_GPU_INSTANCING = "EXT_mesh_gpu_instancing";
    EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
    EXT_TEXTURE_WEBP = "EXT_texture_webp";
    EXT_TEXTURE_AVIF = "EXT_texture_avif";
    KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
    KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
    KHR_MATERIALS_ANISOTROPY = "KHR_materials_anisotropy";
    KHR_MATERIALS_CLEARCOAT = "KHR_materials_clearcoat";
    KHR_MATERIALS_DIFFUSE_TRANSMISSION = "KHR_materials_diffuse_transmission";
    KHR_MATERIALS_DISPERSION = "KHR_materials_dispersion";
    KHR_MATERIALS_EMISSIVE_STRENGTH = "KHR_materials_emissive_strength";
    KHR_MATERIALS_IOR = "KHR_materials_ior";
    KHR_MATERIALS_IRIDESCENCE = "KHR_materials_iridescence";
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = "KHR_materials_pbrSpecularGlossiness";
    KHR_MATERIALS_SHEEN = "KHR_materials_sheen";
    KHR_MATERIALS_SPECULAR = "KHR_materials_specular";
    KHR_MATERIALS_TRANSMISSION = "KHR_materials_transmission";
    KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
    KHR_MATERIALS_VOLUME = "KHR_materials_volume";
    KHR_MATERIALS_VARIANTS = "KHR_materials_variants";
    KHR_MESH_QUANTIZATION = "KHR_mesh_quantization";
    KHR_TEXTURE_BASISU = "KHR_texture_basisu";
    KHR_TEXTURE_TRANSFORM = "KHR_texture_transform";
    KHR_XMP_JSON_LD = "KHR_xmp_json_ld";
    INSTANCE_ATTRIBUTE = "INSTANCE_ATTRIBUTE";
    InstancedMesh = class extends ExtensionProperty {
      init() {
        this.extensionName = EXT_MESH_GPU_INSTANCING;
        this.propertyType = "InstancedMesh";
        this.parentTypes = [PropertyType.NODE];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          attributes: new RefMap()
        });
      }
      /** Returns an instance attribute as an {@link Accessor}. */
      getAttribute(semantic) {
        return this.getRefMap("attributes", semantic);
      }
      /**
       * Sets an instance attribute to an {@link Accessor}. All attributes must have the same
       * instance count.
       */
      setAttribute(semantic, accessor) {
        return this.setRefMap("attributes", semantic, accessor, {
          usage: INSTANCE_ATTRIBUTE
        });
      }
      /**
       * Lists all instance attributes {@link Accessor}s associated with the InstancedMesh. Order
       * will be consistent with the order returned by {@link .listSemantics}().
       */
      listAttributes() {
        return this.listRefMapValues("attributes");
      }
      /**
       * Lists all instance attribute semantics associated with the primitive. Order will be
       * consistent with the order returned by {@link .listAttributes}().
       */
      listSemantics() {
        return this.listRefMapKeys("attributes");
      }
    };
    InstancedMesh.EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;
    EXTMeshGPUInstancing = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = EXT_MESH_GPU_INSTANCING;
        this.provideTypes = [PropertyType.NODE];
        this.prewriteTypes = [PropertyType.ACCESSOR];
      }
      /** Creates a new InstancedMesh property for use on a {@link Node}. */
      createInstancedMesh() {
        return new InstancedMesh(this.document.getGraph());
      }
      /** @hidden */
      read(context) {
        const jsonDoc = context.jsonDoc;
        const nodeDefs = jsonDoc.json.nodes || [];
        nodeDefs.forEach((nodeDef, nodeIndex) => {
          if (!nodeDef.extensions || !nodeDef.extensions[EXT_MESH_GPU_INSTANCING]) return;
          const instancedMeshDef = nodeDef.extensions[EXT_MESH_GPU_INSTANCING];
          const instancedMesh = this.createInstancedMesh();
          for (const semantic in instancedMeshDef.attributes) {
            instancedMesh.setAttribute(semantic, context.accessors[instancedMeshDef.attributes[semantic]]);
          }
          context.nodes[nodeIndex].setExtension(EXT_MESH_GPU_INSTANCING, instancedMesh);
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        context.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);
        for (const prop of this.properties) {
          for (const attribute of prop.listAttributes()) {
            context.addAccessorToUsageGroup(attribute, INSTANCE_ATTRIBUTE);
          }
        }
        return this;
      }
      /** @hidden */
      write(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listNodes().forEach((node) => {
          const instancedMesh = node.getExtension(EXT_MESH_GPU_INSTANCING);
          if (instancedMesh) {
            const nodeIndex = context.nodeIndexMap.get(node);
            const nodeDef = jsonDoc.json.nodes[nodeIndex];
            const instancedMeshDef = {
              attributes: {}
            };
            instancedMesh.listSemantics().forEach((semantic) => {
              const attribute = instancedMesh.getAttribute(semantic);
              instancedMeshDef.attributes[semantic] = context.accessorIndexMap.get(attribute);
            });
            nodeDef.extensions = nodeDef.extensions || {};
            nodeDef.extensions[EXT_MESH_GPU_INSTANCING] = instancedMeshDef;
          }
        });
        return this;
      }
    };
    EXTMeshGPUInstancing.EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;
    (function(EncoderMethod2) {
      EncoderMethod2["QUANTIZE"] = "quantize";
      EncoderMethod2["FILTER"] = "filter";
    })(EncoderMethod$1 || (EncoderMethod$1 = {}));
    (function(MeshoptMode2) {
      MeshoptMode2["ATTRIBUTES"] = "ATTRIBUTES";
      MeshoptMode2["TRIANGLES"] = "TRIANGLES";
      MeshoptMode2["INDICES"] = "INDICES";
    })(MeshoptMode || (MeshoptMode = {}));
    (function(MeshoptFilter2) {
      MeshoptFilter2["NONE"] = "NONE";
      MeshoptFilter2["OCTAHEDRAL"] = "OCTAHEDRAL";
      MeshoptFilter2["QUATERNION"] = "QUATERNION";
      MeshoptFilter2["EXPONENTIAL"] = "EXPONENTIAL";
    })(MeshoptFilter || (MeshoptFilter = {}));
    ({
      BYTE,
      SHORT,
      FLOAT
    } = Accessor.ComponentType);
    ({
      encodeNormalizedInt,
      decodeNormalizedInt
    } = MathUtils);
    DEFAULT_ENCODER_OPTIONS$1 = {
      method: EncoderMethod$1.QUANTIZE
    };
    EXTMeshoptCompression = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = EXT_MESHOPT_COMPRESSION;
        this.prereadTypes = [PropertyType.BUFFER, PropertyType.PRIMITIVE];
        this.prewriteTypes = [PropertyType.BUFFER, PropertyType.ACCESSOR];
        this.readDependencies = ["meshopt.decoder"];
        this.writeDependencies = ["meshopt.encoder"];
        this._decoder = null;
        this._decoderFallbackBufferMap = /* @__PURE__ */ new Map();
        this._encoder = null;
        this._encoderOptions = DEFAULT_ENCODER_OPTIONS$1;
        this._encoderFallbackBuffer = null;
        this._encoderBufferViews = {};
        this._encoderBufferViewData = {};
        this._encoderBufferViewAccessors = {};
      }
      /** @hidden */
      install(key, dependency) {
        if (key === "meshopt.decoder") {
          this._decoder = dependency;
        }
        if (key === "meshopt.encoder") {
          this._encoder = dependency;
        }
        return this;
      }
      /**
       * Configures Meshopt options for quality/compression tuning. The two methods rely on different
       * pre-processing before compression, and should be compared on the basis of (a) quality/loss
       * and (b) final asset size after _also_ applying a lossless compression such as gzip or brotli.
       *
       * - QUANTIZE: Default. Pre-process with {@link quantize quantize()} (lossy to specified
       * 	precision) before applying lossless Meshopt compression. Offers a considerable compression
       * 	ratio with or without further supercompression. Equivalent to `gltfpack -c`.
       * - FILTER: Pre-process with lossy filters to improve compression, before applying lossless
       *	Meshopt compression. While output may initially be larger than with the QUANTIZE method,
       *	this method will benefit more from supercompression (e.g. gzip or brotli). Equivalent to
       * 	`gltfpack -cc`.
       *
       * Output with the FILTER method will generally be smaller after supercompression (e.g. gzip or
       * brotli) is applied, but may be larger than QUANTIZE output without it. Decoding is very fast
       * with both methods.
       *
       * Example:
       *
       * ```ts
       * import { EXTMeshoptCompression } from '@gltf-transform/extensions';
       *
       * doc.createExtension(EXTMeshoptCompression)
       * 	.setRequired(true)
       * 	.setEncoderOptions({
       * 		method: EXTMeshoptCompression.EncoderMethod.QUANTIZE
       * 	});
       * ```
       */
      setEncoderOptions(options) {
        this._encoderOptions = _extends3({}, DEFAULT_ENCODER_OPTIONS$1, options);
        return this;
      }
      /**********************************************************************************************
       * Decoding.
       */
      /** @internal Checks preconditions, decodes buffer views, and creates decoded primitives. */
      preread(context, propertyType) {
        if (!this._decoder) {
          if (!this.isRequired()) return this;
          throw new Error(`[${EXT_MESHOPT_COMPRESSION}] Please install extension dependency, "meshopt.decoder".`);
        }
        if (!this._decoder.supported) {
          if (!this.isRequired()) return this;
          throw new Error(`[${EXT_MESHOPT_COMPRESSION}]: Missing WASM support.`);
        }
        if (propertyType === PropertyType.BUFFER) {
          this._prereadBuffers(context);
        } else if (propertyType === PropertyType.PRIMITIVE) {
          this._prereadPrimitives(context);
        }
        return this;
      }
      /** @internal Decode buffer views. */
      _prereadBuffers(context) {
        const jsonDoc = context.jsonDoc;
        const viewDefs = jsonDoc.json.bufferViews || [];
        viewDefs.forEach((viewDef, index) => {
          if (!viewDef.extensions || !viewDef.extensions[EXT_MESHOPT_COMPRESSION]) return;
          const meshoptDef = viewDef.extensions[EXT_MESHOPT_COMPRESSION];
          const byteOffset = meshoptDef.byteOffset || 0;
          const byteLength = meshoptDef.byteLength || 0;
          const count = meshoptDef.count;
          const stride = meshoptDef.byteStride;
          const result = new Uint8Array(count * stride);
          const bufferDef = jsonDoc.json.buffers[meshoptDef.buffer];
          const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];
          const source = BufferUtils.toView(resource, byteOffset, byteLength);
          this._decoder.decodeGltfBuffer(result, count, stride, source, meshoptDef.mode, meshoptDef.filter);
          context.bufferViews[index] = result;
        });
      }
      /**
       * Mark fallback buffers and replacements.
       *
       * Note: Alignment with primitives is arbitrary; this just needs to happen
       * after Buffers have been parsed.
       * @internal
       */
      _prereadPrimitives(context) {
        const jsonDoc = context.jsonDoc;
        const viewDefs = jsonDoc.json.bufferViews || [];
        viewDefs.forEach((viewDef) => {
          if (!viewDef.extensions || !viewDef.extensions[EXT_MESHOPT_COMPRESSION]) return;
          const meshoptDef = viewDef.extensions[EXT_MESHOPT_COMPRESSION];
          const buffer = context.buffers[meshoptDef.buffer];
          const fallbackBuffer = context.buffers[viewDef.buffer];
          const fallbackBufferDef = jsonDoc.json.buffers[viewDef.buffer];
          if (isFallbackBuffer(fallbackBufferDef)) {
            this._decoderFallbackBufferMap.set(fallbackBuffer, buffer);
          }
        });
      }
      /** @hidden Removes Fallback buffers, if extension is required. */
      read(_context) {
        if (!this.isRequired()) return this;
        for (const [fallbackBuffer, buffer] of this._decoderFallbackBufferMap) {
          for (const parent of fallbackBuffer.listParents()) {
            if (parent instanceof Accessor) {
              parent.swap(fallbackBuffer, buffer);
            }
          }
          fallbackBuffer.dispose();
        }
        return this;
      }
      /**********************************************************************************************
       * Encoding.
       */
      /** @internal Claims accessors that can be compressed and writes compressed buffer views. */
      prewrite(context, propertyType) {
        if (propertyType === PropertyType.ACCESSOR) {
          this._prewriteAccessors(context);
        } else if (propertyType === PropertyType.BUFFER) {
          this._prewriteBuffers(context);
        }
        return this;
      }
      /** @internal Claims accessors that can be compressed. */
      _prewriteAccessors(context) {
        const json = context.jsonDoc.json;
        const encoder = this._encoder;
        const options = this._encoderOptions;
        const graph = this.document.getGraph();
        const fallbackBuffer = this.document.createBuffer();
        const fallbackBufferIndex = this.document.getRoot().listBuffers().indexOf(fallbackBuffer);
        let nextID = 1;
        const parentToID = /* @__PURE__ */ new Map();
        const getParentID = (property) => {
          for (const parent of graph.listParents(property)) {
            if (parent.propertyType === PropertyType.ROOT) continue;
            let id = parentToID.get(property);
            if (id === void 0) parentToID.set(property, id = nextID++);
            return id;
          }
          return -1;
        };
        this._encoderFallbackBuffer = fallbackBuffer;
        this._encoderBufferViews = {};
        this._encoderBufferViewData = {};
        this._encoderBufferViewAccessors = {};
        for (const accessor of this.document.getRoot().listAccessors()) {
          if (getTargetPath(accessor) === "weights") continue;
          if (accessor.getSparse()) continue;
          const usage = context.getAccessorUsage(accessor);
          const parentID = context.accessorUsageGroupedByParent.has(usage) ? getParentID(accessor) : null;
          const mode = getMeshoptMode(accessor, usage);
          const filter = options.method === EncoderMethod$1.FILTER ? getMeshoptFilter(accessor, this.document) : {
            filter: MeshoptFilter.NONE
          };
          const preparedAccessor = prepareAccessor(accessor, encoder, mode, filter);
          const {
            array,
            byteStride
          } = preparedAccessor;
          const buffer = accessor.getBuffer();
          if (!buffer) throw new Error(`${EXT_MESHOPT_COMPRESSION}: Missing buffer for accessor.`);
          const bufferIndex = this.document.getRoot().listBuffers().indexOf(buffer);
          const key = [usage, parentID, mode, filter.filter, byteStride, bufferIndex].join(":");
          let bufferView = this._encoderBufferViews[key];
          let bufferViewData = this._encoderBufferViewData[key];
          let bufferViewAccessors = this._encoderBufferViewAccessors[key];
          if (!bufferView || !bufferViewData) {
            bufferViewAccessors = this._encoderBufferViewAccessors[key] = [];
            bufferViewData = this._encoderBufferViewData[key] = [];
            bufferView = this._encoderBufferViews[key] = {
              buffer: fallbackBufferIndex,
              target: WriterContext.USAGE_TO_TARGET[usage],
              byteOffset: 0,
              byteLength: 0,
              byteStride: usage === WriterContext.BufferViewUsage.ARRAY_BUFFER ? byteStride : void 0,
              extensions: {
                [EXT_MESHOPT_COMPRESSION]: {
                  buffer: bufferIndex,
                  byteOffset: 0,
                  byteLength: 0,
                  mode,
                  filter: filter.filter !== MeshoptFilter.NONE ? filter.filter : void 0,
                  byteStride,
                  count: 0
                }
              }
            };
          }
          const accessorDef = context.createAccessorDef(accessor);
          accessorDef.componentType = preparedAccessor.componentType;
          accessorDef.normalized = preparedAccessor.normalized;
          accessorDef.byteOffset = bufferView.byteLength;
          if (accessorDef.min && preparedAccessor.min) accessorDef.min = preparedAccessor.min;
          if (accessorDef.max && preparedAccessor.max) accessorDef.max = preparedAccessor.max;
          context.accessorIndexMap.set(accessor, json.accessors.length);
          json.accessors.push(accessorDef);
          bufferViewAccessors.push(accessorDef);
          bufferViewData.push(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));
          bufferView.byteLength += array.byteLength;
          bufferView.extensions.EXT_meshopt_compression.count += accessor.getCount();
        }
      }
      /** @internal Writes compressed buffer views. */
      _prewriteBuffers(context) {
        const encoder = this._encoder;
        for (const key in this._encoderBufferViews) {
          const bufferView = this._encoderBufferViews[key];
          const bufferViewData = this._encoderBufferViewData[key];
          const buffer = this.document.getRoot().listBuffers()[bufferView.extensions[EXT_MESHOPT_COMPRESSION].buffer];
          const otherBufferViews = context.otherBufferViews.get(buffer) || [];
          const {
            count,
            byteStride,
            mode
          } = bufferView.extensions[EXT_MESHOPT_COMPRESSION];
          const srcArray = BufferUtils.concat(bufferViewData);
          const dstArray = encoder.encodeGltfBuffer(srcArray, count, byteStride, mode);
          const compressedData = BufferUtils.pad(dstArray);
          bufferView.extensions[EXT_MESHOPT_COMPRESSION].byteLength = dstArray.byteLength;
          bufferViewData.length = 0;
          bufferViewData.push(compressedData);
          otherBufferViews.push(compressedData);
          context.otherBufferViews.set(buffer, otherBufferViews);
        }
      }
      /** @hidden Puts encoded data into glTF output. */
      write(context) {
        let fallbackBufferByteOffset = 0;
        for (const key in this._encoderBufferViews) {
          const bufferView = this._encoderBufferViews[key];
          const bufferViewData = this._encoderBufferViewData[key][0];
          const bufferViewIndex = context.otherBufferViewsIndexMap.get(bufferViewData);
          const bufferViewAccessors = this._encoderBufferViewAccessors[key];
          for (const accessorDef of bufferViewAccessors) {
            accessorDef.bufferView = bufferViewIndex;
          }
          const finalBufferViewDef = context.jsonDoc.json.bufferViews[bufferViewIndex];
          const compressedByteOffset = finalBufferViewDef.byteOffset || 0;
          Object.assign(finalBufferViewDef, bufferView);
          finalBufferViewDef.byteOffset = fallbackBufferByteOffset;
          const bufferViewExtensionDef = finalBufferViewDef.extensions[EXT_MESHOPT_COMPRESSION];
          bufferViewExtensionDef.byteOffset = compressedByteOffset;
          fallbackBufferByteOffset += BufferUtils.padNumber(bufferView.byteLength);
        }
        const fallbackBuffer = this._encoderFallbackBuffer;
        const fallbackBufferIndex = context.bufferIndexMap.get(fallbackBuffer);
        const fallbackBufferDef = context.jsonDoc.json.buffers[fallbackBufferIndex];
        fallbackBufferDef.byteLength = fallbackBufferByteOffset;
        fallbackBufferDef.extensions = {
          [EXT_MESHOPT_COMPRESSION]: {
            fallback: true
          }
        };
        fallbackBuffer.dispose();
        return this;
      }
    };
    EXTMeshoptCompression.EXTENSION_NAME = EXT_MESHOPT_COMPRESSION;
    EXTMeshoptCompression.EncoderMethod = EncoderMethod$1;
    AVIFImageUtils = class {
      match(array) {
        return array.length >= 12 && BufferUtils.decodeText(array.slice(4, 12)) === "ftypavif";
      }
      /**
       * Probes size of AVIF or HEIC image. Assumes a single static image, without
       * orientation or other metadata that would affect dimensions.
       */
      getSize(array) {
        if (!this.match(array)) return null;
        const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        let box = unbox(view, 0);
        if (!box) return null;
        let offset = box.end;
        while (box = unbox(view, offset)) {
          if (box.type === "meta") {
            offset = box.start + 4;
          } else if (box.type === "iprp" || box.type === "ipco") {
            offset = box.start;
          } else if (box.type === "ispe") {
            return [view.getUint32(box.start + 4), view.getUint32(box.start + 8)];
          } else if (box.type === "mdat") {
            break;
          } else {
            offset = box.end;
          }
        }
        return null;
      }
      getChannels(_buffer) {
        return 4;
      }
    };
    EXTTextureAVIF = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = EXT_TEXTURE_AVIF;
        this.prereadTypes = [PropertyType.TEXTURE];
      }
      /** @hidden */
      static register() {
        ImageUtils.registerFormat("image/avif", new AVIFImageUtils());
      }
      /** @hidden */
      preread(context) {
        const textureDefs = context.jsonDoc.json.textures || [];
        textureDefs.forEach((textureDef) => {
          if (textureDef.extensions && textureDef.extensions[EXT_TEXTURE_AVIF]) {
            textureDef.source = textureDef.extensions[EXT_TEXTURE_AVIF].source;
          }
        });
        return this;
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listTextures().forEach((texture) => {
          if (texture.getMimeType() === "image/avif") {
            const imageIndex = context.imageIndexMap.get(texture);
            const textureDefs = jsonDoc.json.textures || [];
            textureDefs.forEach((textureDef) => {
              if (textureDef.source === imageIndex) {
                textureDef.extensions = textureDef.extensions || {};
                textureDef.extensions[EXT_TEXTURE_AVIF] = {
                  source: textureDef.source
                };
                delete textureDef.source;
              }
            });
          }
        });
        return this;
      }
    };
    EXTTextureAVIF.EXTENSION_NAME = EXT_TEXTURE_AVIF;
    WEBPImageUtils = class {
      match(array) {
        return array.length >= 12 && array[8] === 87 && array[9] === 69 && array[10] === 66 && array[11] === 80;
      }
      getSize(array) {
        const RIFF = BufferUtils.decodeText(array.slice(0, 4));
        const WEBP = BufferUtils.decodeText(array.slice(8, 12));
        if (RIFF !== "RIFF" || WEBP !== "WEBP") return null;
        const view = new DataView(array.buffer, array.byteOffset);
        let offset = 12;
        while (offset < view.byteLength) {
          const chunkId = BufferUtils.decodeText(new Uint8Array([view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3)]));
          const chunkByteLength = view.getUint32(offset + 4, true);
          if (chunkId === "VP8 ") {
            const width = view.getInt16(offset + 14, true) & 16383;
            const height = view.getInt16(offset + 16, true) & 16383;
            return [width, height];
          } else if (chunkId === "VP8L") {
            const b0 = view.getUint8(offset + 9);
            const b1 = view.getUint8(offset + 10);
            const b2 = view.getUint8(offset + 11);
            const b3 = view.getUint8(offset + 12);
            const width = 1 + ((b1 & 63) << 8 | b0);
            const height = 1 + ((b3 & 15) << 10 | b2 << 2 | (b1 & 192) >> 6);
            return [width, height];
          }
          offset += 8 + chunkByteLength + chunkByteLength % 2;
        }
        return null;
      }
      getChannels(_buffer) {
        return 4;
      }
    };
    EXTTextureWebP = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = EXT_TEXTURE_WEBP;
        this.prereadTypes = [PropertyType.TEXTURE];
      }
      /** @hidden */
      static register() {
        ImageUtils.registerFormat("image/webp", new WEBPImageUtils());
      }
      /** @hidden */
      preread(context) {
        const textureDefs = context.jsonDoc.json.textures || [];
        textureDefs.forEach((textureDef) => {
          if (textureDef.extensions && textureDef.extensions[EXT_TEXTURE_WEBP]) {
            textureDef.source = textureDef.extensions[EXT_TEXTURE_WEBP].source;
          }
        });
        return this;
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listTextures().forEach((texture) => {
          if (texture.getMimeType() === "image/webp") {
            const imageIndex = context.imageIndexMap.get(texture);
            const textureDefs = jsonDoc.json.textures || [];
            textureDefs.forEach((textureDef) => {
              if (textureDef.source === imageIndex) {
                textureDef.extensions = textureDef.extensions || {};
                textureDef.extensions[EXT_TEXTURE_WEBP] = {
                  source: textureDef.source
                };
                delete textureDef.source;
              }
            });
          }
        });
        return this;
      }
    };
    EXTTextureWebP.EXTENSION_NAME = EXT_TEXTURE_WEBP;
    (function(EncoderMethod2) {
      EncoderMethod2[EncoderMethod2["EDGEBREAKER"] = 1] = "EDGEBREAKER";
      EncoderMethod2[EncoderMethod2["SEQUENTIAL"] = 0] = "SEQUENTIAL";
    })(EncoderMethod || (EncoderMethod = {}));
    (function(AttributeEnum2) {
      AttributeEnum2["POSITION"] = "POSITION";
      AttributeEnum2["NORMAL"] = "NORMAL";
      AttributeEnum2["COLOR"] = "COLOR";
      AttributeEnum2["TEX_COORD"] = "TEX_COORD";
      AttributeEnum2["GENERIC"] = "GENERIC";
    })(AttributeEnum || (AttributeEnum = {}));
    DEFAULT_QUANTIZATION_BITS = {
      [AttributeEnum.POSITION]: 14,
      [AttributeEnum.NORMAL]: 10,
      [AttributeEnum.COLOR]: 8,
      [AttributeEnum.TEX_COORD]: 12,
      [AttributeEnum.GENERIC]: 12
    };
    DEFAULT_ENCODER_OPTIONS = {
      decodeSpeed: 5,
      encodeSpeed: 5,
      method: EncoderMethod.EDGEBREAKER,
      quantizationBits: DEFAULT_QUANTIZATION_BITS,
      quantizationVolume: "mesh"
    };
    EncodingError = class extends Error {
    };
    KHRDracoMeshCompression = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_DRACO_MESH_COMPRESSION;
        this.prereadTypes = [PropertyType.PRIMITIVE];
        this.prewriteTypes = [PropertyType.ACCESSOR];
        this.readDependencies = ["draco3d.decoder"];
        this.writeDependencies = ["draco3d.encoder"];
        this._decoderModule = null;
        this._encoderModule = null;
        this._encoderOptions = {};
      }
      /** @hidden */
      install(key, dependency) {
        if (key === "draco3d.decoder") {
          this._decoderModule = dependency;
          initDecoderModule(this._decoderModule);
        }
        if (key === "draco3d.encoder") {
          this._encoderModule = dependency;
          initEncoderModule(this._encoderModule);
        }
        return this;
      }
      /**
       * Sets Draco compression options. Compression does not take effect until the Document is
       * written with an I/O class.
       *
       * Defaults:
       * ```
       * decodeSpeed?: number = 5;
       * encodeSpeed?: number = 5;
       * method?: EncoderMethod = EncoderMethod.EDGEBREAKER;
       * quantizationBits?: {[ATTRIBUTE_NAME]: bits};
       * quantizationVolume?: 'mesh' | 'scene' | bbox = 'mesh';
       * ```
       */
      setEncoderOptions(options) {
        this._encoderOptions = options;
        return this;
      }
      /** @hidden */
      preread(context) {
        if (!this._decoderModule) {
          throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Please install extension dependency, "draco3d.decoder".`);
        }
        const logger = this.document.getLogger();
        const jsonDoc = context.jsonDoc;
        const dracoMeshes = /* @__PURE__ */ new Map();
        try {
          const meshDefs = jsonDoc.json.meshes || [];
          for (const meshDef of meshDefs) {
            for (const primDef of meshDef.primitives) {
              if (!primDef.extensions || !primDef.extensions[KHR_DRACO_MESH_COMPRESSION]) continue;
              const dracoDef = primDef.extensions[KHR_DRACO_MESH_COMPRESSION];
              let [decoder, dracoMesh] = dracoMeshes.get(dracoDef.bufferView) || [];
              if (!dracoMesh || !decoder) {
                const bufferViewDef = jsonDoc.json.bufferViews[dracoDef.bufferView];
                const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];
                const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];
                const byteOffset = bufferViewDef.byteOffset || 0;
                const byteLength = bufferViewDef.byteLength;
                const compressedData = BufferUtils.toView(resource, byteOffset, byteLength);
                decoder = new this._decoderModule.Decoder();
                dracoMesh = decodeGeometry(decoder, compressedData);
                dracoMeshes.set(dracoDef.bufferView, [decoder, dracoMesh]);
                logger.debug(`[${KHR_DRACO_MESH_COMPRESSION}] Decompressed ${compressedData.byteLength} bytes.`);
              }
              for (const semantic in dracoDef.attributes) {
                const accessorDef = context.jsonDoc.json.accessors[primDef.attributes[semantic]];
                const dracoAttribute = decoder.GetAttributeByUniqueId(dracoMesh, dracoDef.attributes[semantic]);
                const attributeArray = decodeAttribute(decoder, dracoMesh, dracoAttribute, accessorDef);
                context.accessors[primDef.attributes[semantic]].setArray(attributeArray);
              }
              if (primDef.indices !== void 0) {
                context.accessors[primDef.indices].setArray(decodeIndex(decoder, dracoMesh));
              }
            }
          }
        } finally {
          for (const [decoder, dracoMesh] of Array.from(dracoMeshes.values())) {
            this._decoderModule.destroy(decoder);
            this._decoderModule.destroy(dracoMesh);
          }
        }
        return this;
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      prewrite(context, _propertyType) {
        if (!this._encoderModule) {
          throw new Error(`[${KHR_DRACO_MESH_COMPRESSION}] Please install extension dependency, "draco3d.encoder".`);
        }
        const logger = this.document.getLogger();
        logger.debug(`[${KHR_DRACO_MESH_COMPRESSION}] Compression options: ${JSON.stringify(this._encoderOptions)}`);
        const primitiveHashMap = listDracoPrimitives(this.document);
        const primitiveEncodingMap = /* @__PURE__ */ new Map();
        let quantizationVolume = "mesh";
        if (this._encoderOptions.quantizationVolume === "scene") {
          if (this.document.getRoot().listScenes().length !== 1) {
            logger.warn(`[${KHR_DRACO_MESH_COMPRESSION}]: quantizationVolume=scene requires exactly 1 scene.`);
          } else {
            quantizationVolume = getBounds(this.document.getRoot().listScenes().pop());
          }
        }
        for (const prim of Array.from(primitiveHashMap.keys())) {
          const primHash = primitiveHashMap.get(prim);
          if (!primHash) throw new Error("Unexpected primitive.");
          if (primitiveEncodingMap.has(primHash)) {
            primitiveEncodingMap.set(primHash, primitiveEncodingMap.get(primHash));
            continue;
          }
          const indices = prim.getIndices();
          const accessorDefs = context.jsonDoc.json.accessors;
          let encodedPrim;
          try {
            encodedPrim = encodeGeometry(prim, _extends3({}, this._encoderOptions, {
              quantizationVolume
            }));
          } catch (e) {
            if (e instanceof EncodingError) {
              logger.warn(`[${KHR_DRACO_MESH_COMPRESSION}]: ${e.message} Skipping primitive compression.`);
              continue;
            }
            throw e;
          }
          primitiveEncodingMap.set(primHash, encodedPrim);
          const indicesDef = context.createAccessorDef(indices);
          indicesDef.count = encodedPrim.numIndices;
          context.accessorIndexMap.set(indices, accessorDefs.length);
          accessorDefs.push(indicesDef);
          if (encodedPrim.numVertices > 65534 && Accessor.getComponentSize(indicesDef.componentType) <= 2) {
            indicesDef.componentType = Accessor.ComponentType.UNSIGNED_INT;
          } else if (encodedPrim.numVertices > 254 && Accessor.getComponentSize(indicesDef.componentType) <= 1) {
            indicesDef.componentType = Accessor.ComponentType.UNSIGNED_SHORT;
          }
          for (const semantic of prim.listSemantics()) {
            const attribute = prim.getAttribute(semantic);
            if (encodedPrim.attributeIDs[semantic] === void 0) continue;
            const attributeDef = context.createAccessorDef(attribute);
            attributeDef.count = encodedPrim.numVertices;
            context.accessorIndexMap.set(attribute, accessorDefs.length);
            accessorDefs.push(attributeDef);
          }
          const buffer = prim.getAttribute("POSITION").getBuffer() || this.document.getRoot().listBuffers()[0];
          if (!context.otherBufferViews.has(buffer)) context.otherBufferViews.set(buffer, []);
          context.otherBufferViews.get(buffer).push(encodedPrim.data);
        }
        logger.debug(`[${KHR_DRACO_MESH_COMPRESSION}] Compressed ${primitiveHashMap.size} primitives.`);
        context.extensionData[KHR_DRACO_MESH_COMPRESSION] = {
          primitiveHashMap,
          primitiveEncodingMap
        };
        return this;
      }
      /** @hidden */
      write(context) {
        const dracoContext = context.extensionData[KHR_DRACO_MESH_COMPRESSION];
        for (const mesh of this.document.getRoot().listMeshes()) {
          const meshDef = context.jsonDoc.json.meshes[context.meshIndexMap.get(mesh)];
          for (let i = 0; i < mesh.listPrimitives().length; i++) {
            const prim = mesh.listPrimitives()[i];
            const primDef = meshDef.primitives[i];
            const primHash = dracoContext.primitiveHashMap.get(prim);
            if (!primHash) continue;
            const encodedPrim = dracoContext.primitiveEncodingMap.get(primHash);
            if (!encodedPrim) continue;
            primDef.extensions = primDef.extensions || {};
            primDef.extensions[KHR_DRACO_MESH_COMPRESSION] = {
              bufferView: context.otherBufferViewsIndexMap.get(encodedPrim.data),
              attributes: encodedPrim.attributeIDs
            };
          }
        }
        if (!dracoContext.primitiveHashMap.size) {
          const json = context.jsonDoc.json;
          json.extensionsUsed = (json.extensionsUsed || []).filter((name) => name !== KHR_DRACO_MESH_COMPRESSION);
          json.extensionsRequired = (json.extensionsRequired || []).filter((name) => name !== KHR_DRACO_MESH_COMPRESSION);
        }
        return this;
      }
    };
    KHRDracoMeshCompression.EXTENSION_NAME = KHR_DRACO_MESH_COMPRESSION;
    KHRDracoMeshCompression.EncoderMethod = EncoderMethod;
    Light = class _Light extends ExtensionProperty {
      /**********************************************************************************************
       * INSTANCE.
       */
      init() {
        this.extensionName = KHR_LIGHTS_PUNCTUAL;
        this.propertyType = "Light";
        this.parentTypes = [PropertyType.NODE];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          color: [1, 1, 1],
          intensity: 1,
          type: _Light.Type.POINT,
          range: null,
          innerConeAngle: 0,
          outerConeAngle: Math.PI / 4
        });
      }
      /**********************************************************************************************
       * COLOR.
       */
      /** Light color; Linear-sRGB components. */
      getColor() {
        return this.get("color");
      }
      /** Light color; Linear-sRGB components. */
      setColor(color) {
        return this.set("color", color);
      }
      /**********************************************************************************************
       * INTENSITY.
       */
      /**
       * Brightness of light. Units depend on the type of light: point and spot lights use luminous
       * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).
       */
      getIntensity() {
        return this.get("intensity");
      }
      /**
       * Brightness of light. Units depend on the type of light: point and spot lights use luminous
       * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).
       */
      setIntensity(intensity) {
        return this.set("intensity", intensity);
      }
      /**********************************************************************************************
       * TYPE.
       */
      /** Type. */
      getType() {
        return this.get("type");
      }
      /** Type. */
      setType(type) {
        return this.set("type", type);
      }
      /**********************************************************************************************
       * RANGE.
       */
      /**
       * Hint defining a distance cutoff at which the light's intensity may be considered to have
       * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range
       * is assumed to be infinite.
       */
      getRange() {
        return this.get("range");
      }
      /**
       * Hint defining a distance cutoff at which the light's intensity may be considered to have
       * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range
       * is assumed to be infinite.
       */
      setRange(range) {
        return this.set("range", range);
      }
      /**********************************************************************************************
       * SPOT LIGHT PROPERTIES
       */
      /**
       * Angle, in radians, from centre of spotlight where falloff begins. Must be >= 0 and
       * < outerConeAngle.
       */
      getInnerConeAngle() {
        return this.get("innerConeAngle");
      }
      /**
       * Angle, in radians, from centre of spotlight where falloff begins. Must be >= 0 and
       * < outerConeAngle.
       */
      setInnerConeAngle(angle) {
        return this.set("innerConeAngle", angle);
      }
      /**
       * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and
       * <= PI / 2.0.
       */
      getOuterConeAngle() {
        return this.get("outerConeAngle");
      }
      /**
       * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and
       * <= PI / 2.0.
       */
      setOuterConeAngle(angle) {
        return this.set("outerConeAngle", angle);
      }
    };
    Light.EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;
    Light.Type = {
      POINT: "point",
      SPOT: "spot",
      DIRECTIONAL: "directional"
    };
    KHRLightsPunctual = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_LIGHTS_PUNCTUAL;
      }
      /** Creates a new punctual Light property for use on a {@link Node}. */
      createLight(name = "") {
        return new Light(this.document.getGraph(), name);
      }
      /** @hidden */
      read(context) {
        const jsonDoc = context.jsonDoc;
        if (!jsonDoc.json.extensions || !jsonDoc.json.extensions[KHR_LIGHTS_PUNCTUAL]) return this;
        const rootDef = jsonDoc.json.extensions[KHR_LIGHTS_PUNCTUAL];
        const lightDefs = rootDef.lights || [];
        const lights = lightDefs.map((lightDef) => {
          var _lightDef$spot, _lightDef$spot2;
          const light = this.createLight().setName(lightDef.name || "").setType(lightDef.type);
          if (lightDef.color !== void 0) light.setColor(lightDef.color);
          if (lightDef.intensity !== void 0) light.setIntensity(lightDef.intensity);
          if (lightDef.range !== void 0) light.setRange(lightDef.range);
          if (((_lightDef$spot = lightDef.spot) == null ? void 0 : _lightDef$spot.innerConeAngle) !== void 0) {
            light.setInnerConeAngle(lightDef.spot.innerConeAngle);
          }
          if (((_lightDef$spot2 = lightDef.spot) == null ? void 0 : _lightDef$spot2.outerConeAngle) !== void 0) {
            light.setOuterConeAngle(lightDef.spot.outerConeAngle);
          }
          return light;
        });
        jsonDoc.json.nodes.forEach((nodeDef, nodeIndex) => {
          if (!nodeDef.extensions || !nodeDef.extensions[KHR_LIGHTS_PUNCTUAL]) return;
          const lightNodeDef = nodeDef.extensions[KHR_LIGHTS_PUNCTUAL];
          context.nodes[nodeIndex].setExtension(KHR_LIGHTS_PUNCTUAL, lights[lightNodeDef.light]);
        });
        return this;
      }
      /** @hidden */
      write(context) {
        const jsonDoc = context.jsonDoc;
        if (this.properties.size === 0) return this;
        const lightDefs = [];
        const lightIndexMap = /* @__PURE__ */ new Map();
        for (const property of this.properties) {
          const light = property;
          const lightDef = {
            type: light.getType()
          };
          if (!MathUtils.eq(light.getColor(), [1, 1, 1])) lightDef.color = light.getColor();
          if (light.getIntensity() !== 1) lightDef.intensity = light.getIntensity();
          if (light.getRange() != null) lightDef.range = light.getRange();
          if (light.getName()) lightDef.name = light.getName();
          if (light.getType() === Light.Type.SPOT) {
            lightDef.spot = {
              innerConeAngle: light.getInnerConeAngle(),
              outerConeAngle: light.getOuterConeAngle()
            };
          }
          lightDefs.push(lightDef);
          lightIndexMap.set(light, lightDefs.length - 1);
        }
        this.document.getRoot().listNodes().forEach((node) => {
          const light = node.getExtension(KHR_LIGHTS_PUNCTUAL);
          if (light) {
            const nodeIndex = context.nodeIndexMap.get(node);
            const nodeDef = jsonDoc.json.nodes[nodeIndex];
            nodeDef.extensions = nodeDef.extensions || {};
            nodeDef.extensions[KHR_LIGHTS_PUNCTUAL] = {
              light: lightIndexMap.get(light)
            };
          }
        });
        jsonDoc.json.extensions = jsonDoc.json.extensions || {};
        jsonDoc.json.extensions[KHR_LIGHTS_PUNCTUAL] = {
          lights: lightDefs
        };
        return this;
      }
    };
    KHRLightsPunctual.EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;
    ({
      R: R$7,
      G: G$7,
      B: B$5
    } = TextureChannel);
    Anisotropy = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_ANISOTROPY;
        this.propertyType = "Anisotropy";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          anisotropyStrength: 0,
          anisotropyRotation: 0,
          anisotropyTexture: null,
          anisotropyTextureInfo: new TextureInfo(this.graph, "anisotropyTextureInfo")
        });
      }
      /**********************************************************************************************
       * Anisotropy strength.
       */
      /** Anisotropy strength. */
      getAnisotropyStrength() {
        return this.get("anisotropyStrength");
      }
      /** Anisotropy strength. */
      setAnisotropyStrength(strength) {
        return this.set("anisotropyStrength", strength);
      }
      /**********************************************************************************************
       * Anisotropy rotation.
       */
      /** Anisotropy rotation; linear multiplier. */
      getAnisotropyRotation() {
        return this.get("anisotropyRotation");
      }
      /** Anisotropy rotation; linear multiplier. */
      setAnisotropyRotation(rotation) {
        return this.set("anisotropyRotation", rotation);
      }
      /**********************************************************************************************
       * Anisotropy texture.
       */
      /**
       * Anisotropy texture. Red and green channels represent the anisotropy
       * direction in [-1, 1] tangent, bitangent space, to be rotated by
       * anisotropyRotation. The blue channel contains strength as [0, 1] to be
       * multiplied by anisotropyStrength.
       */
      getAnisotropyTexture() {
        return this.getRef("anisotropyTexture");
      }
      /**
       * Settings affecting the material's use of its anisotropy texture. If no
       * texture is attached, {@link TextureInfo} is `null`.
       */
      getAnisotropyTextureInfo() {
        return this.getRef("anisotropyTexture") ? this.getRef("anisotropyTextureInfo") : null;
      }
      /** Anisotropy texture. See {@link Anisotropy.getAnisotropyTexture getAnisotropyTexture}. */
      setAnisotropyTexture(texture) {
        return this.setRef("anisotropyTexture", texture, {
          channels: R$7 | G$7 | B$5
        });
      }
    };
    Anisotropy.EXTENSION_NAME = KHR_MATERIALS_ANISOTROPY;
    KHRMaterialsAnisotropy = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_ANISOTROPY;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new Anisotropy property for use on a {@link Material}. */
      createAnisotropy() {
        return new Anisotropy(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        const textureDefs = jsonDoc.json.textures || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_ANISOTROPY]) {
            const anisotropy = this.createAnisotropy();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_ANISOTROPY, anisotropy);
            const anisotropyDef = materialDef.extensions[KHR_MATERIALS_ANISOTROPY];
            if (anisotropyDef.anisotropyStrength !== void 0) {
              anisotropy.setAnisotropyStrength(anisotropyDef.anisotropyStrength);
            }
            if (anisotropyDef.anisotropyRotation !== void 0) {
              anisotropy.setAnisotropyRotation(anisotropyDef.anisotropyRotation);
            }
            if (anisotropyDef.anisotropyTexture !== void 0) {
              const textureInfoDef = anisotropyDef.anisotropyTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              anisotropy.setAnisotropyTexture(texture);
              context.setTextureInfo(anisotropy.getAnisotropyTextureInfo(), textureInfoDef);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const anisotropy = material.getExtension(KHR_MATERIALS_ANISOTROPY);
          if (anisotropy) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            const anisotropyDef = materialDef.extensions[KHR_MATERIALS_ANISOTROPY] = {};
            if (anisotropy.getAnisotropyStrength() > 0) {
              anisotropyDef.anisotropyStrength = anisotropy.getAnisotropyStrength();
            }
            if (anisotropy.getAnisotropyRotation() !== 0) {
              anisotropyDef.anisotropyRotation = anisotropy.getAnisotropyRotation();
            }
            if (anisotropy.getAnisotropyTexture()) {
              const texture = anisotropy.getAnisotropyTexture();
              const textureInfo = anisotropy.getAnisotropyTextureInfo();
              anisotropyDef.anisotropyTexture = context.createTextureInfoDef(texture, textureInfo);
            }
          }
        });
        return this;
      }
    };
    KHRMaterialsAnisotropy.EXTENSION_NAME = KHR_MATERIALS_ANISOTROPY;
    ({
      R: R$6,
      G: G$6,
      B: B$4
    } = TextureChannel);
    Clearcoat = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_CLEARCOAT;
        this.propertyType = "Clearcoat";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          clearcoatFactor: 0,
          clearcoatTexture: null,
          clearcoatTextureInfo: new TextureInfo(this.graph, "clearcoatTextureInfo"),
          clearcoatRoughnessFactor: 0,
          clearcoatRoughnessTexture: null,
          clearcoatRoughnessTextureInfo: new TextureInfo(this.graph, "clearcoatRoughnessTextureInfo"),
          clearcoatNormalScale: 1,
          clearcoatNormalTexture: null,
          clearcoatNormalTextureInfo: new TextureInfo(this.graph, "clearcoatNormalTextureInfo")
        });
      }
      /**********************************************************************************************
       * Clearcoat.
       */
      /** Clearcoat; linear multiplier. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */
      getClearcoatFactor() {
        return this.get("clearcoatFactor");
      }
      /** Clearcoat; linear multiplier. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */
      setClearcoatFactor(factor) {
        return this.set("clearcoatFactor", factor);
      }
      /**
       * Clearcoat texture; linear multiplier. The `r` channel of this texture specifies an amount
       * [0-1] of coating over the surface of the material, which may have its own roughness and
       * normal map properties.
       */
      getClearcoatTexture() {
        return this.getRef("clearcoatTexture");
      }
      /**
       * Settings affecting the material's use of its clearcoat texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getClearcoatTextureInfo() {
        return this.getRef("clearcoatTexture") ? this.getRef("clearcoatTextureInfo") : null;
      }
      /** Sets clearcoat texture. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */
      setClearcoatTexture(texture) {
        return this.setRef("clearcoatTexture", texture, {
          channels: R$6
        });
      }
      /**********************************************************************************************
       * Clearcoat roughness.
       */
      /**
       * Clearcoat roughness; linear multiplier.
       * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.
       */
      getClearcoatRoughnessFactor() {
        return this.get("clearcoatRoughnessFactor");
      }
      /**
       * Clearcoat roughness; linear multiplier.
       * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.
       */
      setClearcoatRoughnessFactor(factor) {
        return this.set("clearcoatRoughnessFactor", factor);
      }
      /**
       * Clearcoat roughness texture; linear multiplier. The `g` channel of this texture specifies
       * roughness, independent of the base layer's roughness.
       */
      getClearcoatRoughnessTexture() {
        return this.getRef("clearcoatRoughnessTexture");
      }
      /**
       * Settings affecting the material's use of its clearcoat roughness texture. If no texture is
       * attached, {@link TextureInfo} is `null`.
       */
      getClearcoatRoughnessTextureInfo() {
        return this.getRef("clearcoatRoughnessTexture") ? this.getRef("clearcoatRoughnessTextureInfo") : null;
      }
      /**
       * Sets clearcoat roughness texture.
       * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.
       */
      setClearcoatRoughnessTexture(texture) {
        return this.setRef("clearcoatRoughnessTexture", texture, {
          channels: G$6
        });
      }
      /**********************************************************************************************
       * Clearcoat normals.
       */
      /** Clearcoat normal scale. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */
      getClearcoatNormalScale() {
        return this.get("clearcoatNormalScale");
      }
      /** Clearcoat normal scale. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */
      setClearcoatNormalScale(scale) {
        return this.set("clearcoatNormalScale", scale);
      }
      /**
       * Clearcoat normal map. Independent of the material base layer normal map.
       */
      getClearcoatNormalTexture() {
        return this.getRef("clearcoatNormalTexture");
      }
      /**
       * Settings affecting the material's use of its clearcoat normal texture. If no texture is
       * attached, {@link TextureInfo} is `null`.
       */
      getClearcoatNormalTextureInfo() {
        return this.getRef("clearcoatNormalTexture") ? this.getRef("clearcoatNormalTextureInfo") : null;
      }
      /** Sets clearcoat normal texture. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */
      setClearcoatNormalTexture(texture) {
        return this.setRef("clearcoatNormalTexture", texture, {
          channels: R$6 | G$6 | B$4
        });
      }
    };
    Clearcoat.EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;
    KHRMaterialsClearcoat = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_CLEARCOAT;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new Clearcoat property for use on a {@link Material}. */
      createClearcoat() {
        return new Clearcoat(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        const textureDefs = jsonDoc.json.textures || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_CLEARCOAT]) {
            const clearcoat = this.createClearcoat();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_CLEARCOAT, clearcoat);
            const clearcoatDef = materialDef.extensions[KHR_MATERIALS_CLEARCOAT];
            if (clearcoatDef.clearcoatFactor !== void 0) {
              clearcoat.setClearcoatFactor(clearcoatDef.clearcoatFactor);
            }
            if (clearcoatDef.clearcoatRoughnessFactor !== void 0) {
              clearcoat.setClearcoatRoughnessFactor(clearcoatDef.clearcoatRoughnessFactor);
            }
            if (clearcoatDef.clearcoatTexture !== void 0) {
              const textureInfoDef = clearcoatDef.clearcoatTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              clearcoat.setClearcoatTexture(texture);
              context.setTextureInfo(clearcoat.getClearcoatTextureInfo(), textureInfoDef);
            }
            if (clearcoatDef.clearcoatRoughnessTexture !== void 0) {
              const textureInfoDef = clearcoatDef.clearcoatRoughnessTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              clearcoat.setClearcoatRoughnessTexture(texture);
              context.setTextureInfo(clearcoat.getClearcoatRoughnessTextureInfo(), textureInfoDef);
            }
            if (clearcoatDef.clearcoatNormalTexture !== void 0) {
              const textureInfoDef = clearcoatDef.clearcoatNormalTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              clearcoat.setClearcoatNormalTexture(texture);
              context.setTextureInfo(clearcoat.getClearcoatNormalTextureInfo(), textureInfoDef);
              if (textureInfoDef.scale !== void 0) {
                clearcoat.setClearcoatNormalScale(textureInfoDef.scale);
              }
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const clearcoat = material.getExtension(KHR_MATERIALS_CLEARCOAT);
          if (clearcoat) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            const clearcoatDef = materialDef.extensions[KHR_MATERIALS_CLEARCOAT] = {
              clearcoatFactor: clearcoat.getClearcoatFactor(),
              clearcoatRoughnessFactor: clearcoat.getClearcoatRoughnessFactor()
            };
            if (clearcoat.getClearcoatTexture()) {
              const texture = clearcoat.getClearcoatTexture();
              const textureInfo = clearcoat.getClearcoatTextureInfo();
              clearcoatDef.clearcoatTexture = context.createTextureInfoDef(texture, textureInfo);
            }
            if (clearcoat.getClearcoatRoughnessTexture()) {
              const texture = clearcoat.getClearcoatRoughnessTexture();
              const textureInfo = clearcoat.getClearcoatRoughnessTextureInfo();
              clearcoatDef.clearcoatRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);
            }
            if (clearcoat.getClearcoatNormalTexture()) {
              const texture = clearcoat.getClearcoatNormalTexture();
              const textureInfo = clearcoat.getClearcoatNormalTextureInfo();
              clearcoatDef.clearcoatNormalTexture = context.createTextureInfoDef(texture, textureInfo);
              if (clearcoat.getClearcoatNormalScale() !== 1) {
                clearcoatDef.clearcoatNormalTexture.scale = clearcoat.getClearcoatNormalScale();
              }
            }
          }
        });
        return this;
      }
    };
    KHRMaterialsClearcoat.EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;
    ({
      R: R$5,
      G: G$5,
      B: B$3,
      A: A$3
    } = TextureChannel);
    DiffuseTransmission = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_DIFFUSE_TRANSMISSION;
        this.propertyType = "DiffuseTransmission";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          diffuseTransmissionFactor: 0,
          diffuseTransmissionTexture: null,
          diffuseTransmissionTextureInfo: new TextureInfo(this.graph, "diffuseTransmissionTextureInfo"),
          diffuseTransmissionColorFactor: [1, 1, 1],
          diffuseTransmissionColorTexture: null,
          diffuseTransmissionColorTextureInfo: new TextureInfo(this.graph, "diffuseTransmissionColorTextureInfo")
        });
      }
      /**********************************************************************************************
       * Diffuse transmission.
       */
      /**
       * Percentage of reflected, non-specularly reflected light that is transmitted through the
       * surface via the Lambertian diffuse transmission, i.e., the strength of the diffuse
       * transmission effect.
       */
      getDiffuseTransmissionFactor() {
        return this.get("diffuseTransmissionFactor");
      }
      /**
       * Percentage of reflected, non-specularly reflected light that is transmitted through the
       * surface via the Lambertian diffuse transmission, i.e., the strength of the diffuse
       * transmission effect.
       */
      setDiffuseTransmissionFactor(factor) {
        return this.set("diffuseTransmissionFactor", factor);
      }
      /**
       * Texture that defines the strength of the diffuse transmission effect, stored in the alpha (A)
       * channel. Will be multiplied by the diffuseTransmissionFactor.
       */
      getDiffuseTransmissionTexture() {
        return this.getRef("diffuseTransmissionTexture");
      }
      /**
       * Settings affecting the material's use of its diffuse transmission texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getDiffuseTransmissionTextureInfo() {
        return this.getRef("diffuseTransmissionTexture") ? this.getRef("diffuseTransmissionTextureInfo") : null;
      }
      /**
       * Texture that defines the strength of the diffuse transmission effect, stored in the alpha (A)
       * channel. Will be multiplied by the diffuseTransmissionFactor.
       */
      setDiffuseTransmissionTexture(texture) {
        return this.setRef("diffuseTransmissionTexture", texture, {
          channels: A$3
        });
      }
      /**********************************************************************************************
       * Diffuse transmission color.
       */
      /** Color of the transmitted light; Linear-sRGB components. */
      getDiffuseTransmissionColorFactor() {
        return this.get("diffuseTransmissionColorFactor");
      }
      /** Color of the transmitted light; Linear-sRGB components. */
      setDiffuseTransmissionColorFactor(factor) {
        return this.set("diffuseTransmissionColorFactor", factor);
      }
      /**
       * Texture that defines the color of the transmitted light, stored in the RGB channels and
       * encoded in sRGB. This texture will be multiplied by diffuseTransmissionColorFactor.
       */
      getDiffuseTransmissionColorTexture() {
        return this.getRef("diffuseTransmissionColorTexture");
      }
      /**
       * Settings affecting the material's use of its diffuse transmission color texture. If no
       * texture is attached, {@link TextureInfo} is `null`.
       */
      getDiffuseTransmissionColorTextureInfo() {
        return this.getRef("diffuseTransmissionColorTexture") ? this.getRef("diffuseTransmissionColorTextureInfo") : null;
      }
      /**
       * Texture that defines the color of the transmitted light, stored in the RGB channels and
       * encoded in sRGB. This texture will be multiplied by diffuseTransmissionColorFactor.
       */
      setDiffuseTransmissionColorTexture(texture) {
        return this.setRef("diffuseTransmissionColorTexture", texture, {
          channels: R$5 | G$5 | B$3
        });
      }
    };
    DiffuseTransmission.EXTENSION_NAME = KHR_MATERIALS_DIFFUSE_TRANSMISSION;
    KHRMaterialsDiffuseTransmission = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_DIFFUSE_TRANSMISSION;
      }
      /** Creates a new DiffuseTransmission property for use on a {@link Material}. */
      createDiffuseTransmission() {
        return new DiffuseTransmission(this.document.getGraph());
      }
      /** @hidden */
      read(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        const textureDefs = jsonDoc.json.textures || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_DIFFUSE_TRANSMISSION]) {
            const transmission = this.createDiffuseTransmission();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_DIFFUSE_TRANSMISSION, transmission);
            const transmissionDef = materialDef.extensions[KHR_MATERIALS_DIFFUSE_TRANSMISSION];
            if (transmissionDef.diffuseTransmissionFactor !== void 0) {
              transmission.setDiffuseTransmissionFactor(transmissionDef.diffuseTransmissionFactor);
            }
            if (transmissionDef.diffuseTransmissionColorFactor !== void 0) {
              transmission.setDiffuseTransmissionColorFactor(transmissionDef.diffuseTransmissionColorFactor);
            }
            if (transmissionDef.diffuseTransmissionTexture !== void 0) {
              const textureInfoDef = transmissionDef.diffuseTransmissionTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              transmission.setDiffuseTransmissionTexture(texture);
              context.setTextureInfo(transmission.getDiffuseTransmissionTextureInfo(), textureInfoDef);
            }
            if (transmissionDef.diffuseTransmissionColorTexture !== void 0) {
              const textureInfoDef = transmissionDef.diffuseTransmissionColorTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              transmission.setDiffuseTransmissionColorTexture(texture);
              context.setTextureInfo(transmission.getDiffuseTransmissionColorTextureInfo(), textureInfoDef);
            }
          }
        });
        return this;
      }
      /** @hidden */
      write(context) {
        const jsonDoc = context.jsonDoc;
        for (const material of this.document.getRoot().listMaterials()) {
          const transmission = material.getExtension(KHR_MATERIALS_DIFFUSE_TRANSMISSION);
          if (!transmission) continue;
          const materialIndex = context.materialIndexMap.get(material);
          const materialDef = jsonDoc.json.materials[materialIndex];
          materialDef.extensions = materialDef.extensions || {};
          const transmissionDef = materialDef.extensions[KHR_MATERIALS_DIFFUSE_TRANSMISSION] = {
            diffuseTransmissionFactor: transmission.getDiffuseTransmissionFactor(),
            diffuseTransmissionColorFactor: transmission.getDiffuseTransmissionColorFactor()
          };
          if (transmission.getDiffuseTransmissionTexture()) {
            const texture = transmission.getDiffuseTransmissionTexture();
            const textureInfo = transmission.getDiffuseTransmissionTextureInfo();
            transmissionDef.diffuseTransmissionTexture = context.createTextureInfoDef(texture, textureInfo);
          }
          if (transmission.getDiffuseTransmissionColorTexture()) {
            const texture = transmission.getDiffuseTransmissionColorTexture();
            const textureInfo = transmission.getDiffuseTransmissionColorTextureInfo();
            transmissionDef.diffuseTransmissionColorTexture = context.createTextureInfoDef(texture, textureInfo);
          }
        }
        return this;
      }
    };
    KHRMaterialsDiffuseTransmission.EXTENSION_NAME = KHR_MATERIALS_DIFFUSE_TRANSMISSION;
    Dispersion = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_DISPERSION;
        this.propertyType = "Dispersion";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          dispersion: 0
        });
      }
      /**********************************************************************************************
       * Dispersion.
       */
      /** Dispersion. */
      getDispersion() {
        return this.get("dispersion");
      }
      /** Dispersion. */
      setDispersion(dispersion) {
        return this.set("dispersion", dispersion);
      }
    };
    Dispersion.EXTENSION_NAME = KHR_MATERIALS_DISPERSION;
    KHRMaterialsDispersion = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_DISPERSION;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new Dispersion property for use on a {@link Material}. */
      createDispersion() {
        return new Dispersion(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_DISPERSION]) {
            const dispersion = this.createDispersion();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_DISPERSION, dispersion);
            const dispersionDef = materialDef.extensions[KHR_MATERIALS_DISPERSION];
            if (dispersionDef.dispersion !== void 0) {
              dispersion.setDispersion(dispersionDef.dispersion);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const dispersion = material.getExtension(KHR_MATERIALS_DISPERSION);
          if (dispersion) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            materialDef.extensions[KHR_MATERIALS_DISPERSION] = {
              dispersion: dispersion.getDispersion()
            };
          }
        });
        return this;
      }
    };
    KHRMaterialsDispersion.EXTENSION_NAME = KHR_MATERIALS_DISPERSION;
    EmissiveStrength = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;
        this.propertyType = "EmissiveStrength";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          emissiveStrength: 1
        });
      }
      /**********************************************************************************************
       * EmissiveStrength.
       */
      /** EmissiveStrength. */
      getEmissiveStrength() {
        return this.get("emissiveStrength");
      }
      /** EmissiveStrength. */
      setEmissiveStrength(strength) {
        return this.set("emissiveStrength", strength);
      }
    };
    EmissiveStrength.EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;
    KHRMaterialsEmissiveStrength = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new EmissiveStrength property for use on a {@link Material}. */
      createEmissiveStrength() {
        return new EmissiveStrength(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_EMISSIVE_STRENGTH]) {
            const emissiveStrength = this.createEmissiveStrength();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_EMISSIVE_STRENGTH, emissiveStrength);
            const emissiveStrengthDef = materialDef.extensions[KHR_MATERIALS_EMISSIVE_STRENGTH];
            if (emissiveStrengthDef.emissiveStrength !== void 0) {
              emissiveStrength.setEmissiveStrength(emissiveStrengthDef.emissiveStrength);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const emissiveStrength = material.getExtension(KHR_MATERIALS_EMISSIVE_STRENGTH);
          if (emissiveStrength) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            materialDef.extensions[KHR_MATERIALS_EMISSIVE_STRENGTH] = {
              emissiveStrength: emissiveStrength.getEmissiveStrength()
            };
          }
        });
        return this;
      }
    };
    KHRMaterialsEmissiveStrength.EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;
    IOR = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_IOR;
        this.propertyType = "IOR";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          ior: 1.5
        });
      }
      /**********************************************************************************************
       * IOR.
       */
      /** IOR. */
      getIOR() {
        return this.get("ior");
      }
      /** IOR. */
      setIOR(ior) {
        return this.set("ior", ior);
      }
    };
    IOR.EXTENSION_NAME = KHR_MATERIALS_IOR;
    KHRMaterialsIOR = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_IOR;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new IOR property for use on a {@link Material}. */
      createIOR() {
        return new IOR(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_IOR]) {
            const ior = this.createIOR();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_IOR, ior);
            const iorDef = materialDef.extensions[KHR_MATERIALS_IOR];
            if (iorDef.ior !== void 0) {
              ior.setIOR(iorDef.ior);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const ior = material.getExtension(KHR_MATERIALS_IOR);
          if (ior) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            materialDef.extensions[KHR_MATERIALS_IOR] = {
              ior: ior.getIOR()
            };
          }
        });
        return this;
      }
    };
    KHRMaterialsIOR.EXTENSION_NAME = KHR_MATERIALS_IOR;
    ({
      R: R$4,
      G: G$4
    } = TextureChannel);
    Iridescence = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_IRIDESCENCE;
        this.propertyType = "Iridescence";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          iridescenceFactor: 0,
          iridescenceTexture: null,
          iridescenceTextureInfo: new TextureInfo(this.graph, "iridescenceTextureInfo"),
          iridescenceIOR: 1.3,
          iridescenceThicknessMinimum: 100,
          iridescenceThicknessMaximum: 400,
          iridescenceThicknessTexture: null,
          iridescenceThicknessTextureInfo: new TextureInfo(this.graph, "iridescenceThicknessTextureInfo")
        });
      }
      /**********************************************************************************************
       * Iridescence.
       */
      /** Iridescence; linear multiplier. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */
      getIridescenceFactor() {
        return this.get("iridescenceFactor");
      }
      /** Iridescence; linear multiplier. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */
      setIridescenceFactor(factor) {
        return this.set("iridescenceFactor", factor);
      }
      /**
       * Iridescence intensity.
       *
       * Only the red (R) channel is used for iridescence intensity, but this texture may optionally
       * be packed with additional data in the other channels.
       */
      getIridescenceTexture() {
        return this.getRef("iridescenceTexture");
      }
      /**
       * Settings affecting the material's use of its iridescence texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getIridescenceTextureInfo() {
        return this.getRef("iridescenceTexture") ? this.getRef("iridescenceTextureInfo") : null;
      }
      /** Iridescence intensity. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */
      setIridescenceTexture(texture) {
        return this.setRef("iridescenceTexture", texture, {
          channels: R$4
        });
      }
      /**********************************************************************************************
       * Iridescence IOR.
       */
      /** Index of refraction of the dielectric thin-film layer. */
      getIridescenceIOR() {
        return this.get("iridescenceIOR");
      }
      /** Index of refraction of the dielectric thin-film layer. */
      setIridescenceIOR(ior) {
        return this.set("iridescenceIOR", ior);
      }
      /**********************************************************************************************
       * Iridescence thickness.
       */
      /** Minimum thickness of the thin-film layer, in nanometers (nm). */
      getIridescenceThicknessMinimum() {
        return this.get("iridescenceThicknessMinimum");
      }
      /** Minimum thickness of the thin-film layer, in nanometers (nm). */
      setIridescenceThicknessMinimum(thickness) {
        return this.set("iridescenceThicknessMinimum", thickness);
      }
      /** Maximum thickness of the thin-film layer, in nanometers (nm). */
      getIridescenceThicknessMaximum() {
        return this.get("iridescenceThicknessMaximum");
      }
      /** Maximum thickness of the thin-film layer, in nanometers (nm). */
      setIridescenceThicknessMaximum(thickness) {
        return this.set("iridescenceThicknessMaximum", thickness);
      }
      /**
       * The green channel of this texture defines the thickness of the
       * thin-film layer by blending between the minimum and maximum thickness.
       */
      getIridescenceThicknessTexture() {
        return this.getRef("iridescenceThicknessTexture");
      }
      /**
       * Settings affecting the material's use of its iridescence thickness texture.
       * If no texture is attached, {@link TextureInfo} is `null`.
       */
      getIridescenceThicknessTextureInfo() {
        return this.getRef("iridescenceThicknessTexture") ? this.getRef("iridescenceThicknessTextureInfo") : null;
      }
      /**
       * Sets iridescence thickness texture.
       * See {@link Iridescence.getIridescenceThicknessTexture getIridescenceThicknessTexture}.
       */
      setIridescenceThicknessTexture(texture) {
        return this.setRef("iridescenceThicknessTexture", texture, {
          channels: G$4
        });
      }
    };
    Iridescence.EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;
    KHRMaterialsIridescence = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_IRIDESCENCE;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new Iridescence property for use on a {@link Material}. */
      createIridescence() {
        return new Iridescence(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        const textureDefs = jsonDoc.json.textures || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_IRIDESCENCE]) {
            const iridescence = this.createIridescence();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_IRIDESCENCE, iridescence);
            const iridescenceDef = materialDef.extensions[KHR_MATERIALS_IRIDESCENCE];
            if (iridescenceDef.iridescenceFactor !== void 0) {
              iridescence.setIridescenceFactor(iridescenceDef.iridescenceFactor);
            }
            if (iridescenceDef.iridescenceIor !== void 0) {
              iridescence.setIridescenceIOR(iridescenceDef.iridescenceIor);
            }
            if (iridescenceDef.iridescenceThicknessMinimum !== void 0) {
              iridescence.setIridescenceThicknessMinimum(iridescenceDef.iridescenceThicknessMinimum);
            }
            if (iridescenceDef.iridescenceThicknessMaximum !== void 0) {
              iridescence.setIridescenceThicknessMaximum(iridescenceDef.iridescenceThicknessMaximum);
            }
            if (iridescenceDef.iridescenceTexture !== void 0) {
              const textureInfoDef = iridescenceDef.iridescenceTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              iridescence.setIridescenceTexture(texture);
              context.setTextureInfo(iridescence.getIridescenceTextureInfo(), textureInfoDef);
            }
            if (iridescenceDef.iridescenceThicknessTexture !== void 0) {
              const textureInfoDef = iridescenceDef.iridescenceThicknessTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              iridescence.setIridescenceThicknessTexture(texture);
              context.setTextureInfo(iridescence.getIridescenceThicknessTextureInfo(), textureInfoDef);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const iridescence = material.getExtension(KHR_MATERIALS_IRIDESCENCE);
          if (iridescence) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            const iridescenceDef = materialDef.extensions[KHR_MATERIALS_IRIDESCENCE] = {};
            if (iridescence.getIridescenceFactor() > 0) {
              iridescenceDef.iridescenceFactor = iridescence.getIridescenceFactor();
            }
            if (iridescence.getIridescenceIOR() !== 1.3) {
              iridescenceDef.iridescenceIor = iridescence.getIridescenceIOR();
            }
            if (iridescence.getIridescenceThicknessMinimum() !== 100) {
              iridescenceDef.iridescenceThicknessMinimum = iridescence.getIridescenceThicknessMinimum();
            }
            if (iridescence.getIridescenceThicknessMaximum() !== 400) {
              iridescenceDef.iridescenceThicknessMaximum = iridescence.getIridescenceThicknessMaximum();
            }
            if (iridescence.getIridescenceTexture()) {
              const texture = iridescence.getIridescenceTexture();
              const textureInfo = iridescence.getIridescenceTextureInfo();
              iridescenceDef.iridescenceTexture = context.createTextureInfoDef(texture, textureInfo);
            }
            if (iridescence.getIridescenceThicknessTexture()) {
              const texture = iridescence.getIridescenceThicknessTexture();
              const textureInfo = iridescence.getIridescenceThicknessTextureInfo();
              iridescenceDef.iridescenceThicknessTexture = context.createTextureInfoDef(texture, textureInfo);
            }
          }
        });
        return this;
      }
    };
    KHRMaterialsIridescence.EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;
    ({
      R: R$3,
      G: G$3,
      B: B$2,
      A: A$2
    } = TextureChannel);
    PBRSpecularGlossiness = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
        this.propertyType = "PBRSpecularGlossiness";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          diffuseFactor: [1, 1, 1, 1],
          diffuseTexture: null,
          diffuseTextureInfo: new TextureInfo(this.graph, "diffuseTextureInfo"),
          specularFactor: [1, 1, 1],
          glossinessFactor: 1,
          specularGlossinessTexture: null,
          specularGlossinessTextureInfo: new TextureInfo(this.graph, "specularGlossinessTextureInfo")
        });
      }
      /**********************************************************************************************
       * Diffuse.
       */
      /** Diffuse; Linear-sRGB components. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */
      getDiffuseFactor() {
        return this.get("diffuseFactor");
      }
      /** Diffuse; Linear-sRGB components. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */
      setDiffuseFactor(factor) {
        return this.set("diffuseFactor", factor);
      }
      /**
       * Diffuse texture; sRGB. Alternative to baseColorTexture, used within the
       * spec/gloss PBR workflow.
       */
      getDiffuseTexture() {
        return this.getRef("diffuseTexture");
      }
      /**
       * Settings affecting the material's use of its diffuse texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getDiffuseTextureInfo() {
        return this.getRef("diffuseTexture") ? this.getRef("diffuseTextureInfo") : null;
      }
      /** Sets diffuse texture. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */
      setDiffuseTexture(texture) {
        return this.setRef("diffuseTexture", texture, {
          channels: R$3 | G$3 | B$2 | A$2,
          isColor: true
        });
      }
      /**********************************************************************************************
       * Specular.
       */
      /** Specular; linear multiplier. */
      getSpecularFactor() {
        return this.get("specularFactor");
      }
      /** Specular; linear multiplier. */
      setSpecularFactor(factor) {
        return this.set("specularFactor", factor);
      }
      /**********************************************************************************************
       * Glossiness.
       */
      /** Glossiness; linear multiplier. */
      getGlossinessFactor() {
        return this.get("glossinessFactor");
      }
      /** Glossiness; linear multiplier. */
      setGlossinessFactor(factor) {
        return this.set("glossinessFactor", factor);
      }
      /**********************************************************************************************
       * Specular/Glossiness.
       */
      /** Spec/gloss texture; linear multiplier. */
      getSpecularGlossinessTexture() {
        return this.getRef("specularGlossinessTexture");
      }
      /**
       * Settings affecting the material's use of its spec/gloss texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getSpecularGlossinessTextureInfo() {
        return this.getRef("specularGlossinessTexture") ? this.getRef("specularGlossinessTextureInfo") : null;
      }
      /** Spec/gloss texture; linear multiplier. */
      setSpecularGlossinessTexture(texture) {
        return this.setRef("specularGlossinessTexture", texture, {
          channels: R$3 | G$3 | B$2 | A$2
        });
      }
    };
    PBRSpecularGlossiness.EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    KHRMaterialsPBRSpecularGlossiness = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new PBRSpecularGlossiness property for use on a {@link Material}. */
      createPBRSpecularGlossiness() {
        return new PBRSpecularGlossiness(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        const textureDefs = jsonDoc.json.textures || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const specGloss = this.createPBRSpecularGlossiness();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specGloss);
            const specGlossDef = materialDef.extensions[KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            if (specGlossDef.diffuseFactor !== void 0) {
              specGloss.setDiffuseFactor(specGlossDef.diffuseFactor);
            }
            if (specGlossDef.specularFactor !== void 0) {
              specGloss.setSpecularFactor(specGlossDef.specularFactor);
            }
            if (specGlossDef.glossinessFactor !== void 0) {
              specGloss.setGlossinessFactor(specGlossDef.glossinessFactor);
            }
            if (specGlossDef.diffuseTexture !== void 0) {
              const textureInfoDef = specGlossDef.diffuseTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              specGloss.setDiffuseTexture(texture);
              context.setTextureInfo(specGloss.getDiffuseTextureInfo(), textureInfoDef);
            }
            if (specGlossDef.specularGlossinessTexture !== void 0) {
              const textureInfoDef = specGlossDef.specularGlossinessTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              specGloss.setSpecularGlossinessTexture(texture);
              context.setTextureInfo(specGloss.getSpecularGlossinessTextureInfo(), textureInfoDef);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const specGloss = material.getExtension(KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS);
          if (specGloss) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            const specGlossDef = materialDef.extensions[KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] = {
              diffuseFactor: specGloss.getDiffuseFactor(),
              specularFactor: specGloss.getSpecularFactor(),
              glossinessFactor: specGloss.getGlossinessFactor()
            };
            if (specGloss.getDiffuseTexture()) {
              const texture = specGloss.getDiffuseTexture();
              const textureInfo = specGloss.getDiffuseTextureInfo();
              specGlossDef.diffuseTexture = context.createTextureInfoDef(texture, textureInfo);
            }
            if (specGloss.getSpecularGlossinessTexture()) {
              const texture = specGloss.getSpecularGlossinessTexture();
              const textureInfo = specGloss.getSpecularGlossinessTextureInfo();
              specGlossDef.specularGlossinessTexture = context.createTextureInfoDef(texture, textureInfo);
            }
          }
        });
        return this;
      }
    };
    KHRMaterialsPBRSpecularGlossiness.EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    ({
      R: R$2,
      G: G$2,
      B: B$1,
      A: A$1
    } = TextureChannel);
    Sheen = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_SHEEN;
        this.propertyType = "Sheen";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          sheenColorFactor: [0, 0, 0],
          sheenColorTexture: null,
          sheenColorTextureInfo: new TextureInfo(this.graph, "sheenColorTextureInfo"),
          sheenRoughnessFactor: 0,
          sheenRoughnessTexture: null,
          sheenRoughnessTextureInfo: new TextureInfo(this.graph, "sheenRoughnessTextureInfo")
        });
      }
      /**********************************************************************************************
       * Sheen color.
       */
      /** Sheen; linear multiplier. */
      getSheenColorFactor() {
        return this.get("sheenColorFactor");
      }
      /** Sheen; linear multiplier. */
      setSheenColorFactor(factor) {
        return this.set("sheenColorFactor", factor);
      }
      /**
       * Sheen color texture, in sRGB colorspace.
       */
      getSheenColorTexture() {
        return this.getRef("sheenColorTexture");
      }
      /**
       * Settings affecting the material's use of its sheen color texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getSheenColorTextureInfo() {
        return this.getRef("sheenColorTexture") ? this.getRef("sheenColorTextureInfo") : null;
      }
      /** Sets sheen color texture. See {@link Sheen.getSheenColorTexture getSheenColorTexture}. */
      setSheenColorTexture(texture) {
        return this.setRef("sheenColorTexture", texture, {
          channels: R$2 | G$2 | B$1,
          isColor: true
        });
      }
      /**********************************************************************************************
       * Sheen roughness.
       */
      /** Sheen roughness; linear multiplier. See {@link Sheen.getSheenRoughnessTexture getSheenRoughnessTexture}. */
      getSheenRoughnessFactor() {
        return this.get("sheenRoughnessFactor");
      }
      /** Sheen roughness; linear multiplier. See {@link Sheen.getSheenRoughnessTexture getSheenRoughnessTexture}. */
      setSheenRoughnessFactor(factor) {
        return this.set("sheenRoughnessFactor", factor);
      }
      /**
       * Sheen roughness texture; linear multiplier. The `a` channel of this texture specifies
       * roughness, independent of the base layer's roughness.
       */
      getSheenRoughnessTexture() {
        return this.getRef("sheenRoughnessTexture");
      }
      /**
       * Settings affecting the material's use of its sheen roughness texture. If no texture is
       * attached, {@link TextureInfo} is `null`.
       */
      getSheenRoughnessTextureInfo() {
        return this.getRef("sheenRoughnessTexture") ? this.getRef("sheenRoughnessTextureInfo") : null;
      }
      /**
       * Sets sheen roughness texture.  The `a` channel of this texture specifies
       * roughness, independent of the base layer's roughness.
       */
      setSheenRoughnessTexture(texture) {
        return this.setRef("sheenRoughnessTexture", texture, {
          channels: A$1
        });
      }
    };
    Sheen.EXTENSION_NAME = KHR_MATERIALS_SHEEN;
    KHRMaterialsSheen = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_SHEEN;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new Sheen property for use on a {@link Material}. */
      createSheen() {
        return new Sheen(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        const textureDefs = jsonDoc.json.textures || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_SHEEN]) {
            const sheen = this.createSheen();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_SHEEN, sheen);
            const sheenDef = materialDef.extensions[KHR_MATERIALS_SHEEN];
            if (sheenDef.sheenColorFactor !== void 0) {
              sheen.setSheenColorFactor(sheenDef.sheenColorFactor);
            }
            if (sheenDef.sheenRoughnessFactor !== void 0) {
              sheen.setSheenRoughnessFactor(sheenDef.sheenRoughnessFactor);
            }
            if (sheenDef.sheenColorTexture !== void 0) {
              const textureInfoDef = sheenDef.sheenColorTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              sheen.setSheenColorTexture(texture);
              context.setTextureInfo(sheen.getSheenColorTextureInfo(), textureInfoDef);
            }
            if (sheenDef.sheenRoughnessTexture !== void 0) {
              const textureInfoDef = sheenDef.sheenRoughnessTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              sheen.setSheenRoughnessTexture(texture);
              context.setTextureInfo(sheen.getSheenRoughnessTextureInfo(), textureInfoDef);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const sheen = material.getExtension(KHR_MATERIALS_SHEEN);
          if (sheen) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            const sheenDef = materialDef.extensions[KHR_MATERIALS_SHEEN] = {
              sheenColorFactor: sheen.getSheenColorFactor(),
              sheenRoughnessFactor: sheen.getSheenRoughnessFactor()
            };
            if (sheen.getSheenColorTexture()) {
              const texture = sheen.getSheenColorTexture();
              const textureInfo = sheen.getSheenColorTextureInfo();
              sheenDef.sheenColorTexture = context.createTextureInfoDef(texture, textureInfo);
            }
            if (sheen.getSheenRoughnessTexture()) {
              const texture = sheen.getSheenRoughnessTexture();
              const textureInfo = sheen.getSheenRoughnessTextureInfo();
              sheenDef.sheenRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);
            }
          }
        });
        return this;
      }
    };
    KHRMaterialsSheen.EXTENSION_NAME = KHR_MATERIALS_SHEEN;
    ({
      R: R$1,
      G: G$1,
      B: B2,
      A: A2
    } = TextureChannel);
    Specular = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_SPECULAR;
        this.propertyType = "Specular";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          specularFactor: 1,
          specularTexture: null,
          specularTextureInfo: new TextureInfo(this.graph, "specularTextureInfo"),
          specularColorFactor: [1, 1, 1],
          specularColorTexture: null,
          specularColorTextureInfo: new TextureInfo(this.graph, "specularColorTextureInfo")
        });
      }
      /**********************************************************************************************
       * Specular.
       */
      /** Specular; linear multiplier. See {@link Specular.getSpecularTexture getSpecularTexture}. */
      getSpecularFactor() {
        return this.get("specularFactor");
      }
      /** Specular; linear multiplier. See {@link Specular.getSpecularTexture getSpecularTexture}. */
      setSpecularFactor(factor) {
        return this.set("specularFactor", factor);
      }
      /** Specular color; Linear-sRGB components. See {@link Specular.getSpecularTexture getSpecularTexture}. */
      getSpecularColorFactor() {
        return this.get("specularColorFactor");
      }
      /** Specular color; Linear-sRGB components. See {@link Specular.getSpecularTexture getSpecularTexture}. */
      setSpecularColorFactor(factor) {
        return this.set("specularColorFactor", factor);
      }
      /**
       * Specular texture; linear multiplier. Configures the strength of the specular reflection in
       * the dielectric BRDF. A value of zero disables the specular reflection, resulting in a pure
       * diffuse material.
       *
       * Only the alpha (A) channel is used for specular strength, but this texture may optionally
       * be packed with specular color (RGB) into a single texture.
       */
      getSpecularTexture() {
        return this.getRef("specularTexture");
      }
      /**
       * Settings affecting the material's use of its specular texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getSpecularTextureInfo() {
        return this.getRef("specularTexture") ? this.getRef("specularTextureInfo") : null;
      }
      /** Sets specular texture. See {@link Specular.getSpecularTexture getSpecularTexture}. */
      setSpecularTexture(texture) {
        return this.setRef("specularTexture", texture, {
          channels: A2
        });
      }
      /**
       * Specular color texture; linear multiplier. Defines the F0 color of the specular reflection
       * (RGB channels, encoded in sRGB) in the the dielectric BRDF.
       *
       * Only RGB channels are used here, but this texture may optionally be packed with a specular
       * factor (A) into a single texture.
       */
      getSpecularColorTexture() {
        return this.getRef("specularColorTexture");
      }
      /**
       * Settings affecting the material's use of its specular color texture. If no texture is
       * attached, {@link TextureInfo} is `null`.
       */
      getSpecularColorTextureInfo() {
        return this.getRef("specularColorTexture") ? this.getRef("specularColorTextureInfo") : null;
      }
      /** Sets specular color texture. See {@link Specular.getSpecularColorTexture getSpecularColorTexture}. */
      setSpecularColorTexture(texture) {
        return this.setRef("specularColorTexture", texture, {
          channels: R$1 | G$1 | B2,
          isColor: true
        });
      }
    };
    Specular.EXTENSION_NAME = KHR_MATERIALS_SPECULAR;
    KHRMaterialsSpecular = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_SPECULAR;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new Specular property for use on a {@link Material}. */
      createSpecular() {
        return new Specular(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        const textureDefs = jsonDoc.json.textures || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_SPECULAR]) {
            const specular = this.createSpecular();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_SPECULAR, specular);
            const specularDef = materialDef.extensions[KHR_MATERIALS_SPECULAR];
            if (specularDef.specularFactor !== void 0) {
              specular.setSpecularFactor(specularDef.specularFactor);
            }
            if (specularDef.specularColorFactor !== void 0) {
              specular.setSpecularColorFactor(specularDef.specularColorFactor);
            }
            if (specularDef.specularTexture !== void 0) {
              const textureInfoDef = specularDef.specularTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              specular.setSpecularTexture(texture);
              context.setTextureInfo(specular.getSpecularTextureInfo(), textureInfoDef);
            }
            if (specularDef.specularColorTexture !== void 0) {
              const textureInfoDef = specularDef.specularColorTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              specular.setSpecularColorTexture(texture);
              context.setTextureInfo(specular.getSpecularColorTextureInfo(), textureInfoDef);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const specular = material.getExtension(KHR_MATERIALS_SPECULAR);
          if (specular) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            const specularDef = materialDef.extensions[KHR_MATERIALS_SPECULAR] = {};
            if (specular.getSpecularFactor() !== 1) {
              specularDef.specularFactor = specular.getSpecularFactor();
            }
            if (!MathUtils.eq(specular.getSpecularColorFactor(), [1, 1, 1])) {
              specularDef.specularColorFactor = specular.getSpecularColorFactor();
            }
            if (specular.getSpecularTexture()) {
              const texture = specular.getSpecularTexture();
              const textureInfo = specular.getSpecularTextureInfo();
              specularDef.specularTexture = context.createTextureInfoDef(texture, textureInfo);
            }
            if (specular.getSpecularColorTexture()) {
              const texture = specular.getSpecularColorTexture();
              const textureInfo = specular.getSpecularColorTextureInfo();
              specularDef.specularColorTexture = context.createTextureInfoDef(texture, textureInfo);
            }
          }
        });
        return this;
      }
    };
    KHRMaterialsSpecular.EXTENSION_NAME = KHR_MATERIALS_SPECULAR;
    ({
      R: R2
    } = TextureChannel);
    Transmission = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_TRANSMISSION;
        this.propertyType = "Transmission";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          transmissionFactor: 0,
          transmissionTexture: null,
          transmissionTextureInfo: new TextureInfo(this.graph, "transmissionTextureInfo")
        });
      }
      /**********************************************************************************************
       * Transmission.
       */
      /** Transmission; linear multiplier. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */
      getTransmissionFactor() {
        return this.get("transmissionFactor");
      }
      /** Transmission; linear multiplier. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */
      setTransmissionFactor(factor) {
        return this.set("transmissionFactor", factor);
      }
      /**
       * Transmission texture; linear multiplier. The `r` channel of this texture specifies
       * transmission [0-1] of the material's surface. By default this is a thin transparency
       * effect, but volume effects (refraction, subsurface scattering) may be introduced with the
       * addition of the `KHR_materials_volume` extension.
       */
      getTransmissionTexture() {
        return this.getRef("transmissionTexture");
      }
      /**
       * Settings affecting the material's use of its transmission texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getTransmissionTextureInfo() {
        return this.getRef("transmissionTexture") ? this.getRef("transmissionTextureInfo") : null;
      }
      /** Sets transmission texture. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */
      setTransmissionTexture(texture) {
        return this.setRef("transmissionTexture", texture, {
          channels: R2
        });
      }
    };
    Transmission.EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;
    KHRMaterialsTransmission = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_TRANSMISSION;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new Transmission property for use on a {@link Material}. */
      createTransmission() {
        return new Transmission(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        const textureDefs = jsonDoc.json.textures || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_TRANSMISSION]) {
            const transmission = this.createTransmission();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_TRANSMISSION, transmission);
            const transmissionDef = materialDef.extensions[KHR_MATERIALS_TRANSMISSION];
            if (transmissionDef.transmissionFactor !== void 0) {
              transmission.setTransmissionFactor(transmissionDef.transmissionFactor);
            }
            if (transmissionDef.transmissionTexture !== void 0) {
              const textureInfoDef = transmissionDef.transmissionTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              transmission.setTransmissionTexture(texture);
              context.setTextureInfo(transmission.getTransmissionTextureInfo(), textureInfoDef);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const transmission = material.getExtension(KHR_MATERIALS_TRANSMISSION);
          if (transmission) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            const transmissionDef = materialDef.extensions[KHR_MATERIALS_TRANSMISSION] = {
              transmissionFactor: transmission.getTransmissionFactor()
            };
            if (transmission.getTransmissionTexture()) {
              const texture = transmission.getTransmissionTexture();
              const textureInfo = transmission.getTransmissionTextureInfo();
              transmissionDef.transmissionTexture = context.createTextureInfoDef(texture, textureInfo);
            }
          }
        });
        return this;
      }
    };
    KHRMaterialsTransmission.EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;
    Unlit = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_UNLIT;
        this.propertyType = "Unlit";
        this.parentTypes = [PropertyType.MATERIAL];
      }
    };
    Unlit.EXTENSION_NAME = KHR_MATERIALS_UNLIT;
    KHRMaterialsUnlit = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_UNLIT;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new Unlit property for use on a {@link Material}. */
      createUnlit() {
        return new Unlit(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const materialDefs = context.jsonDoc.json.materials || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_UNLIT]) {
            context.materials[materialIndex].setExtension(KHR_MATERIALS_UNLIT, this.createUnlit());
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          if (material.getExtension(KHR_MATERIALS_UNLIT)) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            materialDef.extensions[KHR_MATERIALS_UNLIT] = {};
          }
        });
        return this;
      }
    };
    KHRMaterialsUnlit.EXTENSION_NAME = KHR_MATERIALS_UNLIT;
    Mapping = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_VARIANTS;
        this.propertyType = "Mapping";
        this.parentTypes = ["MappingList"];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          material: null,
          variants: new RefSet()
        });
      }
      /** The {@link Material} designated for this {@link Primitive}, under the given variants. */
      getMaterial() {
        return this.getRef("material");
      }
      /** The {@link Material} designated for this {@link Primitive}, under the given variants. */
      setMaterial(material) {
        return this.setRef("material", material);
      }
      /** Adds a {@link Variant} to this mapping. */
      addVariant(variant) {
        return this.addRef("variants", variant);
      }
      /** Removes a {@link Variant} from this mapping. */
      removeVariant(variant) {
        return this.removeRef("variants", variant);
      }
      /** Lists {@link Variant}s in this mapping. */
      listVariants() {
        return this.listRefs("variants");
      }
    };
    Mapping.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;
    MappingList = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_VARIANTS;
        this.propertyType = "MappingList";
        this.parentTypes = [PropertyType.PRIMITIVE];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          mappings: new RefSet()
        });
      }
      /** Adds a {@link Mapping} to this mapping. */
      addMapping(mapping) {
        return this.addRef("mappings", mapping);
      }
      /** Removes a {@link Mapping} from the list for this {@link Primitive}. */
      removeMapping(mapping) {
        return this.removeRef("mappings", mapping);
      }
      /** Lists {@link Mapping}s in this {@link Primitive}. */
      listMappings() {
        return this.listRefs("mappings");
      }
    };
    MappingList.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;
    Variant = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_VARIANTS;
        this.propertyType = "Variant";
        this.parentTypes = ["MappingList"];
      }
    };
    Variant.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;
    KHRMaterialsVariants = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_VARIANTS;
      }
      /** Creates a new MappingList property. */
      createMappingList() {
        return new MappingList(this.document.getGraph());
      }
      /** Creates a new Variant property. */
      createVariant(name = "") {
        return new Variant(this.document.getGraph(), name);
      }
      /** Creates a new Mapping property. */
      createMapping() {
        return new Mapping(this.document.getGraph());
      }
      /** Lists all Variants on the current Document. */
      listVariants() {
        return Array.from(this.properties).filter((prop) => prop instanceof Variant);
      }
      /** @hidden */
      read(context) {
        const jsonDoc = context.jsonDoc;
        if (!jsonDoc.json.extensions || !jsonDoc.json.extensions[KHR_MATERIALS_VARIANTS]) return this;
        const variantsRootDef = jsonDoc.json.extensions[KHR_MATERIALS_VARIANTS];
        const variantDefs = variantsRootDef.variants || [];
        const variants = variantDefs.map((variantDef) => this.createVariant().setName(variantDef.name || ""));
        const meshDefs = jsonDoc.json.meshes || [];
        meshDefs.forEach((meshDef, meshIndex) => {
          const mesh = context.meshes[meshIndex];
          const primDefs = meshDef.primitives || [];
          primDefs.forEach((primDef, primIndex) => {
            if (!primDef.extensions || !primDef.extensions[KHR_MATERIALS_VARIANTS]) {
              return;
            }
            const mappingList = this.createMappingList();
            const variantPrimDef = primDef.extensions[KHR_MATERIALS_VARIANTS];
            for (const mappingDef of variantPrimDef.mappings) {
              const mapping = this.createMapping();
              if (mappingDef.material !== void 0) {
                mapping.setMaterial(context.materials[mappingDef.material]);
              }
              for (const variantIndex of mappingDef.variants || []) {
                mapping.addVariant(variants[variantIndex]);
              }
              mappingList.addMapping(mapping);
            }
            mesh.listPrimitives()[primIndex].setExtension(KHR_MATERIALS_VARIANTS, mappingList);
          });
        });
        return this;
      }
      /** @hidden */
      write(context) {
        const jsonDoc = context.jsonDoc;
        const variants = this.listVariants();
        if (!variants.length) return this;
        const variantDefs = [];
        const variantIndexMap = /* @__PURE__ */ new Map();
        for (const variant of variants) {
          variantIndexMap.set(variant, variantDefs.length);
          variantDefs.push(context.createPropertyDef(variant));
        }
        for (const mesh of this.document.getRoot().listMeshes()) {
          const meshIndex = context.meshIndexMap.get(mesh);
          mesh.listPrimitives().forEach((prim, primIndex) => {
            const mappingList = prim.getExtension(KHR_MATERIALS_VARIANTS);
            if (!mappingList) return;
            const primDef = context.jsonDoc.json.meshes[meshIndex].primitives[primIndex];
            const mappingDefs = mappingList.listMappings().map((mapping) => {
              const mappingDef = context.createPropertyDef(mapping);
              const material = mapping.getMaterial();
              if (material) {
                mappingDef.material = context.materialIndexMap.get(material);
              }
              mappingDef.variants = mapping.listVariants().map((variant) => variantIndexMap.get(variant));
              return mappingDef;
            });
            primDef.extensions = primDef.extensions || {};
            primDef.extensions[KHR_MATERIALS_VARIANTS] = {
              mappings: mappingDefs
            };
          });
        }
        jsonDoc.json.extensions = jsonDoc.json.extensions || {};
        jsonDoc.json.extensions[KHR_MATERIALS_VARIANTS] = {
          variants: variantDefs
        };
        return this;
      }
    };
    KHRMaterialsVariants.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;
    ({
      G: G2
    } = TextureChannel);
    Volume = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_MATERIALS_VOLUME;
        this.propertyType = "Volume";
        this.parentTypes = [PropertyType.MATERIAL];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          thicknessFactor: 0,
          thicknessTexture: null,
          thicknessTextureInfo: new TextureInfo(this.graph, "thicknessTexture"),
          attenuationDistance: Infinity,
          attenuationColor: [1, 1, 1]
        });
      }
      /**********************************************************************************************
       * Thickness.
       */
      /**
       * Thickness of the volume beneath the surface in meters in the local coordinate system of the
       * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume
       * boundary. The doubleSided property has no effect on volume boundaries.
       */
      getThicknessFactor() {
        return this.get("thicknessFactor");
      }
      /**
       * Thickness of the volume beneath the surface in meters in the local coordinate system of the
       * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume
       * boundary. The doubleSided property has no effect on volume boundaries.
       */
      setThicknessFactor(factor) {
        return this.set("thicknessFactor", factor);
      }
      /**
       * Texture that defines the thickness, stored in the G channel. This will be multiplied by
       * thicknessFactor.
       */
      getThicknessTexture() {
        return this.getRef("thicknessTexture");
      }
      /**
       * Settings affecting the material's use of its thickness texture. If no texture is attached,
       * {@link TextureInfo} is `null`.
       */
      getThicknessTextureInfo() {
        return this.getRef("thicknessTexture") ? this.getRef("thicknessTextureInfo") : null;
      }
      /**
       * Texture that defines the thickness, stored in the G channel. This will be multiplied by
       * thicknessFactor.
       */
      setThicknessTexture(texture) {
        return this.setRef("thicknessTexture", texture, {
          channels: G2
        });
      }
      /**********************************************************************************************
       * Attenuation.
       */
      /**
       * Density of the medium given as the average distance in meters that light travels in the
       * medium before interacting with a particle.
       */
      getAttenuationDistance() {
        return this.get("attenuationDistance");
      }
      /**
       * Density of the medium given as the average distance in meters that light travels in the
       * medium before interacting with a particle.
       */
      setAttenuationDistance(distance) {
        return this.set("attenuationDistance", distance);
      }
      /**
       * Color (linear) that white light turns into due to absorption when reaching the attenuation
       * distance.
       */
      getAttenuationColor() {
        return this.get("attenuationColor");
      }
      /**
       * Color (linear) that white light turns into due to absorption when reaching the attenuation
       * distance.
       */
      setAttenuationColor(color) {
        return this.set("attenuationColor", color);
      }
    };
    Volume.EXTENSION_NAME = KHR_MATERIALS_VOLUME;
    KHRMaterialsVolume = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MATERIALS_VOLUME;
        this.prereadTypes = [PropertyType.MESH];
        this.prewriteTypes = [PropertyType.MESH];
      }
      /** Creates a new Volume property for use on a {@link Material}. */
      createVolume() {
        return new Volume(this.document.getGraph());
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(_context) {
        return this;
      }
      /** @hidden */
      preread(context) {
        const jsonDoc = context.jsonDoc;
        const materialDefs = jsonDoc.json.materials || [];
        const textureDefs = jsonDoc.json.textures || [];
        materialDefs.forEach((materialDef, materialIndex) => {
          if (materialDef.extensions && materialDef.extensions[KHR_MATERIALS_VOLUME]) {
            const volume = this.createVolume();
            context.materials[materialIndex].setExtension(KHR_MATERIALS_VOLUME, volume);
            const volumeDef = materialDef.extensions[KHR_MATERIALS_VOLUME];
            if (volumeDef.thicknessFactor !== void 0) {
              volume.setThicknessFactor(volumeDef.thicknessFactor);
            }
            if (volumeDef.attenuationDistance !== void 0) {
              volume.setAttenuationDistance(volumeDef.attenuationDistance);
            }
            if (volumeDef.attenuationColor !== void 0) {
              volume.setAttenuationColor(volumeDef.attenuationColor);
            }
            if (volumeDef.thicknessTexture !== void 0) {
              const textureInfoDef = volumeDef.thicknessTexture;
              const texture = context.textures[textureDefs[textureInfoDef.index].source];
              volume.setThicknessTexture(texture);
              context.setTextureInfo(volume.getThicknessTextureInfo(), textureInfoDef);
            }
          }
        });
        return this;
      }
      /** @hidden */
      prewrite(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listMaterials().forEach((material) => {
          const volume = material.getExtension(KHR_MATERIALS_VOLUME);
          if (volume) {
            const materialIndex = context.materialIndexMap.get(material);
            const materialDef = jsonDoc.json.materials[materialIndex];
            materialDef.extensions = materialDef.extensions || {};
            const volumeDef = materialDef.extensions[KHR_MATERIALS_VOLUME] = {};
            if (volume.getThicknessFactor() > 0) {
              volumeDef.thicknessFactor = volume.getThicknessFactor();
            }
            if (Number.isFinite(volume.getAttenuationDistance())) {
              volumeDef.attenuationDistance = volume.getAttenuationDistance();
            }
            if (!MathUtils.eq(volume.getAttenuationColor(), [1, 1, 1])) {
              volumeDef.attenuationColor = volume.getAttenuationColor();
            }
            if (volume.getThicknessTexture()) {
              const texture = volume.getThicknessTexture();
              const textureInfo = volume.getThicknessTextureInfo();
              volumeDef.thicknessTexture = context.createTextureInfoDef(texture, textureInfo);
            }
          }
        });
        return this;
      }
    };
    KHRMaterialsVolume.EXTENSION_NAME = KHR_MATERIALS_VOLUME;
    KHRMeshQuantization = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_MESH_QUANTIZATION;
      }
      /** @hidden */
      read(_) {
        return this;
      }
      /** @hidden */
      write(_) {
        return this;
      }
    };
    KHRMeshQuantization.EXTENSION_NAME = KHR_MESH_QUANTIZATION;
    KTX2ImageUtils = class {
      match(array) {
        return array[0] === 171 && array[1] === 75 && array[2] === 84 && array[3] === 88 && array[4] === 32 && array[5] === 50 && array[6] === 48 && array[7] === 187 && array[8] === 13 && array[9] === 10 && array[10] === 26 && array[11] === 10;
      }
      getSize(array) {
        const container = read(array);
        return [container.pixelWidth, container.pixelHeight];
      }
      getChannels(array) {
        const container = read(array);
        const dfd = container.dataFormatDescriptor[0];
        if (dfd.colorModel === KHR_DF_MODEL_ETC1S) {
          return dfd.samples.length === 2 && (dfd.samples[1].channelType & 15) === 15 ? 4 : 3;
        } else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {
          return (dfd.samples[0].channelType & 15) === 3 ? 4 : 3;
        }
        throw new Error(`Unexpected KTX2 colorModel, "${dfd.colorModel}".`);
      }
      getVRAMByteLength(array) {
        const container = read(array);
        const hasAlpha = this.getChannels(array) > 3;
        let uncompressedBytes = 0;
        for (let i = 0; i < container.levels.length; i++) {
          const level = container.levels[i];
          if (level.uncompressedByteLength) {
            uncompressedBytes += level.uncompressedByteLength;
          } else {
            const levelWidth = Math.max(1, Math.floor(container.pixelWidth / Math.pow(2, i)));
            const levelHeight = Math.max(1, Math.floor(container.pixelHeight / Math.pow(2, i)));
            const blockSize = hasAlpha ? 16 : 8;
            uncompressedBytes += levelWidth / 4 * (levelHeight / 4) * blockSize;
          }
        }
        return uncompressedBytes;
      }
    };
    KHRTextureBasisu = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_TEXTURE_BASISU;
        this.prereadTypes = [PropertyType.TEXTURE];
      }
      /** @hidden */
      static register() {
        ImageUtils.registerFormat("image/ktx2", new KTX2ImageUtils());
      }
      /** @hidden */
      preread(context) {
        context.jsonDoc.json.textures.forEach((textureDef) => {
          if (textureDef.extensions && textureDef.extensions[KHR_TEXTURE_BASISU]) {
            const basisuDef = textureDef.extensions[KHR_TEXTURE_BASISU];
            textureDef.source = basisuDef.source;
          }
        });
        return this;
      }
      /** @hidden */
      read(_context) {
        return this;
      }
      /** @hidden */
      write(context) {
        const jsonDoc = context.jsonDoc;
        this.document.getRoot().listTextures().forEach((texture) => {
          if (texture.getMimeType() === "image/ktx2") {
            const imageIndex = context.imageIndexMap.get(texture);
            jsonDoc.json.textures.forEach((textureDef) => {
              if (textureDef.source === imageIndex) {
                textureDef.extensions = textureDef.extensions || {};
                textureDef.extensions[KHR_TEXTURE_BASISU] = {
                  source: textureDef.source
                };
                delete textureDef.source;
              }
            });
          }
        });
        return this;
      }
    };
    KHRTextureBasisu.EXTENSION_NAME = KHR_TEXTURE_BASISU;
    Transform = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_TEXTURE_TRANSFORM;
        this.propertyType = "Transform";
        this.parentTypes = [PropertyType.TEXTURE_INFO];
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          offset: [0, 0],
          rotation: 0,
          scale: [1, 1],
          texCoord: null
        });
      }
      getOffset() {
        return this.get("offset");
      }
      setOffset(offset) {
        return this.set("offset", offset);
      }
      getRotation() {
        return this.get("rotation");
      }
      setRotation(rotation) {
        return this.set("rotation", rotation);
      }
      getScale() {
        return this.get("scale");
      }
      setScale(scale) {
        return this.set("scale", scale);
      }
      getTexCoord() {
        return this.get("texCoord");
      }
      setTexCoord(texCoord) {
        return this.set("texCoord", texCoord);
      }
    };
    Transform.EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;
    KHRTextureTransform = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_TEXTURE_TRANSFORM;
      }
      /** Creates a new Transform property for use on a {@link TextureInfo}. */
      createTransform() {
        return new Transform(this.document.getGraph());
      }
      /** @hidden */
      read(context) {
        for (const [textureInfo, textureInfoDef] of Array.from(context.textureInfos.entries())) {
          if (!textureInfoDef.extensions || !textureInfoDef.extensions[KHR_TEXTURE_TRANSFORM]) continue;
          const transform = this.createTransform();
          const transformDef = textureInfoDef.extensions[KHR_TEXTURE_TRANSFORM];
          if (transformDef.offset !== void 0) transform.setOffset(transformDef.offset);
          if (transformDef.rotation !== void 0) transform.setRotation(transformDef.rotation);
          if (transformDef.scale !== void 0) transform.setScale(transformDef.scale);
          if (transformDef.texCoord !== void 0) transform.setTexCoord(transformDef.texCoord);
          textureInfo.setExtension(KHR_TEXTURE_TRANSFORM, transform);
        }
        return this;
      }
      /** @hidden */
      write(context) {
        const textureInfoEntries = Array.from(context.textureInfoDefMap.entries());
        for (const [textureInfo, textureInfoDef] of textureInfoEntries) {
          const transform = textureInfo.getExtension(KHR_TEXTURE_TRANSFORM);
          if (!transform) continue;
          textureInfoDef.extensions = textureInfoDef.extensions || {};
          const transformDef = {};
          const eq = MathUtils.eq;
          if (!eq(transform.getOffset(), [0, 0])) transformDef.offset = transform.getOffset();
          if (transform.getRotation() !== 0) transformDef.rotation = transform.getRotation();
          if (!eq(transform.getScale(), [1, 1])) transformDef.scale = transform.getScale();
          if (transform.getTexCoord() != null) transformDef.texCoord = transform.getTexCoord();
          textureInfoDef.extensions[KHR_TEXTURE_TRANSFORM] = transformDef;
        }
        return this;
      }
    };
    KHRTextureTransform.EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;
    PARENT_TYPES = [PropertyType.ROOT, PropertyType.SCENE, PropertyType.NODE, PropertyType.MESH, PropertyType.MATERIAL, PropertyType.TEXTURE, PropertyType.ANIMATION];
    Packet = class extends ExtensionProperty {
      init() {
        this.extensionName = KHR_XMP_JSON_LD;
        this.propertyType = "Packet";
        this.parentTypes = PARENT_TYPES;
      }
      getDefaults() {
        return Object.assign(super.getDefaults(), {
          context: {},
          properties: {}
        });
      }
      /**********************************************************************************************
       * Context.
       */
      /**
       * Returns the XMP context definition URL for the given term.
       * See: https://json-ld.org/spec/latest/json-ld/#the-context
       * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.
       */
      getContext() {
        return this.get("context");
      }
      /**
       * Sets the XMP context definition URL for the given term.
       * See: https://json-ld.org/spec/latest/json-ld/#the-context
       *
       * Example:
       *
       * ```typescript
       * packet.setContext({
       *   dc: 'http://purl.org/dc/elements/1.1/',
       *   model3d: 'https://schema.khronos.org/model3d/xsd/1.0/',
       * });
       * ```
       *
       * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.
       * @param definition URI for XMP namespace.
       */
      setContext(context) {
        return this.set("context", _extends3({}, context));
      }
      /**********************************************************************************************
       * Properties.
       */
      /**
       * Lists properties defined in this packet.
       *
       * Example:
       *
       * ```typescript
       * packet.listProperties(); // → ['dc:Language', 'dc:Creator', 'xmp:CreateDate']
       * ```
       */
      listProperties() {
        return Object.keys(this.get("properties"));
      }
      /**
       * Returns the value of a property, as a literal or JSONLD object.
       *
       * Example:
       *
       * ```typescript
       * packet.getProperty('dc:Creator'); // → {"@list": ["Acme, Inc."]}
       * packet.getProperty('dc:Title'); // → {"@type": "rdf:Alt", "rdf:_1": {"@language": "en-US", "@value": "Lamp"}}
       * packet.getProperty('xmp:CreateDate'); // → "2022-01-01"
       * ```
       */
      getProperty(name) {
        const properties = this.get("properties");
        return name in properties ? properties[name] : null;
      }
      /**
       * Sets the value of a property, as a literal or JSONLD object.
       *
       * Example:
       *
       * ```typescript
       * packet.setProperty('dc:Creator', {'@list': ['Acme, Inc.']});
       * packet.setProperty('dc:Title', {
       * 	'@type': 'rdf:Alt',
       * 	'rdf:_1': {'@language': 'en-US', '@value': 'Lamp'}
       * });
       * packet.setProperty('model3d:preferredSurfaces', {'@list': ['vertical']});
       * ```
       */
      setProperty(name, value2) {
        this._assertContext(name);
        const properties = _extends3({}, this.get("properties"));
        if (value2) {
          properties[name] = value2;
        } else {
          delete properties[name];
        }
        return this.set("properties", properties);
      }
      /**********************************************************************************************
       * Serialize / Deserialize.
       */
      /**
       * Serializes the packet context and properties to a JSONLD object.
       */
      toJSONLD() {
        const context = copyJSON(this.get("context"));
        const properties = copyJSON(this.get("properties"));
        return _extends3({
          "@context": context
        }, properties);
      }
      /**
       * Deserializes a JSONLD packet, then overwrites existing context and properties with
       * the new values.
       */
      fromJSONLD(jsonld) {
        jsonld = copyJSON(jsonld);
        const context = jsonld["@context"];
        if (context) this.set("context", context);
        delete jsonld["@context"];
        return this.set("properties", jsonld);
      }
      /**********************************************************************************************
       * Validation.
       */
      /** @hidden */
      _assertContext(name) {
        const prefix = name.split(":")[0];
        if (!(prefix in this.get("context"))) {
          throw new Error(`${KHR_XMP_JSON_LD}: Missing context for term, "${name}".`);
        }
      }
    };
    Packet.EXTENSION_NAME = KHR_XMP_JSON_LD;
    KHRXMP = class extends Extension {
      constructor(...args) {
        super(...args);
        this.extensionName = KHR_XMP_JSON_LD;
      }
      /** Creates a new XMP packet, to be linked with a {@link Document} or {@link Property Properties}. */
      createPacket() {
        return new Packet(this.document.getGraph());
      }
      /** Lists XMP packets currently defined in a {@link Document}. */
      listPackets() {
        return Array.from(this.properties);
      }
      /** @hidden */
      read(context) {
        var _context$jsonDoc$json;
        const extensionDef = (_context$jsonDoc$json = context.jsonDoc.json.extensions) == null ? void 0 : _context$jsonDoc$json[KHR_XMP_JSON_LD];
        if (!extensionDef || !extensionDef.packets) return this;
        const json = context.jsonDoc.json;
        const root = this.document.getRoot();
        const packets = extensionDef.packets.map((packetDef) => this.createPacket().fromJSONLD(packetDef));
        const defLists = [[json.asset], json.scenes, json.nodes, json.meshes, json.materials, json.images, json.animations];
        const propertyLists = [[root], root.listScenes(), root.listNodes(), root.listMeshes(), root.listMaterials(), root.listTextures(), root.listAnimations()];
        for (let i = 0; i < defLists.length; i++) {
          const defs = defLists[i] || [];
          for (let j = 0; j < defs.length; j++) {
            const def = defs[j];
            if (def.extensions && def.extensions[KHR_XMP_JSON_LD]) {
              const xmpDef = def.extensions[KHR_XMP_JSON_LD];
              propertyLists[i][j].setExtension(KHR_XMP_JSON_LD, packets[xmpDef.packet]);
            }
          }
        }
        return this;
      }
      /** @hidden */
      write(context) {
        const {
          json
        } = context.jsonDoc;
        const packetDefs = [];
        for (const packet of this.properties) {
          packetDefs.push(packet.toJSONLD());
          for (const parent of packet.listParents()) {
            let parentDef;
            switch (parent.propertyType) {
              case PropertyType.ROOT:
                parentDef = json.asset;
                break;
              case PropertyType.SCENE:
                parentDef = json.scenes[context.sceneIndexMap.get(parent)];
                break;
              case PropertyType.NODE:
                parentDef = json.nodes[context.nodeIndexMap.get(parent)];
                break;
              case PropertyType.MESH:
                parentDef = json.meshes[context.meshIndexMap.get(parent)];
                break;
              case PropertyType.MATERIAL:
                parentDef = json.materials[context.materialIndexMap.get(parent)];
                break;
              case PropertyType.TEXTURE:
                parentDef = json.images[context.imageIndexMap.get(parent)];
                break;
              case PropertyType.ANIMATION:
                parentDef = json.animations[context.animationIndexMap.get(parent)];
                break;
              default:
                parentDef = null;
                this.document.getLogger().warn(`[${KHR_XMP_JSON_LD}]: Unsupported parent property, "${parent.propertyType}"`);
                break;
            }
            if (!parentDef) continue;
            parentDef.extensions = parentDef.extensions || {};
            parentDef.extensions[KHR_XMP_JSON_LD] = {
              packet: packetDefs.length - 1
            };
          }
        }
        if (packetDefs.length > 0) {
          json.extensions = json.extensions || {};
          json.extensions[KHR_XMP_JSON_LD] = {
            packets: packetDefs
          };
        }
        return this;
      }
    };
    KHRXMP.EXTENSION_NAME = KHR_XMP_JSON_LD;
    KHRONOS_EXTENSIONS = [KHRDracoMeshCompression, KHRLightsPunctual, KHRMaterialsAnisotropy, KHRMaterialsClearcoat, KHRMaterialsDiffuseTransmission, KHRMaterialsDispersion, KHRMaterialsEmissiveStrength, KHRMaterialsIOR, KHRMaterialsIridescence, KHRMaterialsPBRSpecularGlossiness, KHRMaterialsSpecular, KHRMaterialsSheen, KHRMaterialsTransmission, KHRMaterialsUnlit, KHRMaterialsVariants, KHRMaterialsVolume, KHRMeshQuantization, KHRTextureBasisu, KHRTextureTransform, KHRXMP];
    ALL_EXTENSIONS = [EXTMeshGPUInstancing, EXTMeshoptCompression, EXTTextureAVIF, EXTTextureWebP, ...KHRONOS_EXTENSIONS];
  }
});

// lib/manifold-gltf.ts
var NAME, MERGE, ManifoldPrimitive, EXTManifold;
var init_manifold_gltf = __esm({
  "lib/manifold-gltf.ts"() {
    "use strict";
    init_index_modern();
    NAME = "EXT_mesh_manifold";
    MERGE = "MERGE";
    ManifoldPrimitive = class _ManifoldPrimitive extends ExtensionProperty {
      static EXTENSION_NAME = NAME;
      init() {
        _ManifoldPrimitive.EXTENSION_NAME = NAME;
        this.propertyType = "ManifoldPrimitive";
        this.parentTypes = [PropertyType.MESH];
      }
      getDefaults() {
        return Object.assign(
          super.getDefaults(),
          { manifoldPrimitive: null, mergeIndices: null, mergeValues: null }
        );
      }
      getMergeIndices() {
        return this.getRef("mergeIndices");
      }
      getMergeValues() {
        return this.getRef("mergeValues");
      }
      setMerge(indicesAccessor, valuesAccessor) {
        if (indicesAccessor.getCount() !== valuesAccessor.getCount())
          throw new Error("merge vectors must be the same length.");
        this.setRef("mergeIndices", indicesAccessor);
        return this.setRef("mergeValues", valuesAccessor);
      }
      getRunIndex() {
        return this.get("runIndex");
      }
      setRunIndex(runIndex) {
        return this.set("runIndex", runIndex);
      }
      setIndices(indices) {
        return this.setRef("indices", indices);
      }
      getIndices() {
        return this.getRef("indices");
      }
    };
    EXTManifold = class extends Extension {
      extensionName = NAME;
      prewriteTypes = [PropertyType.ACCESSOR];
      static EXTENSION_NAME = NAME;
      createManifoldPrimitive() {
        return new ManifoldPrimitive(this.document.getGraph());
      }
      read(context) {
        const { json } = context.jsonDoc;
        const meshDefs = json.meshes || [];
        meshDefs.forEach((meshDef, meshIndex) => {
          if (!meshDef.extensions || !meshDef.extensions[NAME]) return;
          const mesh = context.meshes[meshIndex];
          const manifoldPrimitive = this.createManifoldPrimitive();
          mesh.setExtension(NAME, manifoldPrimitive);
          const manifoldDef = meshDef.extensions[NAME];
          if (manifoldDef.manifoldPrimitive) {
            let count = 0;
            const runIndex = Array();
            runIndex.push(count);
            for (const primitive of mesh.listPrimitives()) {
              const indices = primitive.getIndices();
              if (!indices) {
                console.log("Skipping non-indexed primitive ", primitive.getName());
                continue;
              }
              count += indices.getCount();
              runIndex.push(count);
            }
            manifoldPrimitive.setRunIndex(runIndex);
            manifoldPrimitive.setIndices(
              context.accessors[manifoldDef.manifoldPrimitive.indices]
            );
          }
          if (manifoldDef.mergeIndices != null && manifoldDef.mergeValues != null) {
            manifoldPrimitive.setMerge(
              context.accessors[manifoldDef.mergeIndices],
              context.accessors[manifoldDef.mergeValues]
            );
          }
        });
        return this;
      }
      prewrite(context) {
        this.document.getRoot().listMeshes().forEach((mesh) => {
          const manifoldPrimitive = mesh.getExtension(NAME);
          if (!manifoldPrimitive) return;
          const indices = manifoldPrimitive.getIndices();
          context.addAccessorToUsageGroup(
            indices,
            WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER
          );
          const mergeFrom = manifoldPrimitive.getMergeIndices();
          const mergeTo = manifoldPrimitive.getMergeValues();
          if (!mergeFrom || !mergeTo) return;
          context.addAccessorToUsageGroup(mergeFrom, MERGE);
          context.addAccessorToUsageGroup(mergeTo, MERGE);
        });
        return this;
      }
      write(context) {
        const { json } = context.jsonDoc;
        this.document.getRoot().listMeshes().forEach((mesh) => {
          const manifoldPrimitive = mesh.getExtension(NAME);
          if (!manifoldPrimitive) return;
          const meshIndex = context.meshIndexMap.get(mesh);
          const meshDef = json.meshes[meshIndex];
          const runIndex = manifoldPrimitive.getRunIndex();
          const numPrimitive = runIndex.length - 1;
          if (numPrimitive !== meshDef.primitives.length) {
            throw new Error(
              "The number of primitives must be exactly one less than the length of runIndex."
            );
          }
          const mergeIndicesIndex = context.accessorIndexMap.get(manifoldPrimitive.getMergeIndices());
          const mergeValuesIndex = context.accessorIndexMap.get(manifoldPrimitive.getMergeValues());
          const mergeIndices = json.accessors[mergeIndicesIndex];
          const mergeValues = json.accessors[mergeValuesIndex];
          const existingPrimitive = meshDef.primitives[0];
          const primitive = {
            indices: context.accessorIndexMap.get(manifoldPrimitive.getIndices()),
            mode: existingPrimitive.mode,
            attributes: { "POSITION": existingPrimitive.attributes["POSITION"] }
          };
          const indices = json.accessors[primitive.indices];
          if (!indices) {
            return;
          }
          if (mergeIndices && mergeValues) {
            indices.sparse = {
              count: mergeIndices.count,
              indices: {
                bufferView: mergeIndices.bufferView,
                byteOffset: mergeIndices.byteOffset,
                componentType: mergeIndices.componentType
              },
              values: {
                bufferView: mergeValues.bufferView,
                byteOffset: mergeValues.byteOffset
              }
            };
          }
          for (let i = 0; i < numPrimitive; ++i) {
            const accessor = json.accessors[meshDef.primitives[i].indices];
            accessor.bufferView = indices.bufferView;
            accessor.byteOffset = indices.byteOffset + 4 * runIndex[i];
            accessor.count = runIndex[i + 1] - runIndex[i];
          }
          meshDef.extensions = meshDef.extensions || {};
          meshDef.extensions[NAME] = {
            manifoldPrimitive: primitive,
            mergeIndices: mergeIndicesIndex,
            mergeValues: mergeValuesIndex
          };
        });
        return this;
      }
    };
  }
});

// lib/gltf-io.ts
function setupIO(io) {
  return io.registerExtensions([EXTManifold]);
}
function writeMesh(doc, manifoldMesh, id2properties) {
  if (doc.getRoot().listBuffers().length === 0) {
    doc.createBuffer();
  }
  const buffer = doc.getRoot().listBuffers()[0];
  const manifoldExtension = doc.createExtension(EXTManifold);
  const mesh = doc.createMesh();
  const runIndex = Array();
  const attributeUnion = Array();
  const primitive2attributes = /* @__PURE__ */ new Map();
  const numRun = manifoldMesh.runIndex.length - 1;
  let lastID = -1;
  for (let run = 0; run < numRun; ++run) {
    const id = manifoldMesh.runOriginalID[run];
    if (id == lastID) {
      continue;
    }
    lastID = id;
    runIndex.push(manifoldMesh.runIndex[run]);
    const indices2 = doc.createAccessor("primitive indices of ID " + id).setBuffer(buffer).setType(Accessor.Type.SCALAR).setArray(new Uint32Array(1));
    const primitive = doc.createPrimitive().setIndices(indices2);
    const properties = id2properties.get(id);
    if (properties) {
      const { material, attributes } = properties;
      if (attributes.length < 1 || attributes[0] !== "POSITION")
        throw new Error('First attribute must be "POSITION".');
      primitive.setMaterial(material);
      primitive2attributes.set(primitive, attributes);
      properties.attributes.forEach((attribute, i) => {
        if (i >= attributeUnion.length) {
          attributeUnion.push(attribute);
        } else {
          const size = attributeDefs[attribute].components;
          const unionSize = attributeDefs[attributeUnion[i]].components;
          if (size != unionSize) {
            throw new Error(
              "Attribute sizes do not correspond: " + attribute + " and " + attributeUnion[i]
            );
          }
          if (attributeDefs[attributeUnion[i]].type == null) {
            attributeUnion[i] = attribute;
          }
        }
      });
    } else {
      primitive2attributes.set(primitive, ["POSITION"]);
    }
    mesh.addPrimitive(primitive);
  }
  runIndex.push(manifoldMesh.runIndex[numRun]);
  const numVert = manifoldMesh.numVert;
  const numProp = manifoldMesh.numProp;
  let offset = 0;
  attributeUnion.forEach((attribute, aIdx) => {
    const def = attributeDefs[attribute];
    if (def == null)
      throw new Error(attribute + " is not a recognized attribute.");
    if (def.type == null) {
      ++offset;
      return;
    }
    const n = def.components;
    if (offset + n > numProp) throw new Error("Too many attribute channels.");
    const array = new Float32Array(n * numVert);
    for (let v = 0; v < numVert; ++v) {
      for (let i = 0; i < n; ++i) {
        let x = manifoldMesh.vertProperties[numProp * v + offset + i];
        if (attribute == "COLOR_0") {
          x = Math.max(0, Math.min(1, x));
        }
        array[n * v + i] = x;
      }
    }
    const accessor = doc.createAccessor(attribute).setBuffer(buffer).setType(def.type).setArray(array);
    for (const primitive of mesh.listPrimitives()) {
      const attributes = primitive2attributes.get(primitive);
      if (attributes.length > aIdx && attributeDefs[attributes[aIdx]].type != null) {
        primitive.setAttribute(attribute, accessor);
      }
    }
    offset += n;
  });
  const manifoldPrimitive = manifoldExtension.createManifoldPrimitive();
  mesh.setExtension("EXT_mesh_manifold", manifoldPrimitive);
  const indices = doc.createAccessor("manifold indices").setBuffer(buffer).setType(Accessor.Type.SCALAR).setArray(manifoldMesh.triVerts);
  manifoldPrimitive.setIndices(indices);
  manifoldPrimitive.setRunIndex(runIndex);
  const vert2merge = [...Array(manifoldMesh.numVert).keys()];
  const ind = Array();
  const val = Array();
  if (manifoldMesh.mergeFromVert && manifoldMesh.mergeToVert) {
    for (const [i, from] of manifoldMesh.mergeFromVert.entries()) {
      vert2merge[from] = manifoldMesh.mergeToVert[i];
    }
    for (const [i, vert] of manifoldMesh.triVerts.entries()) {
      const newVert = vert2merge[vert];
      if (vert !== newVert) {
        ind.push(i);
        val.push(newVert);
      }
    }
  }
  if (ind.length > 0) {
    const indicesAccessor = doc.createAccessor("merge from").setBuffer(buffer).setType(Accessor.Type.SCALAR).setArray(new Uint32Array(ind));
    const valuesAccessor = doc.createAccessor("merge to").setBuffer(buffer).setType(Accessor.Type.SCALAR).setArray(new Uint32Array(val));
    manifoldPrimitive.setMerge(indicesAccessor, valuesAccessor);
  }
  return mesh;
}
var attributeDefs;
var init_gltf_io = __esm({
  "lib/gltf-io.ts"() {
    "use strict";
    init_index_modern();
    init_manifold_gltf();
    attributeDefs = {
      "POSITION": { type: Accessor.Type.VEC3, components: 3 },
      "NORMAL": { type: Accessor.Type.VEC3, components: 3 },
      "TANGENT": { type: Accessor.Type.VEC4, components: 4 },
      "TEXCOORD_0": { type: Accessor.Type.VEC2, components: 2 },
      "TEXCOORD_1": { type: Accessor.Type.VEC2, components: 2 },
      "COLOR_0": { type: Accessor.Type.VEC3, components: 3 },
      "JOINTS_0": { type: Accessor.Type.VEC4, components: 4 },
      "WEIGHTS_0": { type: Accessor.Type.VEC4, components: 4 },
      "SKIP_1": { type: null, components: 1 },
      "SKIP_2": { type: null, components: 2 },
      "SKIP_3": { type: null, components: 3 },
      "SKIP_4": { type: null, components: 4 }
    };
  }
});

// lib/garbage-collector.ts
var memoryRegistry, manifoldStaticFunctions, manifoldMemberFunctions, crossSectionStaticFunctions, crossSectionMemberFunctions, cleanup2, garbageCollectFunction, interceptMethods, garbageCollectManifold;
var init_garbage_collector = __esm({
  "lib/garbage-collector.ts"() {
    "use strict";
    memoryRegistry = Array();
    manifoldStaticFunctions = [
      "cube",
      "cylinder",
      "sphere",
      "tetrahedron",
      "extrude",
      "revolve",
      "compose",
      "union",
      "difference",
      "intersection",
      "levelSet",
      "smooth",
      "ofMesh",
      "hull"
    ];
    manifoldMemberFunctions = [
      "add",
      "subtract",
      "intersect",
      "decompose",
      "warp",
      "transform",
      "translate",
      "rotate",
      "scale",
      "mirror",
      "calculateCurvature",
      "calculateNormals",
      "smoothByNormals",
      "smoothOut",
      "refine",
      "refineToLength",
      "refineToTolerance",
      "setProperties",
      "setTolerance",
      "simplify",
      "asOriginal",
      "trimByPlane",
      "split",
      "splitByPlane",
      "slice",
      "project",
      "hull"
    ];
    crossSectionStaticFunctions = [
      "square",
      "circle",
      "union",
      "difference",
      "intersection",
      "compose",
      "ofPolygons",
      "hull"
    ];
    crossSectionMemberFunctions = [
      "add",
      "subtract",
      "intersect",
      "rectClip",
      "decompose",
      "transform",
      "translate",
      "rotate",
      "scale",
      "mirror",
      "simplify",
      "offset",
      "hull"
    ];
    cleanup2 = () => {
      for (const obj of memoryRegistry) {
        if (obj instanceof Array)
          for (const elem of obj) elem.delete();
        else
          obj.delete();
      }
      memoryRegistry.length = 0;
    };
    garbageCollectFunction = (originalFn) => {
      return (...args) => {
        const result = originalFn(...args);
        memoryRegistry.push(result);
        return result;
      };
    };
    interceptMethods = (target, methodNames) => {
      for (const name of methodNames) {
        const originalFn = target[name];
        target[name] = garbageCollectFunction(originalFn);
      }
    };
    garbageCollectManifold = (target) => {
      interceptMethods(target.Manifold, manifoldStaticFunctions);
      interceptMethods(target.Manifold.prototype, manifoldMemberFunctions);
      interceptMethods(target.CrossSection, crossSectionStaticFunctions);
      interceptMethods(
        target.CrossSection.prototype,
        crossSectionMemberFunctions
      );
      return target;
    };
  }
});

// lib/gltf-node.ts
async function anyToGLTFNodeList(any) {
  if (Array.isArray(any)) {
    return await any.map(anyToGLTFNodeList).reduce(
      async (acc, cur) => [...await acc, ...await cur],
      new Promise((resolve) => resolve([]))
    );
  } else if (any instanceof GLTFNode) {
    const node = any;
    if (!node.parent) return [node];
    return [await anyToGLTFNodeList(node.parent), node].flat();
  } else if (any.constructor.name === "Manifold") {
    const node = new GLTFNode();
    node.manifold = any;
    return [node];
  }
  throw new Error("Cannot convert model to GLTFNode!");
}
var GLTFMaterial, GLTFNode, nodes, GLTFNodeTracked, getGLTFNodes, resetGLTFNodes, cleanup3;
var init_gltf_node = __esm({
  "lib/gltf-node.ts"() {
    "use strict";
    GLTFMaterial = class {
      attributes;
      roughness;
      metallic;
      baseColorFactor;
      alpha;
      unlit;
      name;
    };
    GLTFNode = class _GLTFNode {
      _parent;
      manifold;
      translation;
      rotation;
      scale;
      material;
      name;
      constructor(parent) {
        this._parent = parent;
      }
      clone(parent) {
        const copy = new _GLTFNode(parent ?? this.parent);
        Object.assign(copy, this);
        return copy;
      }
      get parent() {
        return this._parent;
      }
    };
    nodes = new Array();
    GLTFNodeTracked = class extends GLTFNode {
      constructor(parent) {
        super(parent);
        nodes.push(this);
      }
    };
    getGLTFNodes = () => {
      return nodes;
    };
    resetGLTFNodes = () => {
      nodes.length = 0;
    };
    cleanup3 = () => {
      resetGLTFNodes();
    };
  }
});

// manifold.js
var Module, manifold_default;
var init_manifold = __esm({
  "manifold.js"() {
    "use strict";
    Module = (() => {
      var _scriptName = import.meta.url;
      return (async function(moduleArg = {}) {
        var moduleRtn;
        var Module2 = moduleArg;
        var readyPromiseResolve, readyPromiseReject;
        var readyPromise = new Promise((resolve, reject) => {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var ENVIRONMENT_IS_WEB = typeof window == "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
        var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
        if (ENVIRONMENT_IS_NODE) {
          const { createRequire } = await import("module");
          var require2 = createRequire(import.meta.url);
        }
        var _ManifoldInitialized = false;
        Module2.setup = function() {
          if (_ManifoldInitialized) return;
          _ManifoldInitialized = true;
          Module2.initTBB();
          function toVec(vec, list, f = ((x) => x)) {
            if (list) {
              for (let x of list) {
                vec.push_back(f(x));
              }
            }
            return vec;
          }
          function fromVec(vec, f = ((x) => x)) {
            const result = [];
            const size = vec.size();
            for (let i = 0; i < size; i++) result.push(f(vec.get(i)));
            return result;
          }
          function vec2polygons(vec, f = ((x) => x)) {
            const result = [];
            const nPoly = vec.size();
            for (let i = 0; i < nPoly; i++) {
              const v = vec.get(i);
              const nPts = v.size();
              const poly = [];
              for (let j = 0; j < nPts; j++) {
                poly.push(f(v.get(j)));
              }
              result.push(poly);
            }
            return result;
          }
          function polygons2vec(polygons) {
            if (polygons[0].length < 3) {
              polygons = [polygons];
            }
            return toVec(new Module2.Vector2_vec2(), polygons, (poly) => toVec(new Module2.Vector_vec2(), poly, (p) => {
              if (p instanceof Array) return { x: p[0], y: p[1] };
              return p;
            }));
          }
          function disposePolygons(polygonsVec) {
            for (let i = 0; i < polygonsVec.size(); i++) polygonsVec.get(i).delete();
            polygonsVec.delete();
          }
          function vararg2vec2(vec) {
            if (vec[0] instanceof Array) return { x: vec[0][0], y: vec[0][1] };
            if (typeof vec[0] == "number") return { x: vec[0] || 0, y: vec[1] || 0 };
            return vec[0];
          }
          function vararg2vec3(vec) {
            if (vec[0] instanceof Array) return { x: vec[0][0], y: vec[0][1], z: vec[0][2] };
            if (typeof vec[0] == "number") return { x: vec[0] || 0, y: vec[1] || 0, z: vec[2] || 0 };
            return vec[0];
          }
          function fillRuleToInt(fillRule) {
            return fillRule == "EvenOdd" ? 0 : fillRule == "NonZero" ? 1 : fillRule == "Negative" ? 3 : 2;
          }
          function joinTypeToInt(joinType) {
            return joinType == "Round" ? 1 : joinType == "Miter" ? 2 : 0;
          }
          const CrossSectionCtor = Module2.CrossSection;
          function cross(polygons, fillRule = "Positive") {
            if (polygons instanceof CrossSectionCtor) {
              return polygons;
            } else {
              const polygonsVec = polygons2vec(polygons);
              const cs = new CrossSectionCtor(polygonsVec, fillRuleToInt(fillRule));
              disposePolygons(polygonsVec);
              return cs;
            }
          }
          Module2.CrossSection.prototype.translate = function(...vec) {
            return this._Translate(vararg2vec2(vec));
          };
          Module2.CrossSection.prototype.scale = function(vec) {
            if (typeof vec == "number") {
              return this._Scale({ x: vec, y: vec });
            }
            return this._Scale(vararg2vec2([vec]));
          };
          Module2.CrossSection.prototype.mirror = function(vec) {
            return this._Mirror(vararg2vec2([vec]));
          };
          Module2.CrossSection.prototype.warp = function(func) {
            const wasmFuncPtr = addFunction(function(vec2Ptr) {
              const x = getValue(vec2Ptr, "double");
              const y = getValue(vec2Ptr + 8, "double");
              const vert = [x, y];
              func(vert);
              setValue(vec2Ptr, vert[0], "double");
              setValue(vec2Ptr + 8, vert[1], "double");
            }, "vi");
            const out2 = this._Warp(wasmFuncPtr);
            removeFunction(wasmFuncPtr);
            return out2;
          };
          Module2.CrossSection.prototype.decompose = function() {
            const vec = this._Decompose();
            const result = fromVec(vec);
            vec.delete();
            return result;
          };
          Module2.CrossSection.prototype.bounds = function() {
            const result = this._Bounds();
            return { min: ["x", "y"].map((f) => result.min[f]), max: ["x", "y"].map((f) => result.max[f]) };
          };
          Module2.CrossSection.prototype.offset = function(delta, joinType = "Round", miterLimit = 2, circularSegments = 0) {
            return this._Offset(delta, joinTypeToInt(joinType), miterLimit, circularSegments);
          };
          Module2.CrossSection.prototype.simplify = function(epsilon = 1e-6) {
            return this._Simplify(epsilon);
          };
          Module2.CrossSection.prototype.extrude = function(height, nDivisions = 0, twistDegrees = 0, scaleTop = [1, 1], center = false) {
            scaleTop = vararg2vec2([scaleTop]);
            const man = Module2._Extrude(this._ToPolygons(), height, nDivisions, twistDegrees, scaleTop);
            return center ? man.translate([0, 0, -height / 2]) : man;
          };
          Module2.CrossSection.prototype.revolve = function(circularSegments = 0, revolveDegrees = 360) {
            return Module2._Revolve(this._ToPolygons(), circularSegments, revolveDegrees);
          };
          Module2.CrossSection.prototype.add = function(other) {
            return this._add(cross(other));
          };
          Module2.CrossSection.prototype.subtract = function(other) {
            return this._subtract(cross(other));
          };
          Module2.CrossSection.prototype.intersect = function(other) {
            return this._intersect(cross(other));
          };
          Module2.CrossSection.prototype.toPolygons = function() {
            const vec = this._ToPolygons();
            const result = vec2polygons(vec, (v) => [v.x, v.y]);
            vec.delete();
            return result;
          };
          Module2.Manifold.prototype.smoothOut = function(minSharpAngle = 60, minSmoothness = 0) {
            return this._SmoothOut(minSharpAngle, minSmoothness);
          };
          Module2.Manifold.prototype.warp = function(func) {
            const wasmFuncPtr = addFunction(function(vec3Ptr) {
              const x = getValue(vec3Ptr, "double");
              const y = getValue(vec3Ptr + 8, "double");
              const z = getValue(vec3Ptr + 16, "double");
              const vert = [x, y, z];
              func(vert);
              setValue(vec3Ptr, vert[0], "double");
              setValue(vec3Ptr + 8, vert[1], "double");
              setValue(vec3Ptr + 16, vert[2], "double");
            }, "vi");
            const out2 = this._Warp(wasmFuncPtr);
            removeFunction(wasmFuncPtr);
            const status = out2.status();
            if (status !== "NoError") {
              throw new Module2.ManifoldError(status);
            }
            return out2;
          };
          Module2.Manifold.prototype.calculateNormals = function(normalIdx, minSharpAngle = 60) {
            return this._CalculateNormals(normalIdx, minSharpAngle);
          };
          Module2.Manifold.prototype.setProperties = function(numProp, func) {
            const oldNumProp = this.numProp();
            const wasmFuncPtr = addFunction(function(newPtr, vec3Ptr, oldPtr) {
              const newProp = [];
              for (let i = 0; i < numProp; ++i) {
                newProp[i] = getValue(newPtr + 8 * i, "double");
              }
              const pos = [];
              for (let i = 0; i < 3; ++i) {
                pos[i] = getValue(vec3Ptr + 8 * i, "double");
              }
              const oldProp = [];
              for (let i = 0; i < oldNumProp; ++i) {
                oldProp[i] = getValue(oldPtr + 8 * i, "double");
              }
              func(newProp, pos, oldProp);
              for (let i = 0; i < numProp; ++i) {
                setValue(newPtr + 8 * i, newProp[i], "double");
              }
            }, "viii");
            const out2 = this._SetProperties(numProp, wasmFuncPtr);
            removeFunction(wasmFuncPtr);
            return out2;
          };
          Module2.Manifold.prototype.translate = function(...vec) {
            return this._Translate(vararg2vec3(vec));
          };
          Module2.Manifold.prototype.rotate = function(xOrVec, y, z) {
            if (Array.isArray(xOrVec)) {
              return this._Rotate(...xOrVec);
            } else {
              return this._Rotate(xOrVec, y || 0, z || 0);
            }
          };
          Module2.Manifold.prototype.scale = function(vec) {
            if (typeof vec == "number") {
              return this._Scale({ x: vec, y: vec, z: vec });
            }
            return this._Scale(vararg2vec3([vec]));
          };
          Module2.Manifold.prototype.mirror = function(vec) {
            return this._Mirror(vararg2vec3([vec]));
          };
          Module2.Manifold.prototype.trimByPlane = function(normal, offset = 0) {
            return this._TrimByPlane(vararg2vec3([normal]), offset);
          };
          Module2.Manifold.prototype.slice = function(height = 0) {
            const polygonsVec = this._Slice(height);
            const result = new CrossSectionCtor(polygonsVec, fillRuleToInt("Positive"));
            disposePolygons(polygonsVec);
            return result;
          };
          Module2.Manifold.prototype.project = function() {
            const polygonsVec = this._Project();
            const result = new CrossSectionCtor(polygonsVec, fillRuleToInt("Positive"));
            disposePolygons(polygonsVec);
            return result;
          };
          Module2.Manifold.prototype.split = function(manifold) {
            const vec = this._Split(manifold);
            const result = fromVec(vec);
            vec.delete();
            return result;
          };
          Module2.Manifold.prototype.splitByPlane = function(normal, offset = 0) {
            const vec = this._SplitByPlane(vararg2vec3([normal]), offset);
            const result = fromVec(vec);
            vec.delete();
            return result;
          };
          Module2.Manifold.prototype.decompose = function() {
            const vec = this._Decompose();
            const result = fromVec(vec);
            vec.delete();
            return result;
          };
          Module2.Manifold.prototype.boundingBox = function() {
            const result = this._boundingBox();
            return { min: ["x", "y", "z"].map((f) => result.min[f]), max: ["x", "y", "z"].map((f) => result.max[f]) };
          };
          class Mesh4 {
            constructor({ numProp = 3, triVerts = new Uint32Array(), vertProperties = new Float32Array(), mergeFromVert, mergeToVert, runIndex, runOriginalID, faceID, halfedgeTangent, runTransform } = {}) {
              this.numProp = numProp;
              this.triVerts = triVerts;
              this.vertProperties = vertProperties;
              this.mergeFromVert = mergeFromVert;
              this.mergeToVert = mergeToVert;
              this.runIndex = runIndex;
              this.runOriginalID = runOriginalID;
              this.faceID = faceID;
              this.halfedgeTangent = halfedgeTangent;
              this.runTransform = runTransform;
            }
            get numTri() {
              return this.triVerts.length / 3;
            }
            get numVert() {
              return this.vertProperties.length / this.numProp;
            }
            get numRun() {
              return this.runOriginalID.length;
            }
            merge() {
              const { changed, mesh } = Module2._Merge(this);
              Object.assign(this, { ...mesh });
              return changed;
            }
            verts(tri) {
              return this.triVerts.subarray(3 * tri, 3 * (tri + 1));
            }
            position(vert) {
              return this.vertProperties.subarray(this.numProp * vert, this.numProp * vert + 3);
            }
            extras(vert) {
              return this.vertProperties.subarray(this.numProp * vert + 3, this.numProp * (vert + 1));
            }
            tangent(halfedge) {
              return this.halfedgeTangent.subarray(4 * halfedge, 4 * (halfedge + 1));
            }
            transform(run2) {
              const mat4 = new Array(16);
              for (const col of [0, 1, 2, 3]) {
                for (const row of [0, 1, 2]) {
                  mat4[4 * col + row] = this.runTransform[12 * run2 + 3 * col + row];
                }
              }
              mat4[15] = 1;
              return mat4;
            }
          }
          Module2.Mesh = Mesh4;
          Module2.Manifold.prototype.getMesh = function(normalIdx = -1) {
            return new Mesh4(this._GetMeshJS(normalIdx));
          };
          Module2.ManifoldError = function ManifoldError(code, ...args) {
            let message = "Unknown error";
            switch (code) {
              case "NonFiniteVertex":
                message = "Non-finite vertex";
                break;
              case "NotManifold":
                message = "Not manifold";
                break;
              case "VertexOutOfBounds":
                message = "Vertex index out of bounds";
                break;
              case "PropertiesWrongLength":
                message = "Properties have wrong length";
                break;
              case "MissingPositionProperties":
                message = "Less than three properties";
                break;
              case "MergeVectorsDifferentLengths":
                message = "Merge vectors have different lengths";
                break;
              case "MergeIndexOutOfBounds":
                message = "Merge index out of bounds";
                break;
              case "TransformWrongLength":
                message = "Transform vector has wrong length";
                break;
              case "RunIndexWrongLength":
                message = "Run index vector has wrong length";
                break;
              case "FaceIDWrongLength":
                message = "Face ID vector has wrong length";
              case "InvalidConstruction":
                message = "Manifold constructed with invalid parameters";
            }
            const base = Error.apply(this, [message, ...args]);
            base.name = this.name = "ManifoldError";
            this.message = base.message;
            this.stack = base.stack;
            this.code = code;
          };
          Module2.ManifoldError.prototype = Object.create(Error.prototype, { constructor: { value: Module2.ManifoldError, writable: true, configurable: true } });
          Module2.CrossSection = function(polygons, fillRule = "Positive") {
            const polygonsVec = polygons2vec(polygons);
            const cs = new CrossSectionCtor(polygonsVec, fillRuleToInt(fillRule));
            disposePolygons(polygonsVec);
            return cs;
          };
          Module2.CrossSection.ofPolygons = function(polygons, fillRule = "Positive") {
            return new Module2.CrossSection(polygons, fillRule);
          };
          Module2.CrossSection.square = function(...args) {
            let size = void 0;
            if (args.length == 0) size = { x: 1, y: 1 };
            else if (typeof args[0] == "number") size = { x: args[0], y: args[0] };
            else size = vararg2vec2(args);
            const center = args[1] || false;
            return Module2._Square(size, center);
          };
          Module2.CrossSection.circle = function(radius, circularSegments = 0) {
            return Module2._Circle(radius, circularSegments);
          };
          function crossSectionBatchbool(name) {
            return function(...args) {
              if (args.length == 1) args = args[0];
              const v = new Module2.Vector_crossSection();
              for (const cs of args) v.push_back(cross(cs));
              const result = Module2["_crossSection" + name](v);
              v.delete();
              return result;
            };
          }
          Module2.CrossSection.compose = crossSectionBatchbool("Compose");
          Module2.CrossSection.union = crossSectionBatchbool("UnionN");
          Module2.CrossSection.difference = crossSectionBatchbool("DifferenceN");
          Module2.CrossSection.intersection = crossSectionBatchbool("IntersectionN");
          function pushVec2(vec, ps) {
            toVec(vec, ps, (p) => {
              if (p instanceof Array) return { x: p[0], y: p[1] };
              return p;
            });
          }
          Module2.CrossSection.hull = function(...args) {
            if (args.length == 1) args = args[0];
            let pts = new Module2.Vector_vec2();
            for (const cs of args) {
              if (cs instanceof CrossSectionCtor) {
                Module2._crossSectionCollectVertices(pts, cs);
              } else if (cs instanceof Array && cs.length == 2 && typeof cs[0] == "number") {
                pts.push_back({ x: cs[0], y: cs[1] });
              } else if (cs.x) {
                pts.push_back(cs);
              } else {
                const wrap = cs[0].length == 2 && typeof cs[0][0] == "number" || cs[0].x;
                const polys = wrap ? [cs] : cs;
                for (const poly of polys) pushVec2(pts, poly);
              }
            }
            const result = Module2._crossSectionHullPoints(pts);
            pts.delete();
            return result;
          };
          Module2.CrossSection.prototype = Object.create(CrossSectionCtor.prototype);
          Object.defineProperty(Module2.CrossSection, Symbol.hasInstance, { get: () => (t) => t instanceof CrossSectionCtor });
          const ManifoldCtor = Module2.Manifold;
          Module2.Manifold = function(mesh) {
            const manifold = new ManifoldCtor(mesh);
            const status = manifold.status();
            if (status !== "NoError") {
              throw new Module2.ManifoldError(status);
            }
            return manifold;
          };
          Module2.Manifold.ofMesh = function(mesh) {
            return new Module2.Manifold(mesh);
          };
          Module2.Manifold.tetrahedron = function() {
            return Module2._Tetrahedron();
          };
          Module2.Manifold.cube = function(...args) {
            let size = void 0;
            if (args.length == 0) size = { x: 1, y: 1, z: 1 };
            else if (typeof args[0] == "number") size = { x: args[0], y: args[0], z: args[0] };
            else size = vararg2vec3(args);
            const center = args[1] || false;
            return Module2._Cube(size, center);
          };
          Module2.Manifold.cylinder = function(height, radiusLow, radiusHigh = -1, circularSegments = 0, center = false) {
            return Module2._Cylinder(height, radiusLow, radiusHigh, circularSegments, center);
          };
          Module2.Manifold.sphere = function(radius, circularSegments = 0) {
            return Module2._Sphere(radius, circularSegments);
          };
          Module2.Manifold.smooth = function(mesh, sharpenedEdges = []) {
            const sharp = new Module2.Vector_smoothness();
            toVec(sharp, sharpenedEdges);
            const result = Module2._Smooth(mesh, sharp);
            sharp.delete();
            return result;
          };
          Module2.Manifold.extrude = function(polygons, height, nDivisions = 0, twistDegrees = 0, scaleTop = [1, 1], center = false) {
            const cs = polygons instanceof CrossSectionCtor ? polygons : Module2.CrossSection(polygons, "Positive");
            return cs.extrude(height, nDivisions, twistDegrees, scaleTop, center);
          };
          Module2.Manifold.revolve = function(polygons, circularSegments = 0, revolveDegrees = 360) {
            const cs = polygons instanceof CrossSectionCtor ? polygons : Module2.CrossSection(polygons, "Positive");
            return cs.revolve(circularSegments, revolveDegrees);
          };
          Module2.Manifold.reserveIDs = function(n) {
            return Module2._ReserveIDs(n);
          };
          Module2.Manifold.compose = function(manifolds) {
            const vec = new Module2.Vector_manifold();
            toVec(vec, manifolds);
            const result = Module2._manifoldCompose(vec);
            vec.delete();
            return result;
          };
          function manifoldBatchbool(name) {
            return function(...args) {
              if (args.length == 1) args = args[0];
              const v = new Module2.Vector_manifold();
              for (const m of args) v.push_back(m);
              const result = Module2["_manifold" + name + "N"](v);
              v.delete();
              return result;
            };
          }
          Module2.Manifold.union = manifoldBatchbool("Union");
          Module2.Manifold.difference = manifoldBatchbool("Difference");
          Module2.Manifold.intersection = manifoldBatchbool("Intersection");
          Module2.Manifold.levelSet = function(sdf, bounds, edgeLength, level = 0, tolerance = -1) {
            const bounds2 = { min: { x: bounds.min[0], y: bounds.min[1], z: bounds.min[2] }, max: { x: bounds.max[0], y: bounds.max[1], z: bounds.max[2] } };
            const wasmFuncPtr = addFunction(function(vec3Ptr) {
              const x = getValue(vec3Ptr, "double");
              const y = getValue(vec3Ptr + 8, "double");
              const z = getValue(vec3Ptr + 16, "double");
              const vert = [x, y, z];
              return sdf(vert);
            }, "di");
            const out2 = Module2._LevelSet(wasmFuncPtr, bounds2, edgeLength, level, tolerance);
            removeFunction(wasmFuncPtr);
            return out2;
          };
          function pushVec3(vec, ps) {
            toVec(vec, ps, (p) => {
              if (p instanceof Array) return { x: p[0], y: p[1], z: p[2] };
              return p;
            });
          }
          Module2.Manifold.hull = function(...args) {
            if (args.length == 1) args = args[0];
            let pts = new Module2.Vector_vec3();
            for (const m of args) {
              if (m instanceof ManifoldCtor) {
                Module2._manifoldCollectVertices(pts, m);
              } else if (m instanceof Array && m.length == 3 && typeof m[0] == "number") {
                pts.push_back({ x: m[0], y: m[1], z: m[2] });
              } else if (m.x) {
                pts.push_back(m);
              } else {
                pushVec3(pts, m);
              }
            }
            const result = Module2._manifoldHullPoints(pts);
            pts.delete();
            return result;
          };
          Module2.Manifold.prototype = Object.create(ManifoldCtor.prototype);
          Object.defineProperty(Module2.Manifold, Symbol.hasInstance, { get: () => (t) => t instanceof ManifoldCtor });
          Module2.triangulate = function(polygons, epsilon = -1, allowConvex = true) {
            const polygonsVec = polygons2vec(polygons);
            const result = fromVec(Module2._Triangulate(polygonsVec, epsilon, allowConvex), (x) => [x[0], x[1], x[2]]);
            disposePolygons(polygonsVec);
            return result;
          };
        };
        var moduleOverrides = Object.assign({}, Module2);
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = (status, toThrow) => {
          throw toThrow;
        };
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module2["locateFile"]) {
            return Module2["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var readAsync, readBinary;
        if (ENVIRONMENT_IS_NODE) {
          var fs = require2("fs");
          var nodePath = require2("path");
          scriptDirectory = require2("url").fileURLToPath(new URL("./", import.meta.url));
          readBinary = (filename) => {
            filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
            var ret = fs.readFileSync(filename);
            return ret;
          };
          readAsync = (filename, binary = true) => {
            filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
            return new Promise((resolve, reject) => {
              fs.readFile(filename, binary ? void 0 : "utf8", (err3, data) => {
                if (err3) reject(err3);
                else resolve(binary ? data.buffer : data);
              });
            });
          };
          if (!Module2["thisProgram"] && process.argv.length > 1) {
            thisProgram = process.argv[1].replace(/\\/g, "/");
          }
          arguments_ = process.argv.slice(2);
          quit_ = (status, toThrow) => {
            process.exitCode = status;
            throw toThrow;
          };
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document != "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptName) {
            scriptDirectory = _scriptName;
          }
          if (scriptDirectory.startsWith("blob:")) {
            scriptDirectory = "";
          } else {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
          }
          {
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = (url) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = (url) => {
              if (isFileURI(url)) {
                return new Promise((reject, resolve) => {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, true);
                  xhr.responseType = "arraybuffer";
                  xhr.onload = () => {
                    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                      resolve(xhr.response);
                    }
                    reject(xhr.status);
                  };
                  xhr.onerror = reject;
                  xhr.send(null);
                });
              }
              return fetch(url, { credentials: "same-origin" }).then((response) => {
                if (response.ok) {
                  return response.arrayBuffer();
                }
                return Promise.reject(new Error(response.status + " : " + response.url));
              });
            };
          }
        } else {
        }
        var out = Module2["print"] || console.log.bind(console);
        var err2 = Module2["printErr"] || console.error.bind(console);
        Object.assign(Module2, moduleOverrides);
        moduleOverrides = null;
        if (Module2["arguments"]) arguments_ = Module2["arguments"];
        if (Module2["thisProgram"]) thisProgram = Module2["thisProgram"];
        if (Module2["quit"]) quit_ = Module2["quit"];
        var wasmBinary;
        if (Module2["wasmBinary"]) wasmBinary = Module2["wasmBinary"];
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateMemoryViews() {
          var b = wasmMemory.buffer;
          Module2["HEAP8"] = HEAP8 = new Int8Array(b);
          Module2["HEAP16"] = HEAP16 = new Int16Array(b);
          Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);
          Module2["HEAPU16"] = HEAPU16 = new Uint16Array(b);
          Module2["HEAP32"] = HEAP32 = new Int32Array(b);
          Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);
          Module2["HEAPF32"] = HEAPF32 = new Float32Array(b);
          Module2["HEAPF64"] = HEAPF64 = new Float64Array(b);
        }
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        function preRun() {
          if (Module2["preRun"]) {
            if (typeof Module2["preRun"] == "function") Module2["preRun"] = [Module2["preRun"]];
            while (Module2["preRun"].length) {
              addOnPreRun(Module2["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          runtimeInitialized = true;
          callRuntimeCallbacks(__ATINIT__);
        }
        function postRun() {
          if (Module2["postRun"]) {
            if (typeof Module2["postRun"] == "function") Module2["postRun"] = [Module2["postRun"]];
            while (Module2["postRun"].length) {
              addOnPostRun(Module2["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var runDependencyWatcher = null;
        var dependenciesFulfilled = null;
        function addRunDependency(id) {
          runDependencies++;
          Module2["monitorRunDependencies"]?.(runDependencies);
        }
        function removeRunDependency(id) {
          runDependencies--;
          Module2["monitorRunDependencies"]?.(runDependencies);
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        function abort(what) {
          Module2["onAbort"]?.(what);
          what = "Aborted(" + what + ")";
          err2(what);
          ABORT = true;
          EXITSTATUS = 1;
          what += ". Build with -sASSERTIONS for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
        var isFileURI = (filename) => filename.startsWith("file://");
        function findWasmBinary() {
          if (Module2["locateFile"]) {
            var f = "manifold.wasm";
            if (!isDataURI(f)) {
              return locateFile(f);
            }
            return f;
          }
          return new URL("manifold.wasm", import.meta.url).href;
        }
        var wasmBinaryFile;
        function getBinarySync(file) {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(file);
          }
          throw "both async and sync fetching of the wasm failed";
        }
        function getBinaryPromise(binaryFile) {
          if (!wasmBinary) {
            return readAsync(binaryFile).then((response) => new Uint8Array(response), () => getBinarySync(binaryFile));
          }
          return Promise.resolve().then(() => getBinarySync(binaryFile));
        }
        function instantiateArrayBuffer(binaryFile, imports, receiver) {
          return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
            err2(`failed to asynchronously prepare wasm: ${reason}`);
            abort(reason);
          });
        }
        function instantiateAsync(binary, binaryFile, imports, callback) {
          if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
            return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
              var result = WebAssembly.instantiateStreaming(response, imports);
              return result.then(callback, function(reason) {
                err2(`wasm streaming compile failed: ${reason}`);
                err2("falling back to ArrayBuffer instantiation");
                return instantiateArrayBuffer(binaryFile, imports, callback);
              });
            });
          }
          return instantiateArrayBuffer(binaryFile, imports, callback);
        }
        function getWasmImports() {
          return { a: wasmImports };
        }
        function createWasm() {
          var info = getWasmImports();
          function receiveInstance(instance, module) {
            wasmExports = instance.exports;
            wasmExports = applySignatureConversions(wasmExports);
            wasmMemory = wasmExports["J"];
            updateMemoryViews();
            wasmTable = wasmExports["M"];
            addOnInit(wasmExports["K"]);
            removeRunDependency("wasm-instantiate");
            return wasmExports;
          }
          addRunDependency("wasm-instantiate");
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"]);
          }
          if (Module2["instantiateWasm"]) {
            try {
              return Module2["instantiateWasm"](info, receiveInstance);
            } catch (e) {
              err2(`Module.instantiateWasm callback failed with error: ${e}`);
              readyPromiseReject(e);
            }
          }
          if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();
          instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
          return {};
        }
        var callRuntimeCallbacks = (callbacks) => {
          while (callbacks.length > 0) {
            callbacks.shift()(Module2);
          }
        };
        function getValue(ptr, type = "i8") {
          if (type.endsWith("*")) type = "*";
          switch (type) {
            case "i1":
              return HEAP8[ptr >>> 0];
            case "i8":
              return HEAP8[ptr >>> 0];
            case "i16":
              return HEAP16[ptr >>> 1 >>> 0];
            case "i32":
              return HEAP32[ptr >>> 2 >>> 0];
            case "i64":
              abort("to do getValue(i64) use WASM_BIGINT");
            case "float":
              return HEAPF32[ptr >>> 2 >>> 0];
            case "double":
              return HEAPF64[ptr >>> 3 >>> 0];
            case "*":
              return HEAPU32[ptr >>> 2 >>> 0];
            default:
              abort(`invalid type for getValue: ${type}`);
          }
        }
        var noExitRuntime = Module2["noExitRuntime"] || true;
        function setValue(ptr, value2, type = "i8") {
          if (type.endsWith("*")) type = "*";
          switch (type) {
            case "i1":
              HEAP8[ptr >>> 0] = value2;
              break;
            case "i8":
              HEAP8[ptr >>> 0] = value2;
              break;
            case "i16":
              HEAP16[ptr >>> 1 >>> 0] = value2;
              break;
            case "i32":
              HEAP32[ptr >>> 2 >>> 0] = value2;
              break;
            case "i64":
              abort("to do setValue(i64) use WASM_BIGINT");
            case "float":
              HEAPF32[ptr >>> 2 >>> 0] = value2;
              break;
            case "double":
              HEAPF64[ptr >>> 3 >>> 0] = value2;
              break;
            case "*":
              HEAPU32[ptr >>> 2 >>> 0] = value2;
              break;
            default:
              abort(`invalid type for setValue: ${type}`);
          }
        }
        class ExceptionInfo {
          constructor(excPtr) {
            this.excPtr = excPtr;
            this.ptr = excPtr - 24;
          }
          set_type(type) {
            HEAPU32[this.ptr + 4 >>> 2 >>> 0] = type;
          }
          get_type() {
            return HEAPU32[this.ptr + 4 >>> 2 >>> 0];
          }
          set_destructor(destructor) {
            HEAPU32[this.ptr + 8 >>> 2 >>> 0] = destructor;
          }
          get_destructor() {
            return HEAPU32[this.ptr + 8 >>> 2 >>> 0];
          }
          set_caught(caught) {
            caught = caught ? 1 : 0;
            HEAP8[this.ptr + 12 >>> 0] = caught;
          }
          get_caught() {
            return HEAP8[this.ptr + 12 >>> 0] != 0;
          }
          set_rethrown(rethrown) {
            rethrown = rethrown ? 1 : 0;
            HEAP8[this.ptr + 13 >>> 0] = rethrown;
          }
          get_rethrown() {
            return HEAP8[this.ptr + 13 >>> 0] != 0;
          }
          init(type, destructor) {
            this.set_adjusted_ptr(0);
            this.set_type(type);
            this.set_destructor(destructor);
          }
          set_adjusted_ptr(adjustedPtr) {
            HEAPU32[this.ptr + 16 >>> 2 >>> 0] = adjustedPtr;
          }
          get_adjusted_ptr() {
            return HEAPU32[this.ptr + 16 >>> 2 >>> 0];
          }
          get_exception_ptr() {
            var isPointer = ___cxa_is_pointer_type(this.get_type());
            if (isPointer) {
              return HEAPU32[this.excPtr >>> 2 >>> 0];
            }
            var adjusted = this.get_adjusted_ptr();
            if (adjusted !== 0) return adjusted;
            return this.excPtr;
          }
        }
        var exceptionLast = 0;
        var uncaughtExceptionCount = 0;
        function ___cxa_throw(ptr, type, destructor) {
          ptr >>>= 0;
          type >>>= 0;
          destructor >>>= 0;
          var info = new ExceptionInfo(ptr);
          info.init(type, destructor);
          exceptionLast = ptr;
          uncaughtExceptionCount++;
          throw exceptionLast;
        }
        var __abort_js = () => {
          abort("");
        };
        var structRegistrations = {};
        var runDestructors = (destructors) => {
          while (destructors.length) {
            var ptr = destructors.pop();
            var del = destructors.pop();
            del(ptr);
          }
        };
        function readPointer(pointer) {
          return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
        }
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var InternalError;
        var throwInternalError = (message) => {
          throw new InternalError(message);
        };
        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
          myTypes.forEach(function(type) {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
            }
          }
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach((dt, i) => {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(() => {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (0 === unregisteredTypes.length) {
            onComplete(typeConverters);
          }
        };
        var __embind_finalize_value_object = function(structType) {
          structType >>>= 0;
          var reg = structRegistrations[structType];
          delete structRegistrations[structType];
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          var fieldRecords = reg.fields;
          var fieldTypes = fieldRecords.map((field) => field.getterReturnType).concat(fieldRecords.map((field) => field.setterArgumentType));
          whenDependentTypesAreResolved([structType], fieldTypes, (fieldTypes2) => {
            var fields = {};
            fieldRecords.forEach((field, i) => {
              var fieldName = field.fieldName;
              var getterReturnType = fieldTypes2[i];
              var getter = field.getter;
              var getterContext = field.getterContext;
              var setterArgumentType = fieldTypes2[i + fieldRecords.length];
              var setter = field.setter;
              var setterContext = field.setterContext;
              fields[fieldName] = { read: (ptr) => getterReturnType["fromWireType"](getter(getterContext, ptr)), write: (ptr, o) => {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              } };
            });
            return [{ name: reg.name, fromWireType: (ptr) => {
              var rv = {};
              for (var i in fields) {
                rv[i] = fields[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, toWireType: (destructors, o) => {
              for (var fieldName in fields) {
                if (!(fieldName in o)) {
                  throw new TypeError(`Missing field: "${fieldName}"`);
                }
              }
              var ptr = rawConstructor();
              for (fieldName in fields) {
                fields[fieldName].write(ptr, o[fieldName]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, destructorFunction: rawDestructor }];
          });
        };
        function __embind_register_bigint(primitiveType, name, size, minRange, maxRange) {
          primitiveType >>>= 0;
          name >>>= 0;
          size >>>= 0;
        }
        var embind_init_charCodes = () => {
          var codes = new Array(256);
          for (var i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
          }
          embind_charCodes = codes;
        };
        var embind_charCodes;
        var readLatin1String = (ptr) => {
          var ret = "";
          var c = ptr;
          while (HEAPU8[c >>> 0]) {
            ret += embind_charCodes[HEAPU8[c++ >>> 0]];
          }
          return ret;
        };
        var BindingError;
        var throwBindingError = (message) => {
          throw new BindingError(message);
        };
        function sharedRegisterType(rawType, registeredInstance, options = {}) {
          var name = registeredInstance.name;
          if (!rawType) {
            throwBindingError(`type "${name}" must have a positive integer typeid pointer`);
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError(`Cannot register type '${name}' twice`);
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach((cb) => cb());
          }
        }
        function registerType(rawType, registeredInstance, options = {}) {
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          return sharedRegisterType(rawType, registeredInstance, options);
        }
        var GenericWireTypeSize = 8;
        function __embind_register_bool(rawType, name, trueValue, falseValue) {
          rawType >>>= 0;
          name >>>= 0;
          name = readLatin1String(name);
          registerType(rawType, { name, fromWireType: function(wt) {
            return !!wt;
          }, toWireType: function(destructors, o) {
            return o ? trueValue : falseValue;
          }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: function(pointer) {
            return this["fromWireType"](HEAPU8[pointer >>> 0]);
          }, destructorFunction: null });
        }
        var shallowCopyInternalPointer = (o) => ({ count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType });
        var throwInstanceAlreadyDeleted = (obj) => {
          function getInstanceTypeName(handle) {
            return handle.$$.ptrType.registeredClass.name;
          }
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        };
        var finalizationRegistry = false;
        var detachFinalizer = (handle) => {
        };
        var runDestructor = ($$) => {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        };
        var releaseClassHandle = ($$) => {
          $$.count.value -= 1;
          var toDelete = 0 === $$.count.value;
          if (toDelete) {
            runDestructor($$);
          }
        };
        var downcastPointer = (ptr, ptrClass, desiredClass) => {
          if (ptrClass === desiredClass) {
            return ptr;
          }
          if (void 0 === desiredClass.baseClass) {
            return null;
          }
          var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        };
        var registeredPointers = {};
        var getInheritedInstanceCount = () => Object.keys(registeredInstances).length;
        var getLiveInheritedInstances = () => {
          var rv = [];
          for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        };
        var deletionQueue = [];
        var flushPendingDeletes = () => {
          while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
          }
        };
        var delayFunction;
        var setDelayFunction = (fn) => {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        };
        var init_embind = () => {
          Module2["getInheritedInstanceCount"] = getInheritedInstanceCount;
          Module2["getLiveInheritedInstances"] = getLiveInheritedInstances;
          Module2["flushPendingDeletes"] = flushPendingDeletes;
          Module2["setDelayFunction"] = setDelayFunction;
        };
        var registeredInstances = {};
        var getBasestPointer = (class_, ptr) => {
          if (ptr === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
          }
          return ptr;
        };
        var getInheritedInstance = (class_, ptr) => {
          ptr = getBasestPointer(class_, ptr);
          return registeredInstances[ptr];
        };
        var makeClassHandle = (prototype, record) => {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = { value: 1 };
          return attachFinalizer(Object.create(prototype, { $$: { value: record, writable: true } }));
        };
        function RegisteredPointer_fromWireType(ptr) {
          var rawPointer = this.getPointee(ptr);
          if (!rawPointer) {
            this.destructor(ptr);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (void 0 !== registeredInstance) {
            if (0 === registeredInstance.$$.count.value) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
            }
          }
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
          }
        }
        var attachFinalizer = (handle) => {
          if ("undefined" === typeof FinalizationRegistry) {
            attachFinalizer = (handle2) => handle2;
            return handle;
          }
          finalizationRegistry = new FinalizationRegistry((info) => {
            releaseClassHandle(info.$$);
          });
          attachFinalizer = (handle2) => {
            var $$ = handle2.$$;
            var hasSmartPtr = !!$$.smartPtr;
            if (hasSmartPtr) {
              var info = { $$ };
              finalizationRegistry.register(handle2, info, handle2);
            }
            return handle2;
          };
          detachFinalizer = (handle2) => finalizationRegistry.unregister(handle2);
          return attachFinalizer(handle);
        };
        var init_ClassHandle = () => {
          Object.assign(ClassHandle.prototype, { isAliasOf(other) {
            if (!(this instanceof ClassHandle)) {
              return false;
            }
            if (!(other instanceof ClassHandle)) {
              return false;
            }
            var leftClass = this.$$.ptrType.registeredClass;
            var left = this.$$.ptr;
            other.$$ = other.$$;
            var rightClass = other.$$.ptrType.registeredClass;
            var right = other.$$.ptr;
            while (leftClass.baseClass) {
              left = leftClass.upcast(left);
              leftClass = leftClass.baseClass;
            }
            while (rightClass.baseClass) {
              right = rightClass.upcast(right);
              rightClass = rightClass.baseClass;
            }
            return leftClass === rightClass && left === right;
          }, clone() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.preservePointerOnDelete) {
              this.$$.count.value += 1;
              return this;
            } else {
              var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
              clone.$$.count.value += 1;
              clone.$$.deleteScheduled = false;
              return clone;
            }
          }, delete() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            detachFinalizer(this);
            releaseClassHandle(this.$$);
            if (!this.$$.preservePointerOnDelete) {
              this.$$.smartPtr = void 0;
              this.$$.ptr = void 0;
            }
          }, isDeleted() {
            return !this.$$.ptr;
          }, deleteLater() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            deletionQueue.push(this);
            if (deletionQueue.length === 1 && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
            this.$$.deleteScheduled = true;
            return this;
          } });
        };
        function ClassHandle() {
        }
        var createNamedFunction = (name, body) => Object.defineProperty(body, "name", { value: name });
        var ensureOverloadTable = (proto, methodName, humanName) => {
          if (void 0 === proto[methodName].overloadTable) {
            var prevFunc = proto[methodName];
            proto[methodName] = function(...args) {
              if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
                throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
              }
              return proto[methodName].overloadTable[args.length].apply(this, args);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        };
        var exposePublicSymbol = (name, value2, numArguments) => {
          if (Module2.hasOwnProperty(name)) {
            if (void 0 === numArguments || void 0 !== Module2[name].overloadTable && void 0 !== Module2[name].overloadTable[numArguments]) {
              throwBindingError(`Cannot register public name '${name}' twice`);
            }
            ensureOverloadTable(Module2, name, name);
            if (Module2.hasOwnProperty(numArguments)) {
              throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
            }
            Module2[name].overloadTable[numArguments] = value2;
          } else {
            Module2[name] = value2;
            if (void 0 !== numArguments) {
              Module2[name].numArguments = numArguments;
            }
          }
        };
        var char_0 = 48;
        var char_9 = 57;
        var makeLegalFunctionName = (name) => {
          if (void 0 === name) {
            return "_unknown";
          }
          name = name.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return `_${name}`;
          }
          return name;
        };
        function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        var upcastPointer = (ptr, ptrClass, desiredClass) => {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
          }
          return ptr;
        };
        function constNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
          }
          if (!handle.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function genericPointerToWireType(destructors, handle) {
          var ptr;
          if (handle === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
            } else {
              return 0;
            }
          }
          if (!handle || !handle.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
          }
          if (!handle.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (void 0 === handle.$$.smartPtr) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
                }
                break;
              case 1:
                ptr = handle.$$.smartPtr;
                break;
              case 2:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  var clonedHandle = handle["clone"]();
                  ptr = this.rawShare(ptr, Emval.toHandle(() => clonedHandle["delete"]()));
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr;
        }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
          }
          if (!handle.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          if (handle.$$.ptrType.isConst) {
            throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        var init_RegisteredPointer = () => {
          Object.assign(RegisteredPointer.prototype, { getPointee(ptr) {
            if (this.rawGetPointee) {
              ptr = this.rawGetPointee(ptr);
            }
            return ptr;
          }, destructor(ptr) {
            this.rawDestructor?.(ptr);
          }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, fromWireType: RegisteredPointer_fromWireType });
        };
        function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        var replacePublicSymbol = (name, value2, numArguments) => {
          if (!Module2.hasOwnProperty(name)) {
            throwInternalError("Replacing nonexistent public symbol");
          }
          if (void 0 !== Module2[name].overloadTable && void 0 !== numArguments) {
            Module2[name].overloadTable[numArguments] = value2;
          } else {
            Module2[name] = value2;
            Module2[name].argCount = numArguments;
          }
        };
        var dynCallLegacy = (sig, ptr, args) => {
          sig = sig.replace(/p/g, "i");
          var f = Module2["dynCall_" + sig];
          return f(ptr, ...args);
        };
        var wasmTable;
        var getWasmTableEntry = (funcPtr) => wasmTable.get(funcPtr);
        var dynCall = (sig, ptr, args = []) => {
          if (sig.includes("j")) {
            return dynCallLegacy(sig, ptr, args);
          }
          var rtn = getWasmTableEntry(ptr)(...args);
          return sig[0] == "p" ? rtn >>> 0 : rtn;
        };
        var getDynCaller = (sig, ptr) => (...args) => dynCall(sig, ptr, args);
        var embind__requireFunction = (signature, rawFunction) => {
          signature = readLatin1String(signature);
          function makeDynCaller() {
            if (signature.includes("j")) {
              return getDynCaller(signature, rawFunction);
            }
            if (signature.includes("p")) {
              return getDynCaller(signature, rawFunction);
            }
            return getWasmTableEntry(rawFunction);
          }
          var fp = makeDynCaller();
          if (typeof fp != "function") {
            throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
          }
          return fp;
        };
        var extendError = (baseErrorType, errorName) => {
          var errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            var stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            } else {
              return `${this.name}: ${this.message}`;
            }
          };
          return errorClass;
        };
        var UnboundTypeError;
        var getTypeName = (type) => {
          var ptr = ___getTypeName(type);
          var rv = readLatin1String(ptr);
          _free(ptr);
          return rv;
        };
        var throwUnboundTypeError = (message, types) => {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          types.forEach(visit);
          throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([", "]));
        };
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          rawPointerType >>>= 0;
          rawConstPointerType >>>= 0;
          baseClassRawType >>>= 0;
          getActualTypeSignature >>>= 0;
          getActualType >>>= 0;
          upcastSignature >>>= 0;
          upcast >>>= 0;
          downcastSignature >>>= 0;
          downcast >>>= 0;
          name >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          name = readLatin1String(name);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          upcast &&= embind__requireFunction(upcastSignature, upcast);
          downcast &&= embind__requireFunction(downcastSignature, downcast);
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);
          });
          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], (base) => {
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
              baseClass = base.registeredClass;
              basePrototype = baseClass.instancePrototype;
            } else {
              basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(name, function(...args) {
              if (Object.getPrototypeOf(this) !== instancePrototype) {
                throw new BindingError("Use 'new' to construct " + name);
              }
              if (void 0 === registeredClass.constructor_body) {
                throw new BindingError(name + " has no accessible constructor");
              }
              var body = registeredClass.constructor_body[args.length];
              if (void 0 === body) {
                throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
              }
              return body.apply(this, args);
            });
            var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
            if (registeredClass.baseClass) {
              registeredClass.baseClass.__derivedClasses ??= [];
              registeredClass.baseClass.__derivedClasses.push(registeredClass);
            }
            var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);
            var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);
            var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);
            registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
          });
        }
        var heap32VectorToArray = (count, firstElement) => {
          var array = [];
          for (var i = 0; i < count; i++) {
            array.push(HEAPU32[firstElement + i * 4 >>> 2 >>> 0]);
          }
          return array;
        };
        function usesDestructorStack(argTypes) {
          for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
              return true;
            }
          }
          return false;
        }
        function newFunc(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError(`new_ called with constructor type ${typeof constructor} which is not a function`);
          }
          var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
          });
          dummy.prototype = constructor.prototype;
          var obj = new dummy();
          var r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {
          var needsDestructorStack = usesDestructorStack(argTypes);
          var argCount = argTypes.length;
          var argsList = "";
          var argsListWired = "";
          for (var i = 0; i < argCount - 2; ++i) {
            argsList += (i !== 0 ? ", " : "") + "arg" + i;
            argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
          }
          var invokerFnBody = `
        return function (${argsList}) {
        if (arguments.length !== ${argCount - 2}) {
          throwBindingError('function ' + humanName + ' called with ' + arguments.length + ' arguments, expected ${argCount - 2}');
        }`;
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          var dtorStack = needsDestructorStack ? "destructors" : "null";
          var args1 = ["humanName", "throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
          if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam['toWireType'](" + dtorStack + ", this);\n";
          }
          for (var i = 0; i < argCount - 2; ++i) {
            invokerFnBody += "var arg" + i + "Wired = argType" + i + "['toWireType'](" + dtorStack + ", arg" + i + ");\n";
            args1.push("argType" + i);
          }
          if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
          }
          invokerFnBody += (returns || isAsync ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
              var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
              if (argTypes[i].destructorFunction !== null) {
                invokerFnBody += `${paramName}_dtor(${paramName});
`;
                args1.push(`${paramName}_dtor`);
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType['fromWireType'](rv);\nreturn ret;\n";
          } else {
          }
          invokerFnBody += "}\n";
          return [args1, invokerFnBody];
        }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = usesDestructorStack(argTypes);
          var returns = argTypes[0].name !== "void";
          var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
          for (var i = 0; i < argCount - 2; ++i) {
            closureArgs.push(argTypes[i + 2]);
          }
          if (!needsDestructorStack) {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
              if (argTypes[i].destructorFunction !== null) {
                closureArgs.push(argTypes[i].destructorFunction);
              }
            }
          }
          let [args, invokerFnBody] = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);
          args.push(invokerFnBody);
          var invokerFn = newFunc(Function, args)(...closureArgs);
          return createNamedFunction(humanName, invokerFn);
        }
        var __embind_register_class_constructor = function(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          rawClassType >>>= 0;
          rawArgTypesAddr >>>= 0;
          invokerSignature >>>= 0;
          invoker >>>= 0;
          rawConstructor >>>= 0;
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          whenDependentTypesAreResolved([], [rawClassType], (classType) => {
            classType = classType[0];
            var humanName = `constructor ${classType.name}`;
            if (void 0 === classType.registeredClass.constructor_body) {
              classType.registeredClass.constructor_body = [];
            }
            if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
              throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
            }
            classType.registeredClass.constructor_body[argCount - 1] = () => {
              throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
            };
            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
              argTypes.splice(1, 0, null);
              classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
              return [];
            });
            return [];
          });
        };
        var getFunctionName = (signature) => {
          signature = signature.trim();
          const argsIndex = signature.indexOf("(");
          if (argsIndex !== -1) {
            return signature.substr(0, argsIndex);
          } else {
            return signature;
          }
        };
        var __embind_register_class_function = function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync) {
          rawClassType >>>= 0;
          methodName >>>= 0;
          rawArgTypesAddr >>>= 0;
          invokerSignature >>>= 0;
          rawInvoker >>>= 0;
          context >>>= 0;
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          methodName = getFunctionName(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], (classType) => {
            classType = classType[0];
            var humanName = `${classType.name}.${methodName}`;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
            }
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
              if (void 0 === proto[methodName].overloadTable) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        };
        var emval_freelist = [];
        var emval_handles = [];
        function __emval_decref(handle) {
          handle >>>= 0;
          if (handle > 9 && 0 === --emval_handles[handle + 1]) {
            emval_handles[handle] = void 0;
            emval_freelist.push(handle);
          }
        }
        var count_emval_handles = () => emval_handles.length / 2 - 5 - emval_freelist.length;
        var init_emval = () => {
          emval_handles.push(0, 1, void 0, 1, null, 1, true, 1, false, 1);
          Module2["count_emval_handles"] = count_emval_handles;
        };
        var Emval = { toValue: (handle) => {
          if (!handle) {
            throwBindingError("Cannot use deleted val. handle = " + handle);
          }
          return emval_handles[handle];
        }, toHandle: (value2) => {
          switch (value2) {
            case void 0:
              return 2;
            case null:
              return 4;
            case true:
              return 6;
            case false:
              return 8;
            default: {
              const handle = emval_freelist.pop() || emval_handles.length;
              emval_handles[handle] = value2;
              emval_handles[handle + 1] = 1;
              return handle;
            }
          }
        } };
        var EmValType = { name: "emscripten::val", fromWireType: (handle) => {
          var rv = Emval.toValue(handle);
          __emval_decref(handle);
          return rv;
        }, toWireType: (destructors, value2) => Emval.toHandle(value2), argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, destructorFunction: null };
        function __embind_register_emval(rawType) {
          rawType >>>= 0;
          return registerType(rawType, EmValType);
        }
        var enumReadValueFromPointer = (name, width, signed) => {
          switch (width) {
            case 1:
              return signed ? function(pointer) {
                return this["fromWireType"](HEAP8[pointer >>> 0]);
              } : function(pointer) {
                return this["fromWireType"](HEAPU8[pointer >>> 0]);
              };
            case 2:
              return signed ? function(pointer) {
                return this["fromWireType"](HEAP16[pointer >>> 1 >>> 0]);
              } : function(pointer) {
                return this["fromWireType"](HEAPU16[pointer >>> 1 >>> 0]);
              };
            case 4:
              return signed ? function(pointer) {
                return this["fromWireType"](HEAP32[pointer >>> 2 >>> 0]);
              } : function(pointer) {
                return this["fromWireType"](HEAPU32[pointer >>> 2 >>> 0]);
              };
            default:
              throw new TypeError(`invalid integer width (${width}): ${name}`);
          }
        };
        function __embind_register_enum(rawType, name, size, isSigned) {
          rawType >>>= 0;
          name >>>= 0;
          size >>>= 0;
          name = readLatin1String(name);
          function ctor() {
          }
          ctor.values = {};
          registerType(rawType, { name, constructor: ctor, fromWireType: function(c) {
            return this.constructor.values[c];
          }, toWireType: (destructors, c) => c.value, argPackAdvance: GenericWireTypeSize, readValueFromPointer: enumReadValueFromPointer(name, size, isSigned), destructorFunction: null });
          exposePublicSymbol(name, ctor);
        }
        var requireRegisteredType = (rawType, humanName) => {
          var impl = registeredTypes[rawType];
          if (void 0 === impl) {
            throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);
          }
          return impl;
        };
        function __embind_register_enum_value(rawEnumType, name, enumValue) {
          rawEnumType >>>= 0;
          name >>>= 0;
          var enumType = requireRegisteredType(rawEnumType, "enum");
          name = readLatin1String(name);
          var Enum = enumType.constructor;
          var Value = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(`${enumType.name}_${name}`, function() {
          }) } });
          Enum.values[enumValue] = Value;
          Enum[name] = Value;
        }
        var embindRepr = (v) => {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        };
        var floatReadValueFromPointer = (name, width) => {
          switch (width) {
            case 4:
              return function(pointer) {
                return this["fromWireType"](HEAPF32[pointer >>> 2 >>> 0]);
              };
            case 8:
              return function(pointer) {
                return this["fromWireType"](HEAPF64[pointer >>> 3 >>> 0]);
              };
            default:
              throw new TypeError(`invalid float width (${width}): ${name}`);
          }
        };
        var __embind_register_float = function(rawType, name, size) {
          rawType >>>= 0;
          name >>>= 0;
          size >>>= 0;
          name = readLatin1String(name);
          registerType(rawType, { name, fromWireType: (value2) => value2, toWireType: (destructors, value2) => value2, argPackAdvance: GenericWireTypeSize, readValueFromPointer: floatReadValueFromPointer(name, size), destructorFunction: null });
        };
        function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync) {
          name >>>= 0;
          rawArgTypesAddr >>>= 0;
          signature >>>= 0;
          rawInvoker >>>= 0;
          fn >>>= 0;
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name = readLatin1String(name);
          name = getFunctionName(name);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(name, function() {
            throwUnboundTypeError(`Cannot call ${name} due to unbound types`, argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, (argTypes2) => {
            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
            return [];
          });
        }
        var integerReadValueFromPointer = (name, width, signed) => {
          switch (width) {
            case 1:
              return signed ? (pointer) => HEAP8[pointer >>> 0] : (pointer) => HEAPU8[pointer >>> 0];
            case 2:
              return signed ? (pointer) => HEAP16[pointer >>> 1 >>> 0] : (pointer) => HEAPU16[pointer >>> 1 >>> 0];
            case 4:
              return signed ? (pointer) => HEAP32[pointer >>> 2 >>> 0] : (pointer) => HEAPU32[pointer >>> 2 >>> 0];
            default:
              throw new TypeError(`invalid integer width (${width}): ${name}`);
          }
        };
        function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
          primitiveType >>>= 0;
          name >>>= 0;
          size >>>= 0;
          name = readLatin1String(name);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          var fromWireType = (value2) => value2;
          if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = (value2) => value2 << bitshift >>> bitshift;
          }
          var isUnsignedType = name.includes("unsigned");
          var checkAssertions = (value2, toTypeName) => {
          };
          var toWireType;
          if (isUnsignedType) {
            toWireType = function(destructors, value2) {
              checkAssertions(value2, this.name);
              return value2 >>> 0;
            };
          } else {
            toWireType = function(destructors, value2) {
              checkAssertions(value2, this.name);
              return value2;
            };
          }
          registerType(primitiveType, { name, fromWireType, toWireType, argPackAdvance: GenericWireTypeSize, readValueFromPointer: integerReadValueFromPointer(name, size, minRange !== 0), destructorFunction: null });
        }
        function __embind_register_memory_view(rawType, dataTypeIndex, name) {
          rawType >>>= 0;
          name >>>= 0;
          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle) {
            var size = HEAPU32[handle >>> 2 >>> 0];
            var data = HEAPU32[handle + 4 >>> 2 >>> 0];
            return new TA(HEAP8.buffer, data, size);
          }
          name = readLatin1String(name);
          registerType(rawType, { name, fromWireType: decodeMemoryView, argPackAdvance: GenericWireTypeSize, readValueFromPointer: decodeMemoryView }, { ignoreDuplicateRegistrations: true });
        }
        function __embind_register_optional(rawOptionalType, rawType) {
          rawOptionalType >>>= 0;
          rawType >>>= 0;
          __embind_register_emval(rawOptionalType);
        }
        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
          outIdx >>>= 0;
          if (!(maxBytesToWrite > 0)) return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx) break;
              heap[outIdx++ >>> 0] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx) break;
              heap[outIdx++ >>> 0] = 192 | u >> 6;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx) break;
              heap[outIdx++ >>> 0] = 224 | u >> 12;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx) break;
              heap[outIdx++ >>> 0] = 240 | u >> 18;
              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            }
          }
          heap[outIdx >>> 0] = 0;
          return outIdx - startIdx;
        };
        var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        var lengthBytesUTF8 = (str) => {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var c = str.charCodeAt(i);
            if (c <= 127) {
              len++;
            } else if (c <= 2047) {
              len += 2;
            } else if (c >= 55296 && c <= 57343) {
              len += 4;
              ++i;
            } else {
              len += 3;
            }
          }
          return len;
        };
        var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
        var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead) => {
          idx >>>= 0;
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
          }
          var str = "";
          while (idx < endPtr) {
            var u0 = heapOrArray[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heapOrArray[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heapOrArray[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
          return str;
        };
        var UTF8ToString = (ptr, maxBytesToRead) => {
          ptr >>>= 0;
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        };
        function __embind_register_std_string(rawType, name) {
          rawType >>>= 0;
          name >>>= 0;
          name = readLatin1String(name);
          var stdStringIsUTF8 = name === "std::string";
          registerType(rawType, { name, fromWireType(value2) {
            var length2 = HEAPU32[value2 >>> 2 >>> 0];
            var payload = value2 + 4;
            var str;
            if (stdStringIsUTF8) {
              var decodeStartPtr = payload;
              for (var i = 0; i <= length2; ++i) {
                var currentBytePtr = payload + i;
                if (i == length2 || HEAPU8[currentBytePtr >>> 0] == 0) {
                  var maxRead = currentBytePtr - decodeStartPtr;
                  var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + 1;
                }
              }
            } else {
              var a = new Array(length2);
              for (var i = 0; i < length2; ++i) {
                a[i] = String.fromCharCode(HEAPU8[payload + i >>> 0]);
              }
              str = a.join("");
            }
            _free(value2);
            return str;
          }, toWireType(destructors, value2) {
            if (value2 instanceof ArrayBuffer) {
              value2 = new Uint8Array(value2);
            }
            var length2;
            var valueIsOfTypeString = typeof value2 == "string";
            if (!(valueIsOfTypeString || value2 instanceof Uint8Array || value2 instanceof Uint8ClampedArray || value2 instanceof Int8Array)) {
              throwBindingError("Cannot pass non-string to std::string");
            }
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              length2 = lengthBytesUTF8(value2);
            } else {
              length2 = value2.length;
            }
            var base = _malloc(4 + length2 + 1);
            var ptr = base + 4;
            HEAPU32[base >>> 2 >>> 0] = length2;
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              stringToUTF8(value2, ptr, length2 + 1);
            } else {
              if (valueIsOfTypeString) {
                for (var i = 0; i < length2; ++i) {
                  var charCode = value2.charCodeAt(i);
                  if (charCode > 255) {
                    _free(ptr);
                    throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                  }
                  HEAPU8[ptr + i >>> 0] = charCode;
                }
              } else {
                for (var i = 0; i < length2; ++i) {
                  HEAPU8[ptr + i >>> 0] = value2[i];
                }
              }
            }
            if (destructors !== null) {
              destructors.push(_free, base);
            }
            return base;
          }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, destructorFunction(ptr) {
            _free(ptr);
          } });
        }
        var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
        var UTF16ToString = (ptr, maxBytesToRead) => {
          var endPtr = ptr;
          var idx = endPtr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          while (!(idx >= maxIdx) && HEAPU16[idx >>> 0]) ++idx;
          endPtr = idx << 1;
          if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr >>> 0, endPtr >>> 0));
          var str = "";
          for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
            var codeUnit = HEAP16[ptr + i * 2 >>> 1 >>> 0];
            if (codeUnit == 0) break;
            str += String.fromCharCode(codeUnit);
          }
          return str;
        };
        var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
          maxBytesToWrite ??= 2147483647;
          if (maxBytesToWrite < 2) return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            HEAP16[outPtr >>> 1 >>> 0] = codeUnit;
            outPtr += 2;
          }
          HEAP16[outPtr >>> 1 >>> 0] = 0;
          return outPtr - startPtr;
        };
        var lengthBytesUTF16 = (str) => str.length * 2;
        var UTF32ToString = (ptr, maxBytesToRead) => {
          var i = 0;
          var str = "";
          while (!(i >= maxBytesToRead / 4)) {
            var utf32 = HEAP32[ptr + i * 4 >>> 2 >>> 0];
            if (utf32 == 0) break;
            ++i;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        };
        var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
          outPtr >>>= 0;
          maxBytesToWrite ??= 2147483647;
          if (maxBytesToWrite < 4) return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            HEAP32[outPtr >>> 2 >>> 0] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr) break;
          }
          HEAP32[outPtr >>> 2 >>> 0] = 0;
          return outPtr - startPtr;
        };
        var lengthBytesUTF32 = (str) => {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) ++i;
            len += 4;
          }
          return len;
        };
        var __embind_register_std_wstring = function(rawType, charSize, name) {
          rawType >>>= 0;
          charSize >>>= 0;
          name >>>= 0;
          name = readLatin1String(name);
          var decodeString, encodeString, readCharAt, lengthBytesUTF;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            readCharAt = (pointer) => HEAPU16[pointer >>> 1 >>> 0];
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            readCharAt = (pointer) => HEAPU32[pointer >>> 2 >>> 0];
          }
          registerType(rawType, { name, fromWireType: (value2) => {
            var length2 = HEAPU32[value2 >>> 2 >>> 0];
            var str;
            var decodeStartPtr = value2 + 4;
            for (var i = 0; i <= length2; ++i) {
              var currentBytePtr = value2 + 4 + i * charSize;
              if (i == length2 || readCharAt(currentBytePtr) == 0) {
                var maxReadBytes = currentBytePtr - decodeStartPtr;
                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                if (str === void 0) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + charSize;
              }
            }
            _free(value2);
            return str;
          }, toWireType: (destructors, value2) => {
            if (!(typeof value2 == "string")) {
              throwBindingError(`Cannot pass non-string to C++ string type ${name}`);
            }
            var length2 = lengthBytesUTF(value2);
            var ptr = _malloc(4 + length2 + charSize);
            HEAPU32[ptr >>> 2 >>> 0] = length2 / charSize;
            encodeString(value2, ptr + 4, length2 + charSize);
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, argPackAdvance: GenericWireTypeSize, readValueFromPointer: readPointer, destructorFunction(ptr) {
            _free(ptr);
          } });
        };
        function __embind_register_value_object(rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          rawType >>>= 0;
          name >>>= 0;
          constructorSignature >>>= 0;
          rawConstructor >>>= 0;
          destructorSignature >>>= 0;
          rawDestructor >>>= 0;
          structRegistrations[rawType] = { name: readLatin1String(name), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
        }
        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          structType >>>= 0;
          fieldName >>>= 0;
          getterReturnType >>>= 0;
          getterSignature >>>= 0;
          getter >>>= 0;
          getterContext >>>= 0;
          setterArgumentType >>>= 0;
          setterSignature >>>= 0;
          setter >>>= 0;
          setterContext >>>= 0;
          structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        var __embind_register_void = function(rawType, name) {
          rawType >>>= 0;
          name >>>= 0;
          name = readLatin1String(name);
          registerType(rawType, { isVoid: true, name, argPackAdvance: 0, fromWireType: () => void 0, toWireType: (destructors, o) => void 0 });
        };
        function __emscripten_memcpy_js(dest, src, num) {
          dest >>>= 0;
          src >>>= 0;
          num >>>= 0;
          return HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
        }
        var emval_returnValue = (returnType, destructorsRef, handle) => {
          var destructors = [];
          var result = returnType["toWireType"](destructors, handle);
          if (destructors.length) {
            HEAPU32[destructorsRef >>> 2 >>> 0] = Emval.toHandle(destructors);
          }
          return result;
        };
        function __emval_as(handle, returnType, destructorsRef) {
          handle >>>= 0;
          returnType >>>= 0;
          destructorsRef >>>= 0;
          handle = Emval.toValue(handle);
          returnType = requireRegisteredType(returnType, "emval::as");
          return emval_returnValue(returnType, destructorsRef, handle);
        }
        var emval_symbols = {};
        var getStringOrSymbol = (address) => {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          }
          return symbol;
        };
        var emval_methodCallers = [];
        function __emval_call_method(caller, objHandle, methodName, destructorsRef, args) {
          caller >>>= 0;
          objHandle >>>= 0;
          methodName >>>= 0;
          destructorsRef >>>= 0;
          args >>>= 0;
          caller = emval_methodCallers[caller];
          objHandle = Emval.toValue(objHandle);
          methodName = getStringOrSymbol(methodName);
          return caller(objHandle, objHandle[methodName], destructorsRef, args);
        }
        function __emval_equals(first, second) {
          first >>>= 0;
          second >>>= 0;
          first = Emval.toValue(first);
          second = Emval.toValue(second);
          return first == second;
        }
        var emval_addMethodCaller = (caller) => {
          var id = emval_methodCallers.length;
          emval_methodCallers.push(caller);
          return id;
        };
        var emval_lookupTypes = (argCount, argTypes) => {
          var a = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            a[i] = requireRegisteredType(HEAPU32[argTypes + i * 4 >>> 2 >>> 0], "parameter " + i);
          }
          return a;
        };
        var reflectConstruct = Reflect.construct;
        function __emval_get_method_caller(argCount, argTypes, kind) {
          argTypes >>>= 0;
          var types = emval_lookupTypes(argCount, argTypes);
          var retType = types.shift();
          argCount--;
          var functionBody = `return function (obj, func, destructorsRef, args) {
`;
          var offset = 0;
          var argsList = [];
          if (kind === 0) {
            argsList.push("obj");
          }
          var params = ["retType"];
          var args = [retType];
          for (var i = 0; i < argCount; ++i) {
            argsList.push("arg" + i);
            params.push("argType" + i);
            args.push(types[i]);
            functionBody += `  var arg${i} = argType${i}.readValueFromPointer(args${offset ? "+" + offset : ""});
`;
            offset += types[i]["argPackAdvance"];
          }
          var invoker = kind === 1 ? "new func" : "func.call";
          functionBody += `  var rv = ${invoker}(${argsList.join(", ")});
`;
          if (!retType.isVoid) {
            params.push("emval_returnValue");
            args.push(emval_returnValue);
            functionBody += "  return emval_returnValue(retType, destructorsRef, rv);\n";
          }
          functionBody += "};\n";
          params.push(functionBody);
          var invokerFunction = newFunc(Function, params)(...args);
          var functionName = `methodCaller<(${types.map((t) => t.name).join(", ")}) => ${retType.name}>`;
          return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
        }
        function __emval_get_property(handle, key) {
          handle >>>= 0;
          key >>>= 0;
          handle = Emval.toValue(handle);
          key = Emval.toValue(key);
          return Emval.toHandle(handle[key]);
        }
        function __emval_incref(handle) {
          handle >>>= 0;
          if (handle > 9) {
            emval_handles[handle + 1] += 1;
          }
        }
        function __emval_new_cstring(v) {
          v >>>= 0;
          return Emval.toHandle(getStringOrSymbol(v));
        }
        function __emval_new_object() {
          return Emval.toHandle({});
        }
        function __emval_run_destructors(handle) {
          handle >>>= 0;
          var destructors = Emval.toValue(handle);
          runDestructors(destructors);
          __emval_decref(handle);
        }
        function __emval_set_property(handle, key, value2) {
          handle >>>= 0;
          key >>>= 0;
          value2 >>>= 0;
          handle = Emval.toValue(handle);
          key = Emval.toValue(key);
          value2 = Emval.toValue(value2);
          handle[key] = value2;
        }
        function __emval_take_value(type, arg) {
          type >>>= 0;
          arg >>>= 0;
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](arg);
          return Emval.toHandle(v);
        }
        var getHeapMax = () => 4294901760;
        var growMemory = (size) => {
          var b = wasmMemory.buffer;
          var pages = (size - b.byteLength + 65535) / 65536;
          try {
            wasmMemory.grow(pages);
            updateMemoryViews();
            return 1;
          } catch (e) {
          }
        };
        function _emscripten_resize_heap(requestedSize) {
          requestedSize >>>= 0;
          var oldSize = HEAPU8.length;
          var maxHeapSize = getHeapMax();
          if (requestedSize > maxHeapSize) {
            return false;
          }
          var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = growMemory(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        var uleb128Encode = (n, target) => {
          if (n < 128) {
            target.push(n);
          } else {
            target.push(n % 128 | 128, n >> 7);
          }
        };
        var sigToWasmTypes = (sig) => {
          var typeNames = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" };
          var type = { parameters: [], results: sig[0] == "v" ? [] : [typeNames[sig[0]]] };
          for (var i = 1; i < sig.length; ++i) {
            type.parameters.push(typeNames[sig[i]]);
          }
          return type;
        };
        var generateFuncType = (sig, target) => {
          var sigRet = sig.slice(0, 1);
          var sigParam = sig.slice(1);
          var typeCodes = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
          target.push(96);
          uleb128Encode(sigParam.length, target);
          for (var i = 0; i < sigParam.length; ++i) {
            target.push(typeCodes[sigParam[i]]);
          }
          if (sigRet == "v") {
            target.push(0);
          } else {
            target.push(1, typeCodes[sigRet]);
          }
        };
        var convertJsFunctionToWasm = (func, sig) => {
          if (typeof WebAssembly.Function == "function") {
            return new WebAssembly.Function(sigToWasmTypes(sig), func);
          }
          var typeSectionBody = [1];
          generateFuncType(sig, typeSectionBody);
          var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1];
          uleb128Encode(typeSectionBody.length, bytes);
          bytes.push(...typeSectionBody);
          bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
          var module = new WebAssembly.Module(new Uint8Array(bytes));
          var instance = new WebAssembly.Instance(module, { e: { f: func } });
          var wrappedFunc = instance.exports["f"];
          return wrappedFunc;
        };
        var updateTableMap = (offset, count) => {
          if (functionsInTableMap) {
            for (var i = offset; i < offset + count; i++) {
              var item = getWasmTableEntry(i);
              if (item) {
                functionsInTableMap.set(item, i);
              }
            }
          }
        };
        var functionsInTableMap;
        var getFunctionAddress = (func) => {
          if (!functionsInTableMap) {
            functionsInTableMap = /* @__PURE__ */ new WeakMap();
            updateTableMap(0, wasmTable.length);
          }
          return functionsInTableMap.get(func) || 0;
        };
        var freeTableIndexes = [];
        var getEmptyTableSlot = () => {
          if (freeTableIndexes.length) {
            return freeTableIndexes.pop();
          }
          try {
            wasmTable.grow(1);
          } catch (err3) {
            if (!(err3 instanceof RangeError)) {
              throw err3;
            }
            throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
          }
          return wasmTable.length - 1;
        };
        var setWasmTableEntry = (idx, func) => wasmTable.set(idx, func);
        var addFunction = (func, sig) => {
          var rtn = getFunctionAddress(func);
          if (rtn) {
            return rtn;
          }
          var ret = getEmptyTableSlot();
          try {
            setWasmTableEntry(ret, func);
          } catch (err3) {
            if (!(err3 instanceof TypeError)) {
              throw err3;
            }
            var wrapped = convertJsFunctionToWasm(func, sig);
            setWasmTableEntry(ret, wrapped);
          }
          functionsInTableMap.set(func, ret);
          return ret;
        };
        var removeFunction = (index) => {
          functionsInTableMap.delete(getWasmTableEntry(index));
          setWasmTableEntry(index, null);
          freeTableIndexes.push(index);
        };
        InternalError = Module2["InternalError"] = class InternalError extends Error {
          constructor(message) {
            super(message);
            this.name = "InternalError";
          }
        };
        embind_init_charCodes();
        BindingError = Module2["BindingError"] = class BindingError extends Error {
          constructor(message) {
            super(message);
            this.name = "BindingError";
          }
        };
        init_ClassHandle();
        init_embind();
        init_RegisteredPointer();
        UnboundTypeError = Module2["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        init_emval();
        var wasmImports = { i: ___cxa_throw, D: __abort_js, n: __embind_finalize_value_object, C: __embind_register_bigint, H: __embind_register_bool, h: __embind_register_class, g: __embind_register_class_constructor, a: __embind_register_class_function, G: __embind_register_emval, t: __embind_register_enum, e: __embind_register_enum_value, x: __embind_register_float, c: __embind_register_function, j: __embind_register_integer, f: __embind_register_memory_view, k: __embind_register_optional, w: __embind_register_std_string, s: __embind_register_std_wstring, o: __embind_register_value_object, l: __embind_register_value_object_field, I: __embind_register_void, F: __emscripten_memcpy_js, v: __emval_as, z: __emval_call_method, b: __emval_decref, m: __emval_equals, y: __emval_get_method_caller, B: __emval_get_property, u: __emval_incref, q: __emval_new_cstring, A: __emval_new_object, p: __emval_run_destructors, r: __emval_set_property, d: __emval_take_value, E: _emscripten_resize_heap };
        var wasmExports = createWasm();
        var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports["K"])();
        var ___getTypeName = (a0) => (___getTypeName = wasmExports["L"])(a0);
        var _malloc = (a0) => (_malloc = wasmExports["N"])(a0);
        var _free = (a0) => (_free = wasmExports["O"])(a0);
        var ___cxa_is_pointer_type = (a0) => (___cxa_is_pointer_type = wasmExports["P"])(a0);
        function applySignatureConversions(wasmExports2) {
          wasmExports2 = Object.assign({}, wasmExports2);
          var makeWrapper_pp = (f) => (a0) => f(a0) >>> 0;
          var makeWrapper_p = (f) => () => f() >>> 0;
          wasmExports2["L"] = makeWrapper_pp(wasmExports2["L"]);
          wasmExports2["N"] = makeWrapper_pp(wasmExports2["N"]);
          wasmExports2["_emscripten_stack_alloc"] = makeWrapper_pp(wasmExports2["_emscripten_stack_alloc"]);
          wasmExports2["emscripten_stack_get_current"] = makeWrapper_p(wasmExports2["emscripten_stack_get_current"]);
          return wasmExports2;
        }
        Module2["addFunction"] = addFunction;
        Module2["removeFunction"] = removeFunction;
        var calledRun;
        dependenciesFulfilled = function runCaller() {
          if (!calledRun) run();
          if (!calledRun) dependenciesFulfilled = runCaller;
        };
        function run() {
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun) return;
            calledRun = true;
            Module2["calledRun"] = true;
            if (ABORT) return;
            initRuntime();
            readyPromiseResolve(Module2);
            Module2["onRuntimeInitialized"]?.();
            postRun();
          }
          if (Module2["setStatus"]) {
            Module2["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module2["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        if (Module2["preInit"]) {
          if (typeof Module2["preInit"] == "function") Module2["preInit"] = [Module2["preInit"]];
          while (Module2["preInit"].length > 0) {
            Module2["preInit"].pop()();
          }
        }
        run();
        moduleRtn = readyPromise;
        return moduleRtn;
      });
    })();
    manifold_default = Module;
  }
});

// lib/wasm.ts
function setWasmUrl2(url) {
  wasmUrl = url;
}
async function instantiateManifold() {
  console.log("Instatiate manifoldwasm");
  let module = null;
  if (typeof wasmUrl === "string" && !!wasmUrl) {
    module = await manifold_default({ locateFile: () => wasmUrl });
  } else {
    module = await manifold_default();
  }
  module.setup();
  return module;
}
async function getManifoldModule() {
  if (!manifoldwasm) manifoldwasm = await instantiateManifold();
  return manifoldwasm;
}
function getManifoldModuleSync() {
  return manifoldwasm;
}
var manifoldwasm, wasmUrl;
var init_wasm = __esm({
  "lib/wasm.ts"() {
    "use strict";
    init_manifold();
    manifoldwasm = null;
    wasmUrl = null;
  }
});

// lib/level-of-detail.ts
var minCircularAngle, minCircularEdgeLength, setMinCircularAngle, setMinCircularEdgeLength, setCircularSegments, resetToCircularDefaults, getMinCircularAngle, getMinCircularEdgeLength, getCircularSegments, cleanup4;
var init_level_of_detail = __esm({
  "lib/level-of-detail.ts"() {
    "use strict";
    init_wasm();
    minCircularAngle = 10;
    minCircularEdgeLength = 1;
    setMinCircularAngle = (angle) => {
      minCircularAngle = angle;
      getManifoldModuleSync()?.setMinCircularAngle(angle);
    };
    setMinCircularEdgeLength = (length2) => {
      minCircularEdgeLength = length2;
      getManifoldModuleSync()?.setMinCircularEdgeLength(length2);
    };
    setCircularSegments = (segments) => getManifoldModuleSync()?.setCircularSegments(segments);
    resetToCircularDefaults = () => {
      getManifoldModuleSync()?.resetToCircularDefaults();
      minCircularAngle = 10;
      minCircularEdgeLength = 1;
    };
    getMinCircularAngle = () => minCircularAngle;
    getMinCircularEdgeLength = () => minCircularEdgeLength;
    getCircularSegments = (radius) => getManifoldModuleSync()?.getCircularSegments(radius);
    cleanup4 = () => {
      resetToCircularDefaults();
    };
  }
});

// lib/material.ts
function cleanup5() {
  id2material.clear();
  materialCache.clear();
}
function getBackupMaterial(node) {
  if (node == null) {
    return {};
  }
  if (node.material == null) {
    node.material = getBackupMaterial(node.parent);
  }
  return node.material;
}
function makeDefaultMaterial(doc, matIn = {}) {
  const { roughness, metallic, baseColorFactor, alpha, unlit } = {
    ...defaultMaterial,
    ...matIn
  };
  const material = doc.createMaterial(matIn.name ?? "");
  if (unlit) {
    const unlit2 = doc.createExtension(KHRMaterialsUnlit).createUnlit();
    material.setExtension("KHR_materials_unlit", unlit2);
  }
  if (alpha < 1) {
    material.setAlphaMode(Material.AlphaMode.BLEND).setDoubleSided(true);
  }
  return material.setRoughnessFactor(roughness).setMetallicFactor(metallic).setBaseColorFactor([...baseColorFactor, alpha]);
}
function getCachedMaterial(doc, matDef) {
  if (!materialCache.has(matDef)) {
    materialCache.set(matDef, makeDefaultMaterial(doc, matDef));
  }
  return materialCache.get(matDef);
}
var defaultMaterial, id2material, materialCache, setMaterial, getMaterialByID;
var init_material = __esm({
  "lib/material.ts"() {
    "use strict";
    init_index_modern();
    init_index_modern2();
    defaultMaterial = {
      roughness: 0.2,
      metallic: 1,
      baseColorFactor: [1, 1, 0],
      alpha: 1,
      unlit: false
    };
    id2material = /* @__PURE__ */ new Map();
    materialCache = /* @__PURE__ */ new Map();
    setMaterial = (manifold, material) => {
      const out = manifold.asOriginal();
      id2material.set(out.originalID(), material);
      return out;
    };
    getMaterialByID = (id) => {
      return id2material.get(id);
    };
  }
});

// lib/debug.ts
function cleanup6() {
  ghost = false;
  shown.clear();
  singles.clear();
}
var ghost, shown, singles, SHOW, GHOST, getDebugMeshByID, getDebugMaterialByID, getMaterialByID2, debug, show, only, getDebugGLTFMesh;
var init_debug = __esm({
  "lib/debug.ts"() {
    "use strict";
    init_gltf_io();
    init_material();
    ghost = false;
    shown = /* @__PURE__ */ new Map();
    singles = /* @__PURE__ */ new Map();
    SHOW = {
      baseColorFactor: [1, 0, 0],
      alpha: 0.25,
      roughness: 1,
      metallic: 0
    };
    GHOST = {
      baseColorFactor: [0.5, 0.5, 0.5],
      alpha: 0.25,
      roughness: 1,
      metallic: 0
    };
    getDebugMeshByID = (id) => {
      return shown.has(id) ? shown.get(id) : singles.get(id);
    };
    getDebugMaterialByID = (id) => {
      const show3 = shown.has(id);
      const inMesh = show3 ? shown.get(id) : singles.get(id);
      if (show3 && inMesh) {
        return SHOW;
      }
      return getMaterialByID(id);
    };
    getMaterialByID2 = (id) => ghost ? GHOST : getMaterialByID(id);
    debug = (manifold, map) => {
      let result = manifold.asOriginal();
      map.set(result.originalID(), result.getMesh());
      return result;
    };
    show = (manifold) => {
      return debug(manifold, shown);
    };
    only = (manifold) => {
      ghost = true;
      return debug(manifold, singles);
    };
    getDebugGLTFMesh = (doc, manifoldMesh, id2properties, backupMaterial = {}) => {
      const debugNodes = [];
      for (const [run, id] of manifoldMesh.runOriginalID.entries()) {
        const debugMesh = getDebugMeshByID(id);
        if (!debugMesh) {
          continue;
        }
        const material = getDebugMaterialByID(id) || backupMaterial;
        id2properties.get(id).material = getCachedMaterial(doc, material);
        const debugNode = doc.createNode("debug").setMesh(writeMesh(doc, debugMesh, id2properties)).setMatrix(manifoldMesh.transform(run));
        debugNodes.push(debugNode);
      }
      return debugNodes;
    };
  }
});

// lib/manifoldCAD.ts
var manifoldCAD_exports = {};
__export(manifoldCAD_exports, {
  CrossSection: () => CrossSection,
  GLTFMaterial: () => GLTFMaterial,
  GLTFNode: () => GLTFNode,
  Manifold: () => Manifold,
  Mesh: () => Mesh3,
  getAnimationDuration: () => getAnimationDuration,
  getAnimationFPS: () => getAnimationFPS,
  getAnimationMode: () => getAnimationMode,
  getCircularSegments: () => getCircularSegments,
  getGLTFNodes: () => getGLTFNodes2,
  getMinCircularAngle: () => getMinCircularAngle,
  getMinCircularEdgeLength: () => getMinCircularEdgeLength,
  isManifoldCAD: () => isManifoldCAD,
  only: () => only2,
  resetGLTFNodes: () => resetGLTFNodes2,
  setMaterial: () => setMaterial2,
  setMorphEnd: () => setMorphEnd,
  setMorphStart: () => setMorphStart,
  show: () => show2,
  triangulate: () => triangulate
});
var manifoldWasm, Mesh3, Manifold, CrossSection, triangulate, show2, only2, setMaterial2, getGLTFNodes2, resetGLTFNodes2, isManifoldCAD;
var init_manifoldCAD = __esm({
  async "lib/manifoldCAD.ts"() {
    "use strict";
    init_debug();
    init_garbage_collector();
    init_material();
    init_wasm();
    init_animation();
    init_gltf_node();
    init_level_of_detail();
    manifoldWasm = garbageCollectManifold(await getManifoldModule());
    ({ Mesh: Mesh3, Manifold, CrossSection, triangulate } = manifoldWasm);
    show2 = garbageCollectFunction(show);
    only2 = garbageCollectFunction(only);
    setMaterial2 = garbageCollectFunction(setMaterial);
    getGLTFNodes2 = () => [];
    resetGLTFNodes2 = () => {
    };
    isManifoldCAD = () => false;
  }
});

// lib/worker.ts
init_animation();

// lib/bundler.ts
var esbuild = __toESM(require_browser(), 1);

// lib/error.ts
var BundlerError = class extends Error {
  location;
  error;
  manifoldStack;
  constructor(failure, options) {
    super(void 0, options);
    this.cause = failure;
    this.error = failure.errors[0];
    if (this.error.location) {
      const { file, line, column } = this.error.location;
      this.manifoldStack = `${this.toString()}
    at ${file}:${line}:${column}`;
    }
  }
  get name() {
    return "BundlerError";
  }
  get message() {
    return this.error.text;
  }
};
var RuntimeError = class extends Error {
  manifoldStack;
  cause;
  constructor(cause, message, options) {
    super(message ?? cause.message, options);
    this.cause = cause;
  }
  get name() {
    return this.cause.name;
  }
};

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  intToChar[i] = c;
  charToInt[c] = i;
}
function decodeInteger(reader, relative) {
  let value2 = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c = reader.next();
    integer = charToInt[c];
    value2 |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value2 & 1;
  value2 >>>= 1;
  if (shouldNegate) {
    value2 = -2147483648 | -value2;
  }
  return relative + value2;
}
function hasMoreVlq(reader, max) {
  if (reader.pos >= max) return false;
  return reader.peek() !== comma;
}
var bufLength = 1024 * 16;
var StringReader = class {
  constructor(buffer) {
    this.pos = 0;
    this.buffer = buffer;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    const { buffer, pos } = this;
    const idx = buffer.indexOf(char, pos);
    return idx === -1 ? buffer.length : idx;
  }
};
function decode(mappings) {
  const { length: length2 } = mappings;
  const reader = new StringReader(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader.indexOf(";");
    const line = [];
    let sorted = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader.pos < semi) {
      let seg;
      genColumn = decodeInteger(reader, genColumn);
      if (genColumn < lastCol) sorted = false;
      lastCol = genColumn;
      if (hasMoreVlq(reader, semi)) {
        sourcesIndex = decodeInteger(reader, sourcesIndex);
        sourceLine = decodeInteger(reader, sourceLine);
        sourceColumn = decodeInteger(reader, sourceColumn);
        if (hasMoreVlq(reader, semi)) {
          namesIndex = decodeInteger(reader, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader.pos++;
    }
    if (!sorted) sort(line);
    decoded.push(line);
    reader.pos = semi + 1;
  } while (reader.pos <= length2);
  return decoded;
}
function sort(line) {
  line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[0] - b[0];
}

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
var import_resolve_uri = __toESM(require_resolve_uri_umd(), 1);
function stripFilename(path) {
  if (!path) return "";
  const index = path.lastIndexOf("/");
  return path.slice(0, index + 1);
}
function resolver(mapUrl, sourceRoot) {
  const from = stripFilename(mapUrl);
  const prefix = sourceRoot ? sourceRoot + "/" : "";
  return (source) => (0, import_resolve_uri.default)(prefix + (source || ""), from);
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length) return mappings;
  if (!owned) mappings = mappings.slice();
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
    mappings[i] = sortSegments(mappings[i], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i = start; i < mappings.length; i++) {
    if (!isSorted(mappings[i])) return i;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN] < line[j - 1][COLUMN]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned) line = line.slice();
  return line.sort(sortComparator2);
}
function sortComparator2(a, b) {
  return a[COLUMN] - b[COLUMN];
}
var found = false;
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index) {
  for (let i = index + 1; i < haystack.length; index = i++) {
    if (haystack[i][COLUMN] !== needle) break;
  }
  return index;
}
function lowerBound(haystack, needle, index) {
  for (let i = index - 1; i >= 0; index = i--) {
    if (haystack[i][COLUMN] !== needle) break;
  }
  return index;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
function parse(map) {
  return typeof map === "string" ? JSON.parse(map) : map;
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
  constructor(map, mapUrl) {
    const isString = typeof map === "string";
    if (!isString && map._decodedMemo) return map;
    const parsed = parse(map);
    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version;
    this.file = file;
    this.names = names || [];
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
    const resolve = resolver(mapUrl, sourceRoot);
    this.resolvedSources = sources.map(resolve);
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else if (Array.isArray(mappings)) {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString);
    } else if (parsed.sections) {
      throw new Error(`TraceMap passed sectioned source map, please use FlattenMap export instead`);
    } else {
      throw new Error(`invalid source map: ${JSON.stringify(parsed)}`);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
function cast(map) {
  return map;
}
function decodedMappings(map) {
  var _a2;
  return (_a2 = cast(map))._decoded || (_a2._decoded = decode(cast(map)._encoded));
}
function originalPositionFor(map, needle) {
  let { line, column, bias } = needle;
  line--;
  if (line < 0) throw new Error(LINE_GTR_ZERO);
  if (column < 0) throw new Error(COL_GTR_EQ_ZERO);
  const decoded = decodedMappings(map);
  if (line >= decoded.length) return OMapping(null, null, null, null);
  const segments = decoded[line];
  const index = traceSegmentInternal(
    segments,
    cast(map)._decodedMemo,
    line,
    column,
    bias || GREATEST_LOWER_BOUND
  );
  if (index === -1) return OMapping(null, null, null, null);
  const segment = segments[index];
  if (segment.length === 1) return OMapping(null, null, null, null);
  const { names, resolvedSources } = map;
  return OMapping(
    resolvedSources[segment[SOURCES_INDEX]],
    segment[SOURCE_LINE] + 1,
    segment[SOURCE_COLUMN],
    segment.length === 5 ? names[segment[NAMES_INDEX]] : null
  );
}
function OMapping(source, line, column, name) {
  return { source, line, column, name };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
  } else if (bias === LEAST_UPPER_BOUND) index++;
  if (index === -1 || index === segments.length) return -1;
  return index;
}

// lib/util.ts
var import_convert_source_map = __toESM(require_convert_source_map(), 1);
var isWebWorker = () => typeof self !== "undefined" && typeof self.document == "undefined";
var isNode = () => typeof process !== "undefined" && !!process?.versions?.node;
var parseV8StackTrace = (stack) => stack.split("\n").filter((frame) => frame.match(/<anonymous>/)).map((frame) => {
  const matches = frame.matchAll(/:([0-9]+):([0-9]+)\)$/g).next().value;
  const [line, column] = [parseInt(matches[1]), parseInt(matches[2])];
  const methodName = frame.match(/^\s+at\s([^\s]+)/)[1];
  return {
    line,
    column,
    // In Node or Chrome, a function constructor shows as 'eval'.
    methodName: methodName === "eval" ? null : methodName
  };
});
var parseSpiderMonkeyStackTrace = (stack) => stack.split("\n").filter((frame) => frame.match(/AsyncFunction/)).map((frame) => {
  const matches = frame.matchAll(/AsyncFunction:([0-9]+):([0-9]+)/g).next().value;
  const [line, column] = [parseInt(matches[1]), parseInt(matches[2])];
  const methodName = frame.match(/^[^@]+/)[0];
  return {
    line,
    column,
    // In Firefox, a function constructor shows as 'anonymous'.
    methodName: methodName === "anonymous" ? null : methodName
  };
});
var parseStackTrace = (stack) => {
  if (stack.match(/^\s+at\s/gm)) {
    return parseV8StackTrace(stack);
  } else if (stack.match(/^([^@]+)@/gm)) {
    return parseSpiderMonkeyStackTrace(stack);
  } else
    return [];
};
var getSourceMappedStackTrace = (code, error, lineOffset = 0) => {
  const converter = import_convert_source_map.default.fromSource(code);
  if (!converter || !error.stack) {
    return error.stack;
  }
  const parsed = parseStackTrace(error.stack);
  if (!parsed.length) {
    return error.stack;
  }
  const tracer = new TraceMap(converter.toObject());
  const stack = parsed.map((frame) => {
    if (frame.line + lineOffset < 1) {
      return frame;
    }
    const { line, column, source: file } = originalPositionFor(
      tracer,
      { line: frame.line + lineOffset, column: frame.column }
    );
    const { methodName } = frame;
    return { line, column: column + 1, file, methodName };
  });
  return [
    error.toString(),
    ...stack.map((frame) => {
      const location2 = `${frame.file}:${frame.line}:${frame.column}`;
      if (frame.methodName) {
        return `    at ${frame.methodName} (${location2})`;
      } else {
        return `    at ${location2}`;
      }
    })
  ].reduce((acc, cur) => `${acc}
${cur}`);
};

// lib/bundler.ts
var esbuildWasmUrl = null;
var esbuildHasOwnWorker = false;
var setWasmUrl = (url) => {
  esbuildWasmUrl = url;
};
var setHasOwnWorker = (x) => {
  esbuildHasOwnWorker = x;
};
var cdnUrlHelpers = {
  "esm.sh": (specifier) => `https://esm.sh/${specifier}`,
  "jsDelivr": (specifier) => `https://cdn.jsdelivr.net/npm/${specifier}/+esm`,
  "skypack": (specifier) => `https://cdn.skypack.dev/${specifier}`
};
var cdnUrl = (specifier, jsCDN) => {
  if (!jsCDN) return specifier;
  const helper = cdnUrlHelpers[jsCDN];
  return helper ? helper(specifier) : `${jsCDN}${specifier}`;
};
function log(...args) {
  if (typeof self !== "undefined" && self.console) {
    self.console.log(...args);
  }
}
var esbuildManifoldPlugin = (options = {}) => ({
  name: "esbuild-manifold-plugin",
  async setup(build2) {
    let manifoldCADExportPath = null;
    const manifoldCADExportSpecifier = "manifold-3d/manifoldCAD";
    const ManifoldCADExportMatch = /^manifold-3d\/manifoldCAD(.ts|.js)?$/;
    const manifoldCADExportNames = [
      // Manifold classes.
      "Mesh",
      "Manifold",
      "CrossSection",
      // Manifold methods.
      "setMinCircularAngle",
      "setMinCircularEdgeLength",
      "setCircularSegments",
      "getCircularSegments",
      "resetToCircularDefaults",
      "triangulate",
      // Scene builder exports.
      "show",
      "only",
      "setMaterial",
      "setMorphStart",
      "setMorphEnd",
      // GLTFNode and utilities.
      "GLTFNode",
      "getGLTFNodes",
      "resetGLTFNodes",
      // ManifoldCAD specific exports.
      "isManifoldCAD"
    ];
    if (isNode()) {
      (async () => {
        const { resolve, dirname } = await import("node:path");
        const { fileURLToPath } = await import("node:url");
        const dir = "string" == typeof __dirname && __dirname || "string" == typeof import.meta?.dirname && import.meta.dirname || dirname(fileURLToPath(import.meta.url));
        manifoldCADExportPath = resolve(dir, "./manifoldCAD.ts");
      })();
    }
    const skipResolve = {};
    build2.onResolve({ filter: /.*/ }, async (args) => {
      if (args.pluginData === skipResolve) return null;
      if (args.namespace === "http-url") return null;
      if (args.path.match(/^https?:\/\//)) return null;
      const pluginData = {
        toplevel: args.importer === options.filename || args.importer === "<stdin>"
      };
      if (args.path.match(ManifoldCADExportMatch)) {
        return { namespace: "manifold-cad-globals", path: args.path, pluginData };
      }
      if (options.files && Object.keys(options.files).includes(args.path)) {
        return { namespace: "virtual-file", path: args.path };
      }
      const result = await build2.resolve(args.path, {
        resolveDir: args.resolveDir,
        kind: "import-statement",
        pluginData: skipResolve
      });
      if (result.errors.length === 0) {
        if (manifoldCADExportPath && manifoldCADExportPath === result.path) {
          return {
            namespace: "manifold-cad-globals",
            path: args.path,
            pluginData
          };
        }
        return result;
      }
      if (options.fetchRemotePackages !== false && options.jsCDN) {
        return {
          path: cdnUrl(args.path, options.jsCDN),
          namespace: "http-url"
        };
      }
      return null;
    });
    build2.onLoad(
      { filter: /.*/, namespace: "manifold-cad-globals" },
      (args) => {
        const globals = args.pluginData?.toplevel ? "_manifold_cad_top_level" : "_manifold_cad_library";
        return {
          // Type hinting isn't necessary.  Only esbuild will see the swap,
          // and it doesn't do type validation.
          contents: `export const {${manifoldCADExportNames}} = ${globals};`
        };
      }
    );
    build2.onLoad(
      { filter: /.*/, namespace: "virtual-file" },
      (args) => {
        let loader = "ts";
        if (args.path.match(/\.js$/)) loader = "js";
        return { contents: options.files[args.path], loader };
      }
    );
    if (options.fetchRemotePackages !== false) {
      build2.onResolve({ filter: /^https?:\/\// }, (args) => {
        return { path: args.path, namespace: "http-url" };
      });
      build2.onResolve({ filter: /.*/, namespace: "http-url" }, (args) => {
        const path = new URL(args.path, args.importer).toString();
        if (path === cdnUrl(manifoldCADExportSpecifier, options.jsCDN)) {
          const response = {
            path,
            namespace: "manifold-cad-globals",
            pluginData: { toplevel: false }
          };
          return response;
        }
        return { path, namespace: "http-url" };
      });
      build2.onLoad({ filter: /.*/, namespace: "http-url" }, async (args) => {
        const response = await fetch(args.path);
        if (response.ok) {
          log(`Fetching ${args.path}.`);
          return { contents: await response.text() };
        } else {
          return { errors: [{ text: await response.text() }] };
        }
      });
    }
  }
});
var esbuild_initialized = false;
var getEsbuildConfig = async (options = {}) => {
  if (!esbuild_initialized) {
    const esbuildOptions = {};
    if (typeof esbuildWasmUrl === "string" && esbuildWasmUrl) {
      esbuildOptions.wasmURL = esbuildWasmUrl;
      esbuildOptions.worker = esbuildHasOwnWorker === true;
    }
    await esbuild.initialize(esbuildOptions);
    esbuild_initialized = true;
  }
  return {
    // Create a bundle in memory.
    bundle: true,
    write: false,
    platform: "neutral",
    treeShaking: false,
    sourcemap: "inline",
    sourcesContent: false,
    // We have the source handy already.
    format: "cjs",
    logLevel: "silent",
    plugins: [
      esbuildManifoldPlugin(options)
    ],
    // Some CDN imports will check import.meta.env.  This is only present when
    // generating an ESM bundle.  In other cases, it generates log noise, so
    // let's drop it down a log level.
    logOverride: { "empty-import-meta": "info" }
  };
};
var bundleCode = async (code, options = {}) => {
  try {
    let resolveDir;
    if (isNode() && options.filename) {
      const { dirname } = await import("node:path");
      resolveDir = dirname(options.filename);
    }
    const built = await esbuild.build({
      ...await getEsbuildConfig(options),
      stdin: {
        contents: code,
        sourcefile: options.filename,
        resolveDir,
        loader: "ts"
      }
    });
    return built.outputFiles[0].text;
  } catch (error) {
    if (error.errors?.length) {
      throw new BundlerError(error);
    } else {
      throw error;
    }
  }
};

// node_modules/@jscadui/3mf-export/src/defMatrix.js
var defMatrix = [
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
];

// node_modules/@jscadui/3mf-export/src/matrix2str.js
var matrix2str = (m) => {
  let str = "";
  for (let i = 0; i < 16; i++) {
    if (i % 4 == 3) continue;
    if (i > 0) str += " ";
    str += m[i] || 0;
  }
  return str;
};

// node_modules/@jscadui/3mf-export/src/makeItem.js
var makeItem = (id = 1, matrix = defMatrix) => `    <item objectid="${id}" transform="${matrix2str(matrix)}" />
`;

// node_modules/@jscadui/3mf-export/src/toDate3mf.js
var toDate3mf = (d) => d ? d.toISOString().substring(0, 10) : "";

// node_modules/@jscadui/3mf-export/src/pushHeader.js
function pushHeader(out, {
  unit = "millimeter",
  title = "jscad model",
  author = "",
  description = "",
  application = "jscad",
  creationDate = /* @__PURE__ */ new Date(),
  license = "",
  modificationDate
} = {}) {
  out.push(
    `<?xml version="1.0" encoding="UTF-8"?>
<model unit="${unit}" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:slic3rpe="http://schemas.slic3r.org/3mf/2017/06">
  <metadata name="slic3rpe:Version3mf">1</metadata>
  <metadata name="Title">${title}</metadata>
  <metadata name="Designer">${author}</metadata>
  <metadata name="Description">${description || title}</metadata>
  <metadata name="Copyright"></metadata>
  <metadata name="LicenseTerms">${license}</metadata>
  <metadata name="Rating"></metadata>
  <metadata name="CreationDate">${toDate3mf(creationDate)}</metadata>
  <metadata name="ModificationDate">${toDate3mf(modificationDate || creationDate)}</metadata>
  <metadata name="Application">${application}</metadata>
   `
  );
}

// node_modules/@jscadui/3mf-export/src/pushObjectComponent.js
function pushObjectWithComponents(out, id, children, name) {
  out.push(`<object id="${id}" type="model"${name == null ? "" : ' name="' + name + '"'}>
`);
  out.push(` <components>
`);
  children.forEach(
    ({ objectID, transform }) => {
      addComp(out, objectID, transform);
    }
  );
  out.push(` </components>
`);
  out.push(`</object>
`);
}
var addComp = (out, id = 1, matrix = defMatrix) => {
  out.push(
    `    <component objectid="${id}" transform="${matrix2str(matrix)}" />
`
  );
};

// node_modules/@jscadui/3mf-export/src/pushObjectMesh.js
function pushObjectWithMesh(out, id, vertices, indices, precision, name) {
  out.push(`  <object id="${id}" type="model"${!name ? "" : ' name="' + name + '"'}>
   <mesh>
    <vertices>
`);
  for (let i = 0; i < vertices.length; i += 3) {
    out.push(`     <vertex x="${vertices[i].toPrecision(precision)}" y="${vertices[i + 1].toPrecision(
      precision
    )}" z="${vertices[i + 2].toPrecision(precision)}" />
`);
  }
  out.push(`    </vertices>
    <triangles>
`);
  for (let i = 0; i < indices.length; i += 3) {
    out.push(`     <triangle v1="${indices[i]}" v2="${indices[i + 1]}" v3="${indices[i + 2]}" />
`);
  }
  out.push(`    </triangles>
   </mesh>
  </object>
`);
  return out;
}

// node_modules/@jscadui/3mf-export/src/staticFiles.js
var fileForContentTypes = {
  name: "[Content_Types].xml",
  content: `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
<Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
<Default Extension="png" ContentType="image/png" />
</Types>`
};

// node_modules/@jscadui/3mf-export/index.js
function to3dmodel({ meshes = [], components = [], items = [], precision = 17, header }) {
  const out = [];
  pushHeader(out, header);
  out.push("  <resources>\n");
  if (items.length == 0) {
    console.error("3MF empty build! Include items or simple.");
  }
  meshes.forEach(({ id, vertices, indices, name }) => pushObjectWithMesh(out, id, vertices, indices, precision, name));
  components.forEach(({ id, children, name }) => {
    pushObjectWithComponents(out, id, children, name);
  });
  out.push("  </resources>\n");
  out.push(`<build>
`);
  items.forEach(({ objectID, transform }) => {
    out.push(makeItem(objectID, transform));
  });
  out.push("</build>\n");
  out.push("</model>\n");
  return out.join("");
}
var FileForRelThumbnail = class {
  constructor() {
    this.idSeq = 0;
    this.lines = [
      `<?xml version="1.0" encoding="UTF-8"?>`,
      `<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`
    ];
  }
  get name() {
    return "_rels/.rels";
  }
  /**
  *
  * @param {*} target file path
  * @param {*} xmlType xml schema url
  */
  addRel(target, xmlType) {
    this.lines.push(`  <Relationship Target="${target}" Id="rel-${++this.idSeq}" Type="${xmlType}" />`);
  }
  add3dModel(path) {
    this.addRel(path, "http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel");
  }
  addThumbnail(path) {
    this.addRel(path, "http://schemas.openxmlformats.org/package/2006/relationships/metadata/thumbnail");
  }
  get content() {
    return this.lines.join("\n") + `
</Relationships>`;
  }
};

// node_modules/fflate/esm/browser.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0; i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = (function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (; i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
});
var flt = new u8(288);
for (i = 0; i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144; i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256; i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280; i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0; i < 32; ++i)
  fdt[i] = 5;
var i;
var flm = /* @__PURE__ */ hMap(flt, 9, 0);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var wbits = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
};
var wbits16 = function(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >> 8;
  d[o + 2] |= v >> 16;
};
var hTree = function(d, mb) {
  var t = [];
  for (var i = 0; i < d.length; ++i) {
    if (d[i])
      t.push({ s: i, f: d[i] });
  }
  var s = t.length;
  var t2 = t.slice();
  if (!s)
    return { t: et, l: 0 };
  if (s == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return { t: v, l: 1 };
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({ s: -1, f: 25001 });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
  t[0] = { s: -1, f: l.f + r.f, l, r };
  while (i1 != s - 1) {
    l = t[t[i0].f < t[i2].f ? i0++ : i2++];
    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
    t[i1++] = { s: -1, f: l.f + r.f, l, r };
  }
  var maxSym = t2[0].s;
  for (var i = 1; i < s; ++i) {
    if (t2[i].s > maxSym)
      maxSym = t2[i].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (; i < s; ++i) {
      var i2_1 = t2[i].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>= lft;
    while (dt > 0) {
      var i2_2 = t2[i].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i;
    }
    for (; i >= 0 && dt; --i) {
      var i2_3 = t2[i].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return { t: new u8(tr), l: mbt };
};
var ln = function(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
};
var lc = function(c) {
  var s = c.length;
  while (s && !c[--s])
    ;
  var cl = new u16(++s);
  var cli = 0, cln = c[0], cls = 1;
  var w = function(v) {
    cl[cli++] = v;
  };
  for (var i = 1; i <= s; ++i) {
    if (c[i] == cln && i != s)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138)
          w(32754);
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6)
          w(8304);
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--)
        w(cln);
      cls = 1;
      cln = c[i];
    }
  }
  return { c: cl.subarray(0, cli), n: s };
};
var clen = function(cf, cl) {
  var l = 0;
  for (var i = 0; i < cl.length; ++i)
    l += cf[i] * cl[i];
  return l;
};
var wfblk = function(out, pos, dat) {
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i = 0; i < s; ++i)
    out[o + i + 4] = dat[i];
  return (o + 4 + s) * 8;
};
var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];
  var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
  var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
  var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
  var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
  var lcfreq = new u16(19);
  for (var i = 0; i < lclt.length; ++i)
    ++lcfreq[lclt[i] & 31];
  for (var i = 0; i < lcdt.length; ++i)
    ++lcfreq[lcdt[i] & 31];
  var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
    ;
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
  if (bs >= 0 && flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i = 0; i < nlcc; ++i)
      wbits(out, p + 3 * i, lct[clim[i]]);
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i] >> 5 & 127), p += clct[i] >> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i = 0; i < li; ++i) {
    var sym = syms[i];
    if (sym > 255) {
      var len = sym >> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, sym >> 23 & 31), p += fleb[len];
      var dst = sym & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, sym >> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[sym]), p += ll[sym];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = /* @__PURE__ */ new u8(0);
var dflt = function(dat, lvl, plvl, pre, post, st) {
  var s = st.z || dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post);
  var w = o.subarray(pre, o.length - post);
  var lst = st.l;
  var pos = (st.r || 0) & 7;
  if (lvl) {
    if (pos)
      w[0] = st.r >> 3;
    var opt = deo[lvl - 1];
    var n = opt >> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function(i2) {
      return (dat[i2] ^ dat[i2 + 1] << bs1_1 ^ dat[i2 + 2] << bs2_1) & msk_1;
    };
    var syms = new i32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
    for (; i + 2 < s; ++i) {
      var hv = hsh(i);
      var imod = i & 32767, pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i) {
        var rem = s - i;
        if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;
          for (var j = 0; j < 286; ++j)
            lf[j] = 0;
          for (var j = 0; j < 30; ++j)
            df[j] = 0;
        }
        var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                ;
              if (nl > l) {
                l = nl, d = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i - dif + j & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod & 32767;
          }
        }
        if (d) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31, din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }
    for (i = Math.max(i, wi); i < s; ++i) {
      syms[li++] = dat[i];
      ++lf[dat[i]];
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
    if (!lst) {
      st.r = pos & 7 | w[pos / 8 | 0] << 3;
      pos -= 7;
      st.h = head, st.p = prev, st.i = i, st.w = wi;
    }
  } else {
    for (var i = st.w || 0; i < s + lst; i += 65535) {
      var e = i + 65535;
      if (e >= s) {
        w[pos / 8 | 0] = lst;
        e = s;
      }
      pos = wfblk(w, pos + 1, dat.subarray(i, e));
    }
    st.i = s;
  }
  return slc(o, 0, pre + shft(pos) + post);
};
var crct = /* @__PURE__ */ (function() {
  var t = new Int32Array(256);
  for (var i = 0; i < 256; ++i) {
    var c = i, k = 9;
    while (--k)
      c = (c & 1 && -306674912) ^ c >>> 1;
    t[i] = c;
  }
  return t;
})();
var crc = function() {
  var c = -1;
  return {
    p: function(d) {
      var cr = c;
      for (var i = 0; i < d.length; ++i)
        cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
      c = cr;
    },
    d: function() {
      return ~c;
    }
  };
};
var dopt = function(dat, opt, pre, post, st) {
  if (!st) {
    st = { l: 1 };
    if (opt.dictionary) {
      var dict = opt.dictionary.subarray(-32768);
      var newDat = new u8(dict.length + dat.length);
      newDat.set(dict);
      newDat.set(dat, dict.length);
      dat = newDat;
      st.w = dict.length;
    }
  }
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st);
};
var mrg = function(a, b) {
  var o = {};
  for (var k in a)
    o[k] = a[k];
  for (var k in b)
    o[k] = b[k];
  return o;
};
var wbytes = function(d, b, v) {
  for (; v; ++b)
    d[b] = v, v >>>= 8;
};
function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
var fltn = function(d, p, t, o) {
  for (var k in d) {
    var val = d[k], n = p + k, op = o;
    if (Array.isArray(val))
      op = mrg(o, val[1]), val = val[0];
    if (val instanceof u8)
      t[n] = [val, op];
    else {
      t[n += "/"] = [new u8(0), op];
      fltn(val, n, t, o);
    }
  }
};
var te = typeof TextEncoder != "undefined" && /* @__PURE__ */ new TextEncoder();
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {
}
function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);
    for (var i = 0; i < str.length; ++i)
      ar_1[i] = str.charCodeAt(i);
    return ar_1;
  }
  if (te)
    return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;
  var w = function(v) {
    ar[ai++] = v;
  };
  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }
    var c = str.charCodeAt(i);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
var exfl = function(ex) {
  var le = 0;
  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535)
        err(9);
      le += l + 4;
    }
  }
  return le;
};
var wzh = function(d, b, f, fn, u, c, ce, co) {
  var fl2 = fn.length, ex = f.extra, col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 33639248 : 67324752), b += 4;
  if (ce != null)
    d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2;
  d[b++] = f.flag << 1 | (c < 0 && 8), d[b++] = u && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119)
    err(10);
  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >> 1), b += 4;
  if (c != -1) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c < 0 ? -c - 2 : c);
    wbytes(d, b + 8, f.size);
  }
  wbytes(d, b + 12, fl2);
  wbytes(d, b + 14, exl), b += 16;
  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }
  d.set(fn, b);
  b += fl2;
  if (exl) {
    for (var k in ex) {
      var exf = ex[k], l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }
  if (col)
    d.set(co, b), b += col;
  return b;
};
var wzf = function(o, b, c, d, e) {
  wbytes(o, b, 101010256);
  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
function zipSync(data, opts) {
  if (!opts)
    opts = {};
  var r = {};
  var files = [];
  fltn(data, "", r, opts);
  var o = 0;
  var tot = 0;
  for (var fn in r) {
    var _a2 = r[fn], file = _a2[0], p = _a2[1];
    var compression = p.level == 0 ? 0 : 8;
    var f = strToU8(fn), s = f.length;
    var com = p.comment, m = com && strToU8(com), ms = m && m.length;
    var exl = exfl(p.extra);
    if (s > 65535)
      err(11);
    var d = compression ? deflateSync(file, p) : file, l = d.length;
    var c = crc();
    c.p(file);
    files.push(mrg(p, {
      size: file.length,
      crc: c.d(),
      c: d,
      f,
      m,
      u: s != fn.length || m && com.length != ms,
      o,
      compression
    }));
    o += 30 + s + exl + l;
    tot += 76 + 2 * (s + exl) + (ms || 0) + l;
  }
  var out = new u8(tot + 22), oe = o, cdl = tot - o;
  for (var i = 0; i < files.length; ++i) {
    var f = files[i];
    wzh(out, f.o, f, f.f, f.u, f.c.length);
    var badd = 30 + f.f.length + exfl(f.extra);
    out.set(f.c, f.o + badd);
    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
  }
  wzf(out, o, files.length, cdl, oe);
  return out;
}

// lib/export-3mf.ts
var Export3MF = class {
  extensions = ["3mf"];
  unit = "millimeter";
  title = "ManifoldCAD.org model";
  author;
  description = "ManifoldCAD.org model";
  application = "ManifoldCAD.org";
  creationDate;
  license;
  modificationDate;
  /**
   * Convert a GLTF-Transform document to a 3MF model.
   *
   * @param doc The GLTF document to convert.
   * @returns A blob containing the converted model.
   */
  async asBlob(doc) {
    const to3mf = {
      meshes: [],
      components: [],
      items: [],
      precision: 7,
      header: {
        unit: this.unit,
        title: this.title,
        description: this.description,
        application: this.application,
        creationDate: this.creationDate,
        license: this.license,
        modificationDate: this.modificationDate
      }
    };
    let nextGlobalID = 1;
    const object2globalID = /* @__PURE__ */ new Map();
    const getObjectID = (obj) => `${object2globalID.get(obj)}`;
    const getMeshID = (mesh) => {
      const { clonedFrom } = mesh.getExtras();
      if (clonedFrom) {
        return object2globalID.get(clonedFrom);
      }
      return object2globalID.get(mesh);
    };
    const setObjectID = (obj) => {
      const objectID = `${nextGlobalID++}`;
      object2globalID.set(obj, objectID);
      return objectID;
    };
    for (const mesh of doc.getRoot().listMeshes()) {
      const manifoldPrimitive = mesh.getExtension("EXT_mesh_manifold");
      if (manifoldPrimitive) {
        const indices = manifoldPrimitive.getIndices();
        const positionAccessor = mesh.listPrimitives()[0].getAttribute("POSITION");
        const objectID = setObjectID(mesh);
        to3mf.meshes.push({
          vertices: positionAccessor.getArray(),
          indices: indices.getArray(),
          id: objectID
        });
      }
      const { clonedFrom } = mesh.getExtras();
      if (!manifoldPrimitive && clonedFrom) {
        continue;
      }
      if (!manifoldPrimitive && !clonedFrom) {
        console.log("skipping non-ManifoldCAD mesh");
      }
    }
    const nodes2 = doc.getRoot().listNodes().reverse();
    for (const node of nodes2) {
      const meshID = node.getMesh() && getMeshID(node.getMesh());
      to3mf.components.push({
        id: setObjectID(node),
        name: node.getName(),
        children: meshID ? [{ objectID: meshID }] : [],
        transform: node.getMatrix().map((n) => n.toFixed(to3mf.precision))
      });
    }
    for (const node of doc.getRoot().listNodes()) {
      const objectID = getObjectID(node);
      if (!objectID) {
        console.log(`Could not find object ID for ${node.getName()}`);
        continue;
      }
      const child = {
        objectID,
        // Most 3MF parsers will not accept a number in scientific notation.
        // Transforms are serialized to a string, containing 12 numbers
        // separated by spaces.  If we force a number to a string here,
        // 3mf-export passes it through.
        transform: node.getMatrix().map((n) => n.toFixed(to3mf?.precision ?? 7))
      };
      const parent = node.getParentNode();
      if (parent) {
        const parentID = getObjectID(parent);
        const parent3mf = to3mf.components.find((comp) => comp.id == parentID);
        parent3mf.children.push(child);
      } else {
        to3mf.items.push({ objectID });
      }
    }
    const fileForRelThumbnail = new FileForRelThumbnail();
    fileForRelThumbnail.add3dModel("3D/3dmodel.model");
    const model = to3dmodel(to3mf);
    const files = {};
    files["3D/3dmodel.model"] = strToU8(model);
    files[fileForContentTypes.name] = strToU8(fileForContentTypes.content);
    files[fileForRelThumbnail.name] = strToU8(fileForRelThumbnail.content);
    const zipFile = zipSync(files);
    return new Blob(
      [zipFile],
      { type: "application/vnd.ms-package.3dmanufacturing-3dmodel+xml" }
    );
  }
};

// lib/export-gltf.ts
init_index_modern();
init_index_modern2();
init_gltf_io();
var ExportGLTF = class {
  extensions = ["glb", "gltf"];
  /**
   * Convert a GLTF-Transform document to a blob.
   *
   * @param doc The GLTF document to convert.
   * @returns A blob containing the converted model.
   */
  async asBlob(doc) {
    const io = setupIO(new WebIO());
    io.registerExtensions(KHRONOS_EXTENSIONS);
    const glb = await io.writeBinary(doc);
    return new Blob(
      [glb],
      { type: "application/octet-stream" }
    );
  }
};

// lib/worker.ts
init_garbage_collector();
init_gltf_node();
init_level_of_detail();

// lib/scene-builder.ts
init_index_modern();
init_animation();
init_debug();
init_gltf_io();
init_gltf_node();
init_material();
init_math();
init_animation();
init_debug();
init_gltf_node();
init_level_of_detail();
init_material();
function cleanup7() {
  cleanup();
  cleanup6();
  cleanup5();
}
function log2(...args) {
  if (typeof self !== "undefined" && self.console) {
    self.console.log(...args);
  }
}
function createGLTFnode(doc, node) {
  const out = doc.createNode(node.name);
  const pos = addMotion(doc, "translation", node, out);
  if (pos != null) {
    out.setTranslation(pos);
  }
  const rot = addMotion(doc, "rotation", node, out);
  if (rot != null) {
    out.setRotation(euler2quat(rot));
  }
  const scale = addMotion(doc, "scale", node, out);
  if (scale != null) {
    out.setScale(scale);
  }
  return out;
}
function addMesh(doc, node, manifold, backupMaterial = {}) {
  const numTri = manifold.numTri();
  if (numTri == 0) {
    log2("Empty manifold, skipping.");
    return;
  }
  log2(`Triangles: ${numTri.toLocaleString()}`);
  const box = manifold.boundingBox();
  const size = [0, 0, 0];
  for (let i = 0; i < 3; i++) {
    size[i] = Math.round((box.max[i] - box.min[i]) * 10) / 10;
  }
  log2(`Bounding Box: X = ${size[0].toLocaleString()} mm, Y = ${size[1].toLocaleString()} mm, Z = ${size[2].toLocaleString()} mm`);
  const volume = Math.round(manifold.volume() / 10);
  log2(`Genus: ${manifold.genus().toLocaleString()}, Volume: ${(volume / 100).toLocaleString()} cm^3`);
  const manifoldMesh = manifold.getMesh();
  const id2properties = /* @__PURE__ */ new Map();
  for (const id of manifoldMesh.runOriginalID) {
    const material = getMaterialByID2(id) || backupMaterial;
    id2properties.set(id, {
      material: getCachedMaterial(doc, material),
      attributes: ["POSITION", ...material.attributes ?? []]
    });
  }
  const morph = getMorph(manifold);
  const inputPositions = morphStart(manifoldMesh, morph);
  const mesh = writeMesh(doc, manifoldMesh, id2properties);
  node.setMesh(mesh);
  morphEnd(doc, manifoldMesh, mesh, inputPositions, morph);
  const debugNodes = getDebugGLTFMesh(doc, manifoldMesh, id2properties, backupMaterial);
  for (const debugNode of debugNodes) {
    node.addChild(debugNode);
  }
}
function cloneNode(toNode, fromNode) {
  toNode.setMesh(fromNode.getMesh());
  fromNode.listChildren().forEach((child) => {
    const clone = child.clone();
    toNode.addChild(clone);
  });
}
function cloneNodeNewMaterial(doc, toNode, fromNode, backupMaterial, oldBackupMaterial) {
  cloneNode(toNode, fromNode);
  const oldMesh = fromNode.getMesh();
  const newMesh = doc.createMesh();
  toNode.setMesh(newMesh);
  oldMesh.listPrimitives().forEach((primitive) => {
    const newPrimitive = primitive.clone();
    if (primitive.getMaterial() === oldBackupMaterial) {
      newPrimitive.setMaterial(backupMaterial);
    }
    newMesh.addPrimitive(newPrimitive);
  });
  newMesh.setExtras({ clonedFrom: oldMesh });
}
function createNodeFromCache(doc, nodeDef, manifold2node) {
  const node = createGLTFnode(doc, nodeDef);
  const { manifold } = nodeDef;
  if (manifold) {
    setMorph(doc, node, manifold);
    const backupMaterial = getBackupMaterial(nodeDef);
    const cachedNodes = manifold2node.get(manifold);
    if (cachedNodes == null) {
      addMesh(doc, node, manifold, backupMaterial);
      const cache = /* @__PURE__ */ new Map();
      cache.set(backupMaterial, node);
      manifold2node.set(manifold, cache);
    } else {
      const cachedNode = cachedNodes.get(backupMaterial);
      if (cachedNode == null) {
        const [oldBackupMaterial, oldNode] = cachedNodes.entries().next().value;
        cloneNodeNewMaterial(
          doc,
          node,
          oldNode,
          getCachedMaterial(doc, backupMaterial),
          getCachedMaterial(doc, oldBackupMaterial)
        );
        cachedNodes.set(backupMaterial, node);
      } else {
        cloneNode(node, cachedNode);
      }
    }
  }
  return node;
}
function createWrapper(doc) {
  const halfRoot2 = Math.sqrt(2) / 2;
  const mm2m = 1 / 1e3;
  const wrapper = doc.createNode("wrapper").setRotation([-halfRoot2, 0, 0, halfRoot2]).setScale([mm2m, mm2m, mm2m]);
  doc.createScene().addChild(wrapper);
  return wrapper;
}
function GLTFNodesToGLTFDoc(nodes2) {
  if (nodes2.length == 0) {
    throw new TypeError("nodes[] must contain at least one GLTFNode.");
  }
  const doc = new Document();
  const root = createWrapper(doc);
  addAnimationToDoc(doc);
  const node2gltf = /* @__PURE__ */ new Map();
  const manifold2node = /* @__PURE__ */ new Map();
  let leafNodes = 0;
  for (const nodeDef of nodes2) {
    node2gltf.set(nodeDef, createNodeFromCache(doc, nodeDef, manifold2node));
    if (nodeDef.manifold) {
      ++leafNodes;
    }
  }
  for (const nodeDef of nodes2) {
    const gltfNode = node2gltf.get(nodeDef);
    const { parent } = nodeDef;
    if (parent) {
      node2gltf.get(parent).addChild(gltfNode);
    } else {
      root.addChild(gltfNode);
    }
  }
  log2(
    "Total glTF nodes: ",
    nodes2.length,
    ", Total mesh references: ",
    leafNodes
  );
  cleanupAnimationInDoc();
  return doc;
}

// lib/worker.ts
init_wasm();
var exporters;
var AsyncFunction = Object.getPrototypeOf(async function() {
}).constructor;
function log3(...args) {
  if (typeof self !== "undefined" && self.console) {
    self.console.log(...args);
  }
}
function cleanup8() {
  cleanup2();
  cleanup7();
  cleanup4();
  cleanup3();
}
async function evaluate(code, options = {}) {
  cleanup8();
  const t0 = performance.now();
  const { doNotBundle, ...bundleOpt } = options;
  const bundled = doNotBundle === true ? code : await bundleCode(code, bundleOpt);
  const t1 = performance.now();
  if (doNotBundle !== true) {
    log3(`Bundling code took ${((t1 - t0) / 1e3).toFixed(2)} seconds`);
  }
  const manifoldCAD = await init_manifoldCAD().then(() => manifoldCAD_exports);
  const manifoldImport = {
    ...manifoldCAD,
    isManifoldCAD: () => true
  };
  const toplevelImport = {
    ...manifoldImport,
    GLTFNode: GLTFNodeTracked,
    getGLTFNodes,
    resetGLTFNodes
  };
  const globals = {
    // These accessors are only available to top level scripts.
    // See ../lib/manifoldCADGlobals.d.ts
    setCircularSegments,
    setMinCircularAngle,
    setMinCircularEdgeLength,
    resetToCircularDefaults,
    setAnimationDuration,
    setAnimationFPS,
    setAnimationMode,
    // The bundler will swap these objects in when needed.
    _manifold_cad_top_level: toplevelImport,
    _manifold_cad_library: manifoldImport,
    // While this project is built using ES modules, and we assume models and
    // libraries are ES modules, code executed via `new Function()` or `eval` is
    // treated as commonJS.
    // CommonJS expects 'exports' to exist:
    exports: {},
    // This is where we expect results after running the script.
    module: { exports: { default: null } }
  };
  let result = null;
  try {
    const evalFn = new AsyncFunction(...Object.keys(globals), bundled);
    await evalFn(...Object.values(globals));
    result = globals.module?.exports?.default;
    if (typeof result === "function") {
      result = await result();
    }
  } catch (error) {
    const stacktrace = getSourceMappedStackTrace(bundled, error, -2);
    let newError = null;
    const missing = Object.keys(toplevelImport).find((x) => error.message.match(x));
    if (error.name === "ReferenceError" && missing) {
      newError = new RuntimeError(
        error,
        error.message + `.  Import it by adding \`import {${missing}} from 'manifold-3d/manifoldCAD';\` to the top of your model.`
      );
    } else if (error.name === "ReferenceError" && error.message.match(/glMatrix/)) {
      newError = new RuntimeError(
        error,
        "ManifoldCAD no longer includes gl-matrix directly.  Import it by adding `import * as glMatrix from 'gl-matrix';` to the top of your model."
      );
    } else {
      newError = new RuntimeError(error);
    }
    newError.manifoldStack = stacktrace;
    throw newError;
  }
  const t2 = performance.now();
  log3(`Manifold took ${((t2 - t1) / 1e3).toFixed(2)} seconds`);
  if (!result || Array.isArray(result) && !result.length) {
    if (getGLTFNodes().length) {
      throw new Error(
        "GLTF Nodes were created, but not exported.  Add `const nodes = getGLTFNodes();` and `export default nodes;` to the end of your model."
      );
    }
    throw new Error(
      "No output as no model was exported.  Add a default export (e.g.: `export default result;`) to the bottom of your model.  The default export must be a `Manifold` or `GLTFNode` object, an array of `Manifold` or `GLTFNode` objects, or a function that returns any of the above."
    );
  }
  const nodes2 = await anyToGLTFNodeList(result);
  const doc = GLTFNodesToGLTFDoc(nodes2);
  const t3 = performance.now();
  log3(`Creating GLTF Document took ${((t3 - t2) / 1e3).toFixed(2)} seconds`);
  return doc;
}
var exportBlobURL = async (doc, extension) => {
  const t0 = performance.now();
  exporters = [new Export3MF(), new ExportGLTF()];
  const blob = await exporters.find((ex) => ex.extensions.includes(extension)).asBlob(doc);
  const blobURL = URL.createObjectURL(blob);
  const t1 = performance.now();
  log3(`Exporting ${extension.toUpperCase()} took ${(Math.round((t1 - t0) / 10) / 100).toLocaleString()} seconds`);
  return blobURL;
};
var initializeWebWorker = () => {
  const interceptConsole = () => {
    console.debug("Intercepting console.log() in manifoldCAD worker.");
    if (self.console) {
      const oldLog = self.console.log;
      self.console.log = function(...args) {
        let message = "";
        for (const arg of args) {
          if (arg == null) {
            message += "undefined";
          } else if (typeof arg == "object") {
            message += JSON.stringify(arg, null, 4);
          } else {
            message += arg.toString();
          }
        }
        self.postMessage({ type: "log", message });
        oldLog(...args);
      };
    }
    ;
  };
  const sendError = (error) => {
    console.error(error);
    if (error.cause) console.error("Caused by:", error.cause);
    if (error.manifoldStack)
      console.error("manifoldStack:", error.manifoldStack);
    self.postMessage({
      type: "error",
      name: error.name,
      message: error.message,
      stack: error.manifoldStack ?? error.stack
    });
  };
  const handleInitialize = async (message) => {
    try {
      console.debug("Initializing ManifoldCAD worker.");
      if (message.manifoldWasmUrl) setWasmUrl2(message.manifoldWasmUrl);
      if (message.esbuildWasmUrl) setWasmUrl(message.esbuildWasmUrl);
      setHasOwnWorker(message.esbuildHasOwnWorker === true);
      await getManifoldModule();
      interceptConsole();
      self.postMessage({ type: "ready" });
      console.debug("Successfully initialized ManifoldCAD worker!");
    } catch (error) {
      sendError(error);
    }
  };
  let gltfdoc = null;
  const handleEvaluate = async (message) => {
    try {
      const { code, ...options } = message;
      gltfdoc = await evaluate(message.code, options);
      self.postMessage({ type: "done" });
    } catch (error) {
      sendError(error);
    }
  };
  const handleExport = async (message) => {
    try {
      self.postMessage({
        type: "blob",
        extension: message.extension,
        blobURL: await exportBlobURL(gltfdoc, message.extension)
      });
    } catch (error) {
      sendError(error);
    }
  };
  self.onmessage = async (e) => {
    const message = e.data;
    if (message.type === "initialize") {
      handleInitialize(message);
    } else if (message.type === "evaluate") {
      handleEvaluate(message);
    } else if (message.type === "export") {
      handleExport(message);
    }
  };
};
if (isWebWorker()) initializeWebWorker();
export {
  cleanup8 as cleanup,
  evaluate,
  exportBlobURL
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3Byb3BlcnR5LWdyYXBoL3NyYy9ldmVudC1kaXNwYXRjaGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1ncmFwaC9zcmMvZ3JhcGgtZWRnZS50cyIsICIuLi9ub2RlX21vZHVsZXMvcHJvcGVydHktZ3JhcGgvc3JjL2dyYXBoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1ncmFwaC9zcmMvcmVmcy50cyIsICIuLi9ub2RlX21vZHVsZXMvcHJvcGVydHktZ3JhcGgvc3JjL2dyYXBoLW5vZGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9jb25zdGFudHMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy91dGlscy9idWZmZXItdXRpbHMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy91dGlscy9jb2xvci11dGlscy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3V0aWxzL2ltYWdlLXV0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvdXRpbHMvZmlsZS11dGlscy50cyIsICIuLi9ub2RlX21vZHVsZXMvbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vY29tbW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWMzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvdXRpbHMvZ2V0LWJvdW5kcy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3V0aWxzL2h0dHAtdXRpbHMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy91dGlscy9pcy1wbGFpbi1vYmplY3QudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy91dGlscy9sb2dnZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy91dGlscy9tYXRoLXV0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvdXRpbHMvcHJvcGVydHktdXRpbHMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy91dGlscy91dWlkLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9wcm9wZXJ0eS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvZXh0ZW5zaWJsZS1wcm9wZXJ0eS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvYWNjZXNzb3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL2FuaW1hdGlvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvYW5pbWF0aW9uLWNoYW5uZWwudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL2FuaW1hdGlvbi1zYW1wbGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9idWZmZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL2NhbWVyYS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL3Byb3BlcnRpZXMvZXh0ZW5zaW9uLXByb3BlcnR5LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy90ZXh0dXJlLWluZm8udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL21hdGVyaWFsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9tZXNoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9ub2RlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9wcmltaXRpdmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL3ByaW1pdGl2ZS10YXJnZXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9wcm9wZXJ0aWVzL3NjZW5lLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9za2luLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy90ZXh0dXJlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvcHJvcGVydGllcy9yb290LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvZG9jdW1lbnQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9leHRlbnNpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9pby9yZWFkZXItY29udGV4dC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL2lvL3JlYWRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL2lvL3dyaXRlci1jb250ZXh0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvaW8vd3JpdGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvaW8vcGxhdGZvcm0taW8udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9jb3JlL3NyYy9pby9kZW5vLWlvLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vY29yZS9zcmMvaW8vbm9kZS1pby50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2NvcmUvc3JjL2lvL3dlYi1pby50cyIsICIuLi9saWIvbWF0aC50cyIsICIuLi9saWIvYW5pbWF0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9lc2J1aWxkLXdhc20vbGliL2Jyb3dzZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3Jlc29sdmUtdXJpL3NyYy9yZXNvbHZlLXVyaS50cyIsICIuLi9ub2RlX21vZHVsZXMvY29udmVydC1zb3VyY2UtbWFwL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9rdHgtcGFyc2Uvc3JjL2NvbnN0YW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMva3R4LXBhcnNlL3NyYy9jcmVhdGUtZGVmYXVsdC1jb250YWluZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2t0eC1wYXJzZS9zcmMvYnVmZmVyLXJlYWRlci50cyIsICIuLi9ub2RlX21vZHVsZXMva3R4LXBhcnNlL3NyYy9jb25zdGFudHMtaW50ZXJuYWwudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2t0eC1wYXJzZS9zcmMvdXRpbC50cyIsICIuLi9ub2RlX21vZHVsZXMva3R4LXBhcnNlL3NyYy9yZWFkLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9rdHgtcGFyc2Uvc3JjL3dyaXRlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvY29uc3RhbnRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvZXh0LW1lc2gtZ3B1LWluc3RhbmNpbmcvaW5zdGFuY2VkLW1lc2gudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9leHQtbWVzaC1ncHUtaW5zdGFuY2luZy9tZXNoLWdwdS1pbnN0YW5jaW5nLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvZXh0LW1lc2hvcHQtY29tcHJlc3Npb24vY29uc3RhbnRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvZXh0LW1lc2hvcHQtY29tcHJlc3Npb24vZGVjb2Rlci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2V4dC1tZXNob3B0LWNvbXByZXNzaW9uL2VuY29kZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9leHQtbWVzaG9wdC1jb21wcmVzc2lvbi9tZXNob3B0LWNvbXByZXNzaW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMvZXh0LXRleHR1cmUtYXZpZi90ZXh0dXJlLWF2aWYudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9leHQtdGV4dHVyZS13ZWJwL3RleHR1cmUtd2VicC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1kcmFjby1tZXNoLWNvbXByZXNzaW9uL2RlY29kZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItZHJhY28tbWVzaC1jb21wcmVzc2lvbi9lbmNvZGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLWRyYWNvLW1lc2gtY29tcHJlc3Npb24vZHJhY28tbWVzaC1jb21wcmVzc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1saWdodHMtcHVuY3R1YWwvbGlnaHQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbGlnaHRzLXB1bmN0dWFsL2xpZ2h0cy1wdW5jdHVhbC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtYW5pc290cm9weS9hbmlzb3Ryb3B5LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1hbmlzb3Ryb3B5L21hdGVyaWFscy1hbmlzb3Ryb3B5LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1jbGVhcmNvYXQvY2xlYXJjb2F0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1jbGVhcmNvYXQvbWF0ZXJpYWxzLWNsZWFyY29hdC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtZGlmZnVzZS10cmFuc21pc3Npb24vZGlmZnVzZS10cmFuc21pc3Npb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLWRpZmZ1c2UtdHJhbnNtaXNzaW9uL21hdGVyaWFscy1kaWZmdXNlLXRyYW5zbWlzc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtZGlzcGVyc2lvbi9kaXNwZXJzaW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1kaXNwZXJzaW9uL21hdGVyaWFscy1kaXNwZXJzaW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1lbWlzc2l2ZS1zdHJlbmd0aC9lbWlzc2l2ZS1zdHJlbmd0aC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtZW1pc3NpdmUtc3RyZW5ndGgvbWF0ZXJpYWxzLWVtaXNzaXZlLXN0cmVuZ3RoLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1pb3IvaW9yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy1pb3IvbWF0ZXJpYWxzLWlvci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtaXJpZGVzY2VuY2UvaXJpZGVzY2VuY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLWlyaWRlc2NlbmNlL21hdGVyaWFscy1pcmlkZXNjZW5jZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtcGJyLXNwZWN1bGFyLWdsb3NzaW5lc3MvcGJyLXNwZWN1bGFyLWdsb3NzaW5lc3MudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXBici1zcGVjdWxhci1nbG9zc2luZXNzL21hdGVyaWFscy1wYnItc3BlY3VsYXItZ2xvc3NpbmVzcy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtc2hlZW4vc2hlZW4udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXNoZWVuL21hdGVyaWFscy1zaGVlbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtc3BlY3VsYXIvc3BlY3VsYXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXNwZWN1bGFyL21hdGVyaWFscy1zcGVjdWxhci50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtdHJhbnNtaXNzaW9uL3RyYW5zbWlzc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtdHJhbnNtaXNzaW9uL21hdGVyaWFscy10cmFuc21pc3Npb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXVubGl0L3VubGl0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy11bmxpdC9tYXRlcmlhbHMtdW5saXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXZhcmlhbnRzL21hcHBpbmcudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItbWF0ZXJpYWxzLXZhcmlhbnRzL21hcHBpbmctbGlzdC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtdmFyaWFudHMvdmFyaWFudC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tYXRlcmlhbHMtdmFyaWFudHMvbWF0ZXJpYWxzLXZhcmlhbnRzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy12b2x1bWUvdm9sdW1lLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLW1hdGVyaWFscy12b2x1bWUvbWF0ZXJpYWxzLXZvbHVtZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci1tZXNoLXF1YW50aXphdGlvbi9tZXNoLXF1YW50aXphdGlvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci10ZXh0dXJlLWJhc2lzdS90ZXh0dXJlLWJhc2lzdS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2toci10ZXh0dXJlLXRyYW5zZm9ybS90cmFuc2Zvcm0udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHItdGV4dHVyZS10cmFuc2Zvcm0vdGV4dHVyZS10cmFuc2Zvcm0udHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BnbHRmLXRyYW5zZm9ybS9leHRlbnNpb25zL3NyYy9raHIteG1wLWpzb24tbGQvcGFja2V0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AZ2x0Zi10cmFuc2Zvcm0vZXh0ZW5zaW9ucy9zcmMva2hyLXhtcC1qc29uLWxkL3htcC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGdsdGYtdHJhbnNmb3JtL2V4dGVuc2lvbnMvc3JjL2luZGV4LnRzIiwgIi4uL2xpYi9tYW5pZm9sZC1nbHRmLnRzIiwgIi4uL2xpYi9nbHRmLWlvLnRzIiwgIi4uL2xpYi9nYXJiYWdlLWNvbGxlY3Rvci50cyIsICIuLi9saWIvZ2x0Zi1ub2RlLnRzIiwgIi4uL21hbmlmb2xkLmpzIiwgIi4uL2xpYi93YXNtLnRzIiwgIi4uL2xpYi9sZXZlbC1vZi1kZXRhaWwudHMiLCAiLi4vbGliL21hdGVyaWFsLnRzIiwgIi4uL2xpYi9kZWJ1Zy50cyIsICIuLi9saWIvbWFuaWZvbGRDQUQudHMiLCAiLi4vbGliL3dvcmtlci50cyIsICIuLi9saWIvYnVuZGxlci50cyIsICIuLi9saWIvZXJyb3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYy9zcmMvdmxxLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMvc3JjL3N0cmluZ3MudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYy9zcmMvc2NvcGVzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMvc3JjL3NvdXJjZW1hcC1jb2RlYy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9zcmMvdHJhY2UtbWFwcGluZy50cyIsICIuLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9zcmMvcmVzb2x2ZS50cyIsICIuLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9zcmMvc3RyaXAtZmlsZW5hbWUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcvc3JjL3NvdXJjZW1hcC1zZWdtZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC90cmFjZS1tYXBwaW5nL3NyYy9zb3J0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC90cmFjZS1tYXBwaW5nL3NyYy9ieS1zb3VyY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcvc3JjL2JpbmFyeS1zZWFyY2gudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcvc3JjL3R5cGVzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC90cmFjZS1tYXBwaW5nL3NyYy9mbGF0dGVuLW1hcC50cyIsICIuLi9saWIvdXRpbC50cyIsICIuLi9ub2RlX21vZHVsZXMvQGpzY2FkdWkvM21mLWV4cG9ydC9zcmMvZGVmTWF0cml4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9tYXRyaXgyc3RyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9tYWtlSXRlbS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGpzY2FkdWkvM21mLWV4cG9ydC9zcmMvdG9EYXRlM21mLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9wdXNoSGVhZGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9wdXNoT2JqZWN0Q29tcG9uZW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AanNjYWR1aS8zbWYtZXhwb3J0L3NyYy9wdXNoT2JqZWN0TWVzaC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGpzY2FkdWkvM21mLWV4cG9ydC9zcmMvc3RhdGljRmlsZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0Bqc2NhZHVpLzNtZi1leHBvcnQvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZmbGF0ZS9lc20vYnJvd3Nlci5qcyIsICIuLi9saWIvZXhwb3J0LTNtZi50cyIsICIuLi9saWIvZXhwb3J0LWdsdGYudHMiLCAiLi4vbGliL3NjZW5lLWJ1aWxkZXIudHMiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF1QmFBLGlCQ2JBQyxXQ0ZBQyxPQ0VBQyxTQStDQUMsUUFxQ0FDLFFDaEVBQyxhQUNBQyxnQkFLU0M7OztJSmJUUix3QkFBQUE7O2FBQ0pTLGFBQWlELENBQUE7O01BRXpEQyxpQkFBaUJDLE1BQWNDLFVBQWY7QUFDZixjQUFNQyxZQUFZLEtBQUtKO0FBRXZCLFlBQUlJLFVBQVVGLElBQUQsTUFBV0csUUFBVztBQUNsQ0Qsb0JBQVVGLElBQUQsSUFBUyxDQUFBO1FBQ2xCO0FBRUQsWUFBSUUsVUFBVUYsSUFBRCxFQUFPSSxRQUFRSCxRQUF4QixNQUFzQyxJQUFJO0FBQzdDQyxvQkFBVUYsSUFBRCxFQUFPSyxLQUFLSixRQUFyQjtRQUNBO0FBRUQsZUFBTztNQUNQO01BRURLLG9CQUFvQk4sTUFBY0MsVUFBZjtBQUNsQixjQUFNQyxZQUFZLEtBQUtKO0FBQ3ZCLGNBQU1TLGdCQUFnQkwsVUFBVUYsSUFBRDtBQUUvQixZQUFJTyxrQkFBa0JKLFFBQVc7QUFDaEMsZ0JBQU1LLFFBQVFELGNBQWNILFFBQVFILFFBQXRCO0FBRWQsY0FBSU8sVUFBVSxJQUFJO0FBQ2pCRCwwQkFBY0UsT0FBT0QsT0FBTyxDQUE1QjtVQUNBO1FBQ0Q7QUFFRCxlQUFPO01BQ1A7TUFFREUsY0FBY0MsT0FBRDtBQUNaLGNBQU1ULFlBQVksS0FBS0o7QUFDdkIsY0FBTVMsZ0JBQWdCTCxVQUFVUyxNQUFNWCxJQUFQO0FBRS9CLFlBQUlPLGtCQUFrQkosUUFBVztBQUVoQyxnQkFBTVMsUUFBUUwsY0FBY00sTUFBTSxDQUFwQjtBQUVkLG1CQUFTQyxJQUFJLEdBQUdDLElBQUlILE1BQU1JLFFBQVFG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LE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUMzRTtBQVVPLFNBQVMsU0FBUyxLQUFLLEdBQUcsR0FBRztBQUNsQyxNQUFJLE1BQU0sRUFBRSxDQUFDLEdBQ1QsTUFBTSxFQUFFLENBQUMsR0FDVCxNQUFNLEVBQUUsQ0FBQyxHQUNULE1BQU0sRUFBRSxDQUFDO0FBQ2IsTUFBSSxNQUFNLEVBQUUsQ0FBQyxHQUNULE1BQU0sRUFBRSxDQUFDLEdBQ1QsTUFBTSxFQUFFLENBQUMsR0FDVCxNQUFNLEVBQUUsQ0FBQztBQUNiLE1BQUksTUFBTSxFQUFFLENBQUMsR0FDVCxNQUFNLEVBQUUsQ0FBQyxHQUNULE1BQU0sRUFBRSxFQUFFLEdBQ1YsTUFBTSxFQUFFLEVBQUU7QUFDZCxNQUFJLE1BQU0sRUFBRSxFQUFFLEdBQ1YsTUFBTSxFQUFFLEVBQUUsR0FDVixNQUFNLEVBQUUsRUFBRSxHQUNWLE1BQU0sRUFBRSxFQUFFO0FBRWQsTUFBSSxLQUFLLEVBQUUsQ0FBQyxHQUNSLEtBQUssRUFBRSxDQUFDLEdBQ1IsS0FBSyxFQUFFLENBQUMsR0FDUixLQUFLLEVBQUUsQ0FBQztBQUNaLE1BQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUs7QUFDL0MsTUFBSSxDQUFDLElBQUksS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSztBQUMvQyxNQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLO0FBQy9DLE1BQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUs7QUFDL0MsT0FBSyxFQUFFLENBQUM7QUFDUixPQUFLLEVBQUUsQ0FBQztBQUNSLE9BQUssRUFBRSxDQUFDO0FBQ1IsT0FBSyxFQUFFLENBQUM7QUFDUixNQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLO0FBQy9DLE1BQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxLQUFLLE1B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QztBQUFDLG1CQUFPO0FBQUEsVUFBTTtBQUFDLG1CQUFTLGFBQWEsVUFBUztBQUFDLGdCQUFHLFNBQVMsQ0FBQyxFQUFFLFNBQU8sR0FBRTtBQUFDLHlCQUFTLENBQUMsUUFBUTtBQUFBLFlBQUM7QUFBQyxtQkFBTyxNQUFNLElBQUlBLFFBQU8sZ0JBQWEsVUFBUyxVQUFNLE1BQU0sSUFBSUEsUUFBTyxlQUFZLE1BQUssT0FBRztBQUFDLGtCQUFHLGFBQWEsTUFBTSxRQUFNLEVBQUMsR0FBRSxFQUFFLENBQUMsR0FBRSxHQUFFLEVBQUUsQ0FBQyxFQUFDO0FBQUUscUJBQU87QUFBQSxZQUFDLENBQUMsQ0FBQztBQUFBLFVBQUM7QUFBQyxtQkFBUyxnQkFBZ0IsYUFBWTtBQUFDLHFCQUFRLElBQUUsR0FBRSxJQUFFLFlBQVksS0FBSyxHQUFFLElBQUksYUFBWSxJQUFJLENBQUMsRUFBRSxPQUFPO0FBQUUsd0JBQVksT0FBTztBQUFBLFVBQUM7QUFBQyxtQkFBUyxZQUFZLEtBQUk7QUFBQyxnQkFBRyxJQUFJLENBQUMsYUFBWSxNQUFNLFFBQU0sRUFBQyxHQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRSxHQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBQztBQUFFLGdCQUFHLE9BQU8sSUFBSSxDQUFDLEtBQUcsU0FBUyxRQUFNLEVBQUMsR0FBRSxJQUFJLENBQUMsS0FBRyxHQUFFLEdBQUUsSUFBSSxDQUFDLEtBQUcsRUFBQztBQUFFLG1CQUFPLElBQUksQ0FBQztBQUFBLFVBQUM7QUFBQyxtQkFBUyxZQUFZLEtBQUk7QUFBQyxnQkFBRyxJQUFJLENBQUMsYUFBWSxNQUFNLFFBQU0sRUFBQyxHQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRSxHQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRSxHQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBQztBQUFFLGdCQUFHLE9BQU8sSUFBSSxDQUFDLEtBQUcsU0FBUyxRQUFNLEVBQUMsR0FBRSxJQUFJLENBQUMsS0FBRyxHQUFFLEdBQUUsSUFBSSxD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QUNGO0FBQ0EsSUFBSSxZQUFZLEVBQUcscUJBQW9COyIsCiAgIm5hbWVzIjogWyJFdmVudERpc3BhdGNoZXIiLCAiR3JhcGhFZGdlIiwgIkdyYXBoIiwgIlJlZkxpc3QiLCAiUmVmU2V0IiwgIlJlZk1hcCIsICIkYXR0cmlidXRlcyIsICIkaW1tdXRhYmxlS2V5cyIsICJHcmFwaE5vZGUiLCAiX2xpc3RlbmVycyIsICJhZGRFdmVudExpc3RlbmVyIiwgInR5cGUiLCAibGlzdGVuZXIiLCAibGlzdGVuZXJzIiwgInVuZGVmaW5lZCIsICJpbmRleE9mIiwgInB1c2giLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJsaXN0ZW5lckFycmF5IiwgImluZGV4IiwgInNwbGljZSIsICJkaXNwYXRjaEV2ZW50IiwgImV2ZW50IiwgImFycmF5IiwgInNsaWNlIiwgImkiLCAibCIsICJsZW5ndGgiLCAiY2FsbCIsICJkaXNwb3NlIiwgImtleSIsICJjb25zdHJ1Y3RvciIsICJfbmFtZSIsICJfcGFyZW50IiwgIl9jaGlsZCIsICJfYXR0cmlidXRlcyIsICJfZGlzcG9zZWQiLCAiaXNPbkdyYXBoIiwgIkVycm9yIiwgImdldE5hbWUiLCAiZ2V0UGFyZW50IiwgImdldENoaWxkIiwgInNldENoaWxkIiwgImNoaWxkIiwgImdldEF0dHJpYnV0ZXMiLCAiX2Rlc3Ryb3lSZWYiLCAiaXNEaXNwb3NlZCIsICJfZW1wdHlTZXQiLCAiU2V0IiwgIl9lZGdlcyIsICJfcGFyZW50RWRnZXMiLCAiTWFwIiwgIl9jaGlsZEVkZ2VzIiwgImxpc3RFZGdlcyIsICJBcnJheSIsICJmcm9tIiwgImxpc3RQYXJlbnRFZGdlcyIsICJub2RlIiwgImdldCIsICJsaXN0UGFyZW50cyIsICJwYXJlbnRTZXQiLCAiZWRnZSIsICJhZGQiLCAibGlzdENoaWxkRWRnZXMiLCAibGlzdENoaWxkcmVuIiwgImNoaWxkU2V0IiwgImRpc2Nvbm5lY3RQYXJlbnRzIiwgImZpbHRlciIsICJfY3JlYXRlRWRnZSIsICJuYW1lIiwgImEiLCAiYiIsICJhdHRyaWJ1dGVzIiwgInBhcmVudCIsICJoYXMiLCAic2V0IiwgIl9kZXN0cm95RWRnZSIsICJkZWxldGUiLCAicmVmcyIsICJsaXN0IiwgInJlZiIsICJyZW1vdmUiLCAicmVtb3ZlQ2hpbGQiLCAibGlzdFJlZnNCeUNoaWxkIiwgInZhbHVlcyIsICJtYXAiLCAiZ2V0UmVmQnlDaGlsZCIsICJPYmplY3QiLCAiYXNzaWduIiwgImtleXMiLCAiU3ltYm9sIiwgImdyYXBoIiwgIl9jcmVhdGVBdHRyaWJ1dGVzIiwgImdldERlZmF1bHRzIiwgImRlZmF1bHRBdHRyaWJ1dGVzIiwgInZhbHVlIiwgIm90aGVyIiwgImZvckVhY2giLCAiZGV0YWNoIiwgInN3YXAiLCAicHJldlZhbHVlIiwgIm5leHRWYWx1ZSIsICJhdHRyaWJ1dGUiLCAic2V0UmVmIiwgInJlZkF0dHJpYnV0ZXMiLCAicmVtb3ZlUmVmIiwgImFkZFJlZiIsICJzZXRSZWZNYXAiLCAiZ2V0UmVmIiwgInByZXZSZWYiLCAibGlzdFJlZnMiLCAiYXNzZXJ0UmVmTGlzdCIsICJsaXN0UmVmTWFwS2V5cyIsICJhc3NlcnRSZWZNYXAiLCAibGlzdFJlZk1hcFZhbHVlcyIsICJnZXRSZWZNYXAiLCAicmVmTWFwIiwgIm1ldGFkYXRhIiwgInRhcmdldCIsICJ2YWxpZGF0ZUpQRUdCdWZmZXIiLCAidmlldyIsICJpIiwgImJ5dGVMZW5ndGgiLCAiVHlwZUVycm9yIiwgImdldFVpbnQ4IiwgImdsTWF0cml4LkFSUkFZX1RZUEUiLCAiZ2V0Qm91bmRzIiwgIm5vZGUiLCAicmVzdWx0Qm91bmRzIiwgImNyZWF0ZUJvdW5kcyIsICJwYXJlbnRzIiwgInByb3BlcnR5VHlwZSIsICJQcm9wZXJ0eVR5cGUiLCAiTk9ERSIsICJsaXN0Q2hpbGRyZW4iLCAicGFyZW50IiwgInRyYXZlcnNlIiwgIm1lc2giLCAiZ2V0TWVzaCIsICJtZXNoQm91bmRzIiwgImdldE1lc2hCb3VuZHMiLCAiZ2V0V29ybGRNYXRyaXgiLCAibWluIiwgImV2ZXJ5IiwgImlzRmluaXRlIiwgIm1heCIsICJleHBhbmRCb3VuZHMiLCAid29ybGRNYXRyaXgiLCAicHJpbSIsICJsaXN0UHJpbWl0aXZlcyIsICJwb3NpdGlvbiIsICJnZXRBdHRyaWJ1dGUiLCAiaW5kaWNlcyIsICJnZXRJbmRpY2VzIiwgImxvY2FsUG9zIiwgIndvcmxkUG9zIiwgImlsIiwgImdldENvdW50IiwgImluZGV4IiwgImdldFNjYWxhciIsICJnZXRFbGVtZW50IiwgInRyYW5zZm9ybU1hdDQiLCAicG9pbnQiLCAidGFyZ2V0IiwgIk1hdGgiLCAiSW5maW5pdHkiLCAiaXNPYmplY3QiLCAibyIsICJPYmplY3QiLCAicHJvdG90eXBlIiwgInRvU3RyaW5nIiwgImNhbGwiLCAiaXNQbGFpbk9iamVjdCIsICJjdG9yIiwgImNvbnN0cnVjdG9yIiwgInVuZGVmaW5lZCIsICJwcm90IiwgImhhc093biIsICJlcXVhbHNSZWYiLCAicmVmQSIsICJyZWZCIiwgImEiLCAiZ2V0Q2hpbGQiLCAiYiIsICJlcXVhbHMiLCAiZXF1YWxzUmVmU2V0IiwgInJlZlNldEEiLCAicmVmU2V0QiIsICJyZWZWYWx1ZXNBIiwgInZhbHVlcyIsICJyZWZWYWx1ZXNCIiwgImxlbmd0aCIsICJlcXVhbHNSZWZNYXAiLCAicmVmTWFwQSIsICJyZWZNYXBCIiwgImtleXNBIiwgImtleXMiLCAia2V5c0IiLCAia2V5IiwgImdldCIsICJlcXVhbHNBcnJheSIsICJlcXVhbHNPYmplY3QiLCAiX2EiLCAiX2IiLCAibnVtS2V5c0EiLCAibnVtS2V5c0IiLCAidmFsdWVBIiwgInZhbHVlQiIsICJpc0FycmF5IiwgInZhbHVlIiwgIkFycmF5IiwgIkFycmF5QnVmZmVyIiwgImlzVmlldyIsICJhcnJheVRvQ29tcG9uZW50VHlwZSIsICJhcnJheSIsICJGbG9hdDMyQXJyYXkiLCAiQWNjZXNzb3IiLCAiQ29tcG9uZW50VHlwZSIsICJGTE9BVCIsICJVaW50MzJBcnJheSIsICJVTlNJR05FRF9JTlQiLCAiVWludDE2QXJyYXkiLCAiVU5TSUdORURfU0hPUlQiLCAiVWludDhBcnJheSIsICJVTlNJR05FRF9CWVRFIiwgIkludDE2QXJyYXkiLCAiU0hPUlQiLCAiSW50OEFycmF5IiwgIkJZVEUiLCAiRXJyb3IiLCAiZ2V0SW50ZXJsZWF2ZWRBcnJheSIsICJhY2Nlc3NvckRlZiIsICJjb250ZXh0IiwgImpzb25Eb2MiLCAiYnVmZmVyVmlldyIsICJidWZmZXJWaWV3cyIsICJidWZmZXJWaWV3RGVmIiwgImpzb24iLCAiVHlwZWRBcnJheSIsICJDb21wb25lbnRUeXBlVG9UeXBlZEFycmF5IiwgImNvbXBvbmVudFR5cGUiLCAiZWxlbWVudFNpemUiLCAiZ2V0RWxlbWVudFNpemUiLCAidHlwZSIsICJjb21wb25lbnRTaXplIiwgIkJZVEVTX1BFUl9FTEVNRU5UIiwgImFjY2Vzc29yQnl0ZU9mZnNldCIsICJieXRlT2Zmc2V0IiwgImNvdW50IiwgIkRhdGFWaWV3IiwgImJ1ZmZlciIsICJieXRlU3RyaWRlIiwgImoiLCAiZ2V0RmxvYXQzMiIsICJnZXRVaW50MzIiLCAiZ2V0VWludDE2IiwgImdldEludDE2IiwgImdldEludDgiLCAiZ2V0QWNjZXNzb3JBcnJheSIsICJlbGVtZW50U3RyaWRlIiwgInNsaWNlIiwgImdldFNwYXJzZUFycmF5IiwgInNwYXJzZURlZiIsICJzcGFyc2UiLCAiaW5kaWNlc0RlZiIsICJfZXh0ZW5kcyIsICJ2YWx1ZXNEZWYiLCAiZ2V0U2xvdCIsICJkb2N1bWVudCIsICJ0ZXh0dXJlIiwgImVkZ2UiLCAiZ2V0R3JhcGgiLCAibGlzdFBhcmVudEVkZ2VzIiwgImZpbmQiLCAiZ2V0UGFyZW50IiwgImdldFJvb3QiLCAiZ2V0TmFtZSIsICJyZXBsYWNlIiwgImNsZWFuIiwgIm9iamVjdCIsICJ1bnVzZWQiLCAicHVzaCIsICJpc0V4dGVybmFsQnVmZmVyIiwgImpzb25Eb2N1bWVudCIsICJidWZmZXJEZWYiLCAidXJpIiwgInJlc291cmNlcyIsICJpc0V4dGVybmFsSW1hZ2UiLCAiaW1hZ2VEZWYiLCAiaXNHTEIiLCAiaGVhZGVyIiwgIlZFUlNJT04iLCAiR0xCX0JVRkZFUiIsICJWZXJ0ZXhMYXlvdXQiLCAiQnVmZmVyVmlld1VzYWdlIiwgIlRleHR1cmVDaGFubmVsIiwgIkZvcm1hdCIsICJCdWZmZXJVdGlscyIsICJKUEVHSW1hZ2VVdGlscyIsICJQTkdJbWFnZVV0aWxzIiwgIkltYWdlVXRpbHMiLCAiRmlsZVV0aWxzIiwgIk5VTExfRE9NQUlOIiwgIkhUVFBVdGlscyIsICJWZXJib3NpdHkiLCAiTG9nZ2VyIiwgIk1hdGhVdGlscyIsICJBTFBIQUJFVCIsICJVTklRVUVfUkVUUklFUyIsICJJRF9MRU5HVEgiLCAicHJldmlvdXNJRHMiLCAiZ2VuZXJhdGVPbmUiLCAidXVpZCIsICJDT1BZX0lERU5USVRZIiwgIkVNUFRZX1NFVCIsICJQcm9wZXJ0eSIsICJFeHRlbnNpYmxlUHJvcGVydHkiLCAiQW5pbWF0aW9uIiwgIkFuaW1hdGlvbkNoYW5uZWwiLCAiQW5pbWF0aW9uU2FtcGxlciIsICJCdWZmZXIiLCAiQ2FtZXJhIiwgIkV4dGVuc2lvblByb3BlcnR5IiwgIlRleHR1cmVJbmZvIiwgIlIiLCAiRyIsICJCIiwgIkEiLCAiTWF0ZXJpYWwiLCAiTWVzaCIsICJOb2RlIiwgIlByaW1pdGl2ZSIsICJQcmltaXRpdmVUYXJnZXQiLCAiU2NlbmUiLCAiU2tpbiIsICJUZXh0dXJlIiwgIlJvb3QiLCAiRG9jdW1lbnQiLCAiRXh0ZW5zaW9uIiwgIlJlYWRlckNvbnRleHQiLCAiREVGQVVMVF9PUFRJT05TIiwgIlNVUFBPUlRFRF9QUkVSRUFEX1RZUEVTIiwgIkdMVEZSZWFkZXIiLCAiQnVmZmVyVmlld1RhcmdldCIsICJXcml0ZXJDb250ZXh0IiwgIlVuaXF1ZVVSSUdlbmVyYXRvciIsICJTVVBQT1JURURfUFJFV1JJVEVfVFlQRVMiLCAiR0xURldyaXRlciIsICJDaHVua1R5cGUiLCAiUGxhdGZvcm1JTyIsICJXZWJJTyIsICJjcmVhdGVCdWZmZXJGcm9tRGF0YVVSSSIsICJkYXRhVVJJIiwgImJ5dGVTdHJpbmciLCAiYXRvYiIsICJzcGxpdCIsICJpYSIsICJjaGFyQ29kZUF0IiwgImRhdGEiLCAiaXNCYXNlNjQiLCAiaW5kZXhPZiIsICJmcm9tIiwgImVuY29kZVRleHQiLCAidGV4dCIsICJUZXh0RW5jb2RlciIsICJlbmNvZGUiLCAiZGVjb2RlVGV4dCIsICJUZXh0RGVjb2RlciIsICJkZWNvZGUiLCAiY29uY2F0IiwgImFycmF5cyIsICJ0b3RhbEJ5dGVMZW5ndGgiLCAicmVzdWx0IiwgInNldCIsICJwYWQiLCAic3JjQXJyYXkiLCAicGFkZGluZ0J5dGUiLCAicGFkZGVkTGVuZ3RoIiwgInBhZE51bWJlciIsICJkc3RBcnJheSIsICJ2IiwgImNlaWwiLCAidG9WaWV3IiwgImFzc2VydFZpZXciLCAibWF0Y2giLCAiZ2V0U2l6ZSIsICJuZXh0IiwgImdldENoYW5uZWxzIiwgIl9idWZmZXIiLCAibWFnaWMiLCAiUE5HX0ZSSUVEX0NIVU5LX05BTUUiLCAicmVnaXN0ZXJGb3JtYXQiLCAibWltZVR5cGUiLCAiaW1wbCIsICJpbXBscyIsICJnZXRNaW1lVHlwZSIsICJnZXRWUkFNQnl0ZUxlbmd0aCIsICJ1bmNvbXByZXNzZWRCeXRlcyIsICJjaGFubmVscyIsICJyZXNvbHV0aW9uIiwgImZsb29yIiwgIm1pbWVUeXBlVG9FeHRlbnNpb24iLCAicG9wIiwgImV4dGVuc2lvblRvTWltZVR5cGUiLCAiZXh0ZW5zaW9uIiwgImJhc2VuYW1lIiwgImZpbGVOYW1lIiwgInN1YnN0cmluZyIsICJsYXN0SW5kZXhPZiIsICJzdGFydHNXaXRoIiwgImRpcm5hbWUiLCAicGF0aCIsICJVUkwiLCAicGF0aG5hbWUiLCAicmVzb2x2ZSIsICJiYXNlIiwgImlzUmVsYXRpdmVQYXRoIiwgInN0YWNrIiwgInBhcnRzIiwgImpvaW4iLCAiaXNBYnNvbHV0ZVVSTCIsICJQUk9UT0NPTF9SRUdFWFAiLCAidGVzdCIsICJERUZBVUxUX0lOSVQiLCAidmVyYm9zaXR5IiwgImRlYnVnIiwgIkRFQlVHIiwgImNvbnNvbGUiLCAiaW5mbyIsICJJTkZPIiwgIndhcm4iLCAiV0FSTiIsICJlcnJvciIsICJFUlJPUiIsICJERUZBVUxUX0lOU1RBTkNFIiwgImlkZW50aXR5IiwgImVxIiwgInRvbGVyYW5jZSIsICJhYnMiLCAiY2xhbXAiLCAiZGVjb2RlTm9ybWFsaXplZEludCIsICJlbmNvZGVOb3JtYWxpemVkSW50IiwgImYiLCAicm91bmQiLCAiZGVjb21wb3NlIiwgInNyY01hdCIsICJkc3RUcmFuc2xhdGlvbiIsICJkc3RSb3RhdGlvbiIsICJkc3RTY2FsZSIsICJzeCIsICJzeSIsICJzeiIsICJkZXQiLCAiZGV0ZXJtaW5hbnQiLCAiX20xIiwgImludlNYIiwgImludlNZIiwgImludlNaIiwgImdldFJvdGF0aW9uIiwgImNvbXBvc2UiLCAic3JjVHJhbnNsYXRpb24iLCAic3JjUm90YXRpb24iLCAic3JjU2NhbGUiLCAiZHN0TWF0IiwgInRlIiwgIngiLCAieSIsICJ6IiwgInciLCAieDIiLCAieTIiLCAiejIiLCAieHgiLCAieHkiLCAieHoiLCAieXkiLCAieXoiLCAienoiLCAid3giLCAid3kiLCAid3oiLCAiU2V0IiwgInJ0biIsICJjaGFyQXQiLCAicmFuZG9tIiwgInJldHJpZXMiLCAiaWQiLCAiaGFzIiwgImFkZCIsICJ0IiwgIkdyYXBoTm9kZSIsICJncmFwaCIsICJuYW1lIiwgIiRhdHRyaWJ1dGVzIiwgImluaXQiLCAiZGlzcGF0Y2hFdmVudCIsICJnZXREZWZhdWx0cyIsICJhc3NpZ24iLCAiZXh0cmFzIiwgImF0dHJpYnV0ZSIsICJzZXROYW1lIiwgImdldEV4dHJhcyIsICJzZXRFeHRyYXMiLCAiY2xvbmUiLCAiUHJvcGVydHlDbGFzcyIsICJjb3B5IiwgIm90aGVyIiwgIkdyYXBoRWRnZSIsICIkaW1tdXRhYmxlS2V5cyIsICJkaXNwb3NlIiwgIlJlZkxpc3QiLCAiUmVmU2V0IiwgInJlZiIsICJSZWZNYXAiLCAidGhpc1ZhbHVlIiwgIm90aGVyVmFsdWUiLCAic2V0UmVmIiwgImdldEF0dHJpYnV0ZXMiLCAiYWRkUmVmIiwgInN1YmtleSIsICJzZXRSZWZNYXAiLCAiSlNPTiIsICJwYXJzZSIsICJzdHJpbmdpZnkiLCAic2tpcCIsICJkZXRhY2giLCAiZGlzY29ubmVjdFBhcmVudHMiLCAibiIsICJsaXN0UGFyZW50cyIsICJleHRlbnNpb25zIiwgImdldEV4dGVuc2lvbiIsICJnZXRSZWZNYXAiLCAic2V0RXh0ZW5zaW9uIiwgImV4dGVuc2lvblByb3BlcnR5IiwgIl92YWxpZGF0ZVBhcmVudCIsICJsaXN0RXh0ZW5zaW9ucyIsICJsaXN0UmVmTWFwVmFsdWVzIiwgIkFDQ0VTU09SIiwgIlR5cGUiLCAiU0NBTEFSIiwgIm5vcm1hbGl6ZWQiLCAiVkVDMiIsICJWRUMzIiwgIlZFQzQiLCAiTUFUMiIsICJNQVQzIiwgIk1BVDQiLCAiZ2V0Q29tcG9uZW50U2l6ZSIsICJnZXRNaW5Ob3JtYWxpemVkIiwgImdldE5vcm1hbGl6ZWQiLCAiZ2V0Q29tcG9uZW50VHlwZSIsICJnZXRNaW4iLCAiZ2V0QXJyYXkiLCAiTnVtYmVyIiwgImdldE1heE5vcm1hbGl6ZWQiLCAiZ2V0TWF4IiwgImdldFR5cGUiLCAic2V0VHlwZSIsICJzZXROb3JtYWxpemVkIiwgInNldFNjYWxhciIsICJzZXRFbGVtZW50IiwgImdldFNwYXJzZSIsICJzZXRTcGFyc2UiLCAiZ2V0QnVmZmVyIiwgImdldFJlZiIsICJzZXRCdWZmZXIiLCAic2V0QXJyYXkiLCAiZ2V0Qnl0ZUxlbmd0aCIsICJBTklNQVRJT04iLCAic2FtcGxlcnMiLCAiYWRkQ2hhbm5lbCIsICJjaGFubmVsIiwgInJlbW92ZUNoYW5uZWwiLCAicmVtb3ZlUmVmIiwgImxpc3RDaGFubmVscyIsICJsaXN0UmVmcyIsICJhZGRTYW1wbGVyIiwgInNhbXBsZXIiLCAicmVtb3ZlU2FtcGxlciIsICJsaXN0U2FtcGxlcnMiLCAiQU5JTUFUSU9OX0NIQU5ORUwiLCAidGFyZ2V0UGF0aCIsICJ0YXJnZXROb2RlIiwgImdldFRhcmdldFBhdGgiLCAic2V0VGFyZ2V0UGF0aCIsICJnZXRUYXJnZXROb2RlIiwgInNldFRhcmdldE5vZGUiLCAiZ2V0U2FtcGxlciIsICJzZXRTYW1wbGVyIiwgIlRhcmdldFBhdGgiLCAiVFJBTlNMQVRJT04iLCAiUk9UQVRJT04iLCAiU0NBTEUiLCAiV0VJR0hUUyIsICJBTklNQVRJT05fU0FNUExFUiIsICJnZXREZWZhdWx0QXR0cmlidXRlcyIsICJpbnRlcnBvbGF0aW9uIiwgIkludGVycG9sYXRpb24iLCAiTElORUFSIiwgImlucHV0IiwgIm91dHB1dCIsICJnZXRJbnRlcnBvbGF0aW9uIiwgInNldEludGVycG9sYXRpb24iLCAiZ2V0SW5wdXQiLCAic2V0SW5wdXQiLCAidXNhZ2UiLCAiT1RIRVIiLCAiZ2V0T3V0cHV0IiwgInNldE91dHB1dCIsICJTVEVQIiwgIkNVQklDU1BMSU5FIiwgIkJVRkZFUiIsICJnZXRVUkkiLCAic2V0VVJJIiwgIkNBTUVSQSIsICJQRVJTUEVDVElWRSIsICJ6bmVhciIsICJ6ZmFyIiwgImFzcGVjdFJhdGlvIiwgInlmb3YiLCAiUEkiLCAieG1hZyIsICJ5bWFnIiwgImdldFpOZWFyIiwgInNldFpOZWFyIiwgImdldFpGYXIiLCAic2V0WkZhciIsICJnZXRBc3BlY3RSYXRpbyIsICJzZXRBc3BlY3RSYXRpbyIsICJnZXRZRm92IiwgInNldFlGb3YiLCAiZ2V0WE1hZyIsICJzZXRYTWFnIiwgImdldFlNYWciLCAic2V0WU1hZyIsICJPUlRIT0dSQVBISUMiLCAicGFyZW50VHlwZXMiLCAiaW5jbHVkZXMiLCAiRVhURU5TSU9OX05BTUUiLCAiVEVYVFVSRV9JTkZPIiwgInRleENvb3JkIiwgIm1hZ0ZpbHRlciIsICJtaW5GaWx0ZXIiLCAid3JhcFMiLCAiV3JhcE1vZGUiLCAiUkVQRUFUIiwgIndyYXBUIiwgImdldFRleENvb3JkIiwgInNldFRleENvb3JkIiwgImdldE1hZ0ZpbHRlciIsICJzZXRNYWdGaWx0ZXIiLCAiZ2V0TWluRmlsdGVyIiwgInNldE1pbkZpbHRlciIsICJnZXRXcmFwUyIsICJzZXRXcmFwUyIsICJnZXRXcmFwVCIsICJzZXRXcmFwVCIsICJDTEFNUF9UT19FREdFIiwgIk1JUlJPUkVEX1JFUEVBVCIsICJNYWdGaWx0ZXIiLCAiTkVBUkVTVCIsICJNaW5GaWx0ZXIiLCAiTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCIsICJMSU5FQVJfTUlQTUFQX05FQVJFU1QiLCAiTkVBUkVTVF9NSVBNQVBfTElORUFSIiwgIkxJTkVBUl9NSVBNQVBfTElORUFSIiwgIk1BVEVSSUFMIiwgImFscGhhTW9kZSIsICJBbHBoYU1vZGUiLCAiT1BBUVVFIiwgImFscGhhQ3V0b2ZmIiwgImRvdWJsZVNpZGVkIiwgImJhc2VDb2xvckZhY3RvciIsICJiYXNlQ29sb3JUZXh0dXJlIiwgImJhc2VDb2xvclRleHR1cmVJbmZvIiwgImVtaXNzaXZlRmFjdG9yIiwgImVtaXNzaXZlVGV4dHVyZSIsICJlbWlzc2l2ZVRleHR1cmVJbmZvIiwgIm5vcm1hbFNjYWxlIiwgIm5vcm1hbFRleHR1cmUiLCAibm9ybWFsVGV4dHVyZUluZm8iLCAib2NjbHVzaW9uU3RyZW5ndGgiLCAib2NjbHVzaW9uVGV4dHVyZSIsICJvY2NsdXNpb25UZXh0dXJlSW5mbyIsICJyb3VnaG5lc3NGYWN0b3IiLCAibWV0YWxsaWNGYWN0b3IiLCAibWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlIiwgIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZUluZm8iLCAiZ2V0RG91YmxlU2lkZWQiLCAic2V0RG91YmxlU2lkZWQiLCAiZ2V0QWxwaGEiLCAic2V0QWxwaGEiLCAiYWxwaGEiLCAiZ2V0QWxwaGFNb2RlIiwgInNldEFscGhhTW9kZSIsICJnZXRBbHBoYUN1dG9mZiIsICJzZXRBbHBoYUN1dG9mZiIsICJnZXRCYXNlQ29sb3JGYWN0b3IiLCAic2V0QmFzZUNvbG9yRmFjdG9yIiwgImdldEJhc2VDb2xvclRleHR1cmUiLCAiZ2V0QmFzZUNvbG9yVGV4dHVyZUluZm8iLCAic2V0QmFzZUNvbG9yVGV4dHVyZSIsICJpc0NvbG9yIiwgImdldEVtaXNzaXZlRmFjdG9yIiwgInNldEVtaXNzaXZlRmFjdG9yIiwgImdldEVtaXNzaXZlVGV4dHVyZSIsICJnZXRFbWlzc2l2ZVRleHR1cmVJbmZvIiwgInNldEVtaXNzaXZlVGV4dHVyZSIsICJnZXROb3JtYWxTY2FsZSIsICJzZXROb3JtYWxTY2FsZSIsICJzY2FsZSIsICJnZXROb3JtYWxUZXh0dXJlIiwgImdldE5vcm1hbFRleHR1cmVJbmZvIiwgInNldE5vcm1hbFRleHR1cmUiLCAiZ2V0T2NjbHVzaW9uU3RyZW5ndGgiLCAic2V0T2NjbHVzaW9uU3RyZW5ndGgiLCAic3RyZW5ndGgiLCAiZ2V0T2NjbHVzaW9uVGV4dHVyZSIsICJnZXRPY2NsdXNpb25UZXh0dXJlSW5mbyIsICJzZXRPY2NsdXNpb25UZXh0dXJlIiwgImdldFJvdWdobmVzc0ZhY3RvciIsICJzZXRSb3VnaG5lc3NGYWN0b3IiLCAiZmFjdG9yIiwgImdldE1ldGFsbGljRmFjdG9yIiwgInNldE1ldGFsbGljRmFjdG9yIiwgImdldE1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsICJnZXRNZXRhbGxpY1JvdWdobmVzc1RleHR1cmVJbmZvIiwgInNldE1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsICJNQVNLIiwgIkJMRU5EIiwgIk1FU0giLCAid2VpZ2h0cyIsICJwcmltaXRpdmVzIiwgImFkZFByaW1pdGl2ZSIsICJwcmltaXRpdmUiLCAicmVtb3ZlUHJpbWl0aXZlIiwgImdldFdlaWdodHMiLCAic2V0V2VpZ2h0cyIsICJ0cmFuc2xhdGlvbiIsICJyb3RhdGlvbiIsICJjYW1lcmEiLCAic2tpbiIsICJjaGlsZHJlbiIsICJnZXRUcmFuc2xhdGlvbiIsICJnZXRTY2FsZSIsICJzZXRUcmFuc2xhdGlvbiIsICJzZXRSb3RhdGlvbiIsICJzZXRTY2FsZSIsICJnZXRNYXRyaXgiLCAic2V0TWF0cml4IiwgIm1hdHJpeCIsICJnZXRXb3JsZFRyYW5zbGF0aW9uIiwgImdldFdvcmxkUm90YXRpb24iLCAiciIsICJnZXRXb3JsZFNjYWxlIiwgInMiLCAiYW5jZXN0b3JzIiwgImdldFBhcmVudE5vZGUiLCAiYW5jZXN0b3IiLCAibXVsdGlwbHkiLCAiYWRkQ2hpbGQiLCAiY2hpbGQiLCAicGFyZW50Tm9kZSIsICJyZW1vdmVDaGlsZCIsICJTQ0VORSIsICJzZXRNZXNoIiwgImdldENhbWVyYSIsICJzZXRDYW1lcmEiLCAiZ2V0U2tpbiIsICJzZXRTa2luIiwgImZuIiwgIlBSSU1JVElWRSIsICJtb2RlIiwgIk1vZGUiLCAiVFJJQU5HTEVTIiwgIm1hdGVyaWFsIiwgImF0dHJpYnV0ZXMiLCAidGFyZ2V0cyIsICJzZXRJbmRpY2VzIiwgIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwgInNlbWFudGljIiwgInNldEF0dHJpYnV0ZSIsICJhY2Nlc3NvciIsICJBUlJBWV9CVUZGRVIiLCAibGlzdEF0dHJpYnV0ZXMiLCAibGlzdFNlbWFudGljcyIsICJsaXN0UmVmTWFwS2V5cyIsICJnZXRNYXRlcmlhbCIsICJzZXRNYXRlcmlhbCIsICJnZXRNb2RlIiwgInNldE1vZGUiLCAibGlzdFRhcmdldHMiLCAiYWRkVGFyZ2V0IiwgInJlbW92ZVRhcmdldCIsICJQT0lOVFMiLCAiTElORVMiLCAiTElORV9MT09QIiwgIkxJTkVfU1RSSVAiLCAiVFJJQU5HTEVfU1RSSVAiLCAiVFJJQU5HTEVfRkFOIiwgIlBSSU1JVElWRV9UQVJHRVQiLCAiU0tJTiIsICJza2VsZXRvbiIsICJpbnZlcnNlQmluZE1hdHJpY2VzIiwgImpvaW50cyIsICJnZXRTa2VsZXRvbiIsICJzZXRTa2VsZXRvbiIsICJnZXRJbnZlcnNlQmluZE1hdHJpY2VzIiwgInNldEludmVyc2VCaW5kTWF0cmljZXMiLCAiSU5WRVJTRV9CSU5EX01BVFJJQ0VTIiwgImFkZEpvaW50IiwgImpvaW50IiwgInJlbW92ZUpvaW50IiwgImxpc3RKb2ludHMiLCAiVEVYVFVSRSIsICJpbWFnZSIsICJzZXRNaW1lVHlwZSIsICJnZXRJbWFnZSIsICJzZXRJbWFnZSIsICJST09UIiwgImFzc2V0IiwgImdlbmVyYXRvciIsICJ2ZXJzaW9uIiwgImRlZmF1bHRTY2VuZSIsICJhY2Nlc3NvcnMiLCAiYW5pbWF0aW9ucyIsICJidWZmZXJzIiwgImNhbWVyYXMiLCAibWF0ZXJpYWxzIiwgIm1lc2hlcyIsICJub2RlcyIsICJzY2VuZXMiLCAic2tpbnMiLCAidGV4dHVyZXMiLCAiX2V4dGVuc2lvbnMiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJldmVudCIsICJfYWRkQ2hpbGRPZlJvb3QiLCAic2V0RGVmYXVsdFNjZW5lIiwgImdldERlZmF1bHRTY2VuZSIsICJleHRlbnNpb25OYW1lIiwgIm90aGVyRXh0ZW5zaW9uIiwgImdldEFzc2V0IiwgImxpc3RFeHRlbnNpb25zVXNlZCIsICJsaXN0RXh0ZW5zaW9uc1JlcXVpcmVkIiwgImZpbHRlciIsICJpc1JlcXVpcmVkIiwgIl9lbmFibGVFeHRlbnNpb24iLCAiX2Rpc2FibGVFeHRlbnNpb24iLCAiZGVsZXRlIiwgImxpc3RTY2VuZXMiLCAibGlzdE5vZGVzIiwgImxpc3RDYW1lcmFzIiwgImxpc3RTa2lucyIsICJsaXN0TWVzaGVzIiwgImxpc3RNYXRlcmlhbHMiLCAibGlzdFRleHR1cmVzIiwgImxpc3RBbmltYXRpb25zIiwgImxpc3RBY2Nlc3NvcnMiLCAibGlzdEJ1ZmZlcnMiLCAiZnJvbUdyYXBoIiwgIl9HUkFQSF9ET0NVTUVOVFMiLCAiX2dyYXBoIiwgIkdyYXBoIiwgIl9yb290IiwgIl9sb2dnZXIiLCAiZ2V0TG9nZ2VyIiwgInNldExvZ2dlciIsICJsb2dnZXIiLCAibWVyZ2UiLCAiX290aGVyIiwgInRyYW5zZm9ybSIsICJ0cmFuc2Zvcm1zIiwgIm1hcCIsICJjcmVhdGVFeHRlbnNpb24iLCAicHJldkV4dGVuc2lvbiIsICJleHQiLCAiY3JlYXRlU2NlbmUiLCAiY3JlYXRlTm9kZSIsICJjcmVhdGVDYW1lcmEiLCAiY3JlYXRlU2tpbiIsICJjcmVhdGVNZXNoIiwgImNyZWF0ZVByaW1pdGl2ZSIsICJjcmVhdGVQcmltaXRpdmVUYXJnZXQiLCAiY3JlYXRlTWF0ZXJpYWwiLCAiY3JlYXRlVGV4dHVyZSIsICJjcmVhdGVBbmltYXRpb24iLCAiY3JlYXRlQW5pbWF0aW9uQ2hhbm5lbCIsICJjcmVhdGVBbmltYXRpb25TYW1wbGVyIiwgImNyZWF0ZUFjY2Vzc29yIiwgImNyZWF0ZUJ1ZmZlciIsICJXZWFrTWFwIiwgInByZXJlYWRUeXBlcyIsICJwcmV3cml0ZVR5cGVzIiwgInJlYWREZXBlbmRlbmNpZXMiLCAid3JpdGVEZXBlbmRlbmNpZXMiLCAicmVxdWlyZWQiLCAicHJvcGVydGllcyIsICJfbGlzdGVuZXIiLCAiX2V2ZW50IiwgIl9hZGRFeHRlbnNpb25Qcm9wZXJ0eSIsICJfcmVtb3ZlRXh0ZW5zaW9uUHJvcGVydHkiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJwcm9wZXJ0eSIsICJyZWdpc3RlciIsICJzZXRSZXF1aXJlZCIsICJsaXN0UHJvcGVydGllcyIsICJpbnN0YWxsIiwgIl9rZXkiLCAiX2RlcGVuZGVuY3kiLCAicHJlcmVhZCIsICJfcmVhZGVyQ29udGV4dCIsICJfcHJvcGVydHlUeXBlIiwgInByZXdyaXRlIiwgIl93cml0ZXJDb250ZXh0IiwgImJ1ZmZlclZpZXdCdWZmZXJzIiwgInRleHR1cmVJbmZvcyIsICJNYXAiLCAic2V0VGV4dHVyZUluZm8iLCAidGV4dHVyZUluZm8iLCAidGV4dHVyZUluZm9EZWYiLCAidGV4dHVyZURlZiIsICJzYW1wbGVyRGVmIiwgImRlcGVuZGVuY2llcyIsICJyZWFkIiwgIl9vcHRpb25zIiwgIm9wdGlvbnMiLCAidmFsaWRhdGUiLCAiYXNzZXREZWYiLCAiY29weXJpZ2h0IiwgImV4dGVuc2lvbnNVc2VkIiwgImV4dGVuc2lvbnNSZXF1aXJlZCIsICJzb3J0IiwgInVuc3VwcG9ydGVkSG9va3MiLCAiYnVmZmVyRGVmcyIsICJmb3JFYWNoIiwgImJ1ZmZlclZpZXdEZWZzIiwgInJlc291cmNlIiwgImFjY2Vzc29yRGVmcyIsICJpbWFnZURlZnMiLCAiaW1hZ2VzIiwgInRleHR1cmVEZWZzIiwgImJ1ZmZlckRhdGEiLCAiaW1hZ2VEYXRhIiwgIm1hdGVyaWFsRGVmcyIsICJtYXRlcmlhbERlZiIsICJwYnJEZWYiLCAicGJyTWV0YWxsaWNSb3VnaG5lc3MiLCAic291cmNlIiwgIm1lc2hEZWZzIiwgIm1lc2hEZWYiLCAicHJpbWl0aXZlRGVmcyIsICJwcmltaXRpdmVEZWYiLCAiZW50cmllcyIsICJ0YXJnZXROYW1lcyIsICJ0YXJnZXREZWZzIiwgInRhcmdldERlZiIsICJ0YXJnZXRJbmRleCIsICJ0YXJnZXROYW1lIiwgImFjY2Vzc29ySW5kZXgiLCAiY2FtZXJhRGVmcyIsICJjYW1lcmFEZWYiLCAicGVyc3BlY3RpdmVEZWYiLCAicGVyc3BlY3RpdmUiLCAib3J0aG9EZWYiLCAib3J0aG9ncmFwaGljIiwgIm5vZGVEZWZzIiwgIm5vZGVEZWYiLCAic2tpbkRlZnMiLCAic2tpbkRlZiIsICJub2RlSW5kZXgiLCAiY2hpbGRJbmRleCIsICJhbmltYXRpb25EZWZzIiwgImFuaW1hdGlvbkRlZiIsICJhbmltYXRpb24iLCAic2FtcGxlckRlZnMiLCAiY2hhbm5lbERlZiIsICJzY2VuZURlZnMiLCAic2NlbmVEZWYiLCAic2NlbmUiLCAiaGFzU3BhcnNlVmFsdWVzIiwgImlzWmVyb0ZpbGxlZCIsICJfZG9jIiwgImFjY2Vzc29ySW5kZXhNYXAiLCAiYW5pbWF0aW9uSW5kZXhNYXAiLCAiYnVmZmVySW5kZXhNYXAiLCAiY2FtZXJhSW5kZXhNYXAiLCAic2tpbkluZGV4TWFwIiwgIm1hdGVyaWFsSW5kZXhNYXAiLCAibWVzaEluZGV4TWFwIiwgIm5vZGVJbmRleE1hcCIsICJpbWFnZUluZGV4TWFwIiwgInRleHR1cmVEZWZJbmRleE1hcCIsICJ0ZXh0dXJlSW5mb0RlZk1hcCIsICJzYW1wbGVyRGVmSW5kZXhNYXAiLCAic2NlbmVJbmRleE1hcCIsICJpbWFnZUJ1ZmZlclZpZXdzIiwgIm90aGVyQnVmZmVyVmlld3MiLCAib3RoZXJCdWZmZXJWaWV3c0luZGV4TWFwIiwgImV4dGVuc2lvbkRhdGEiLCAiYnVmZmVyVVJJR2VuZXJhdG9yIiwgImltYWdlVVJJR2VuZXJhdG9yIiwgIl9hY2Nlc3NvclVzYWdlTWFwIiwgImFjY2Vzc29yVXNhZ2VHcm91cGVkQnlQYXJlbnQiLCAiYWNjZXNzb3JQYXJlbnRzIiwgInJvb3QiLCAibnVtQnVmZmVycyIsICJudW1JbWFnZXMiLCAiY3JlYXRlVGV4dHVyZUluZm9EZWYiLCAic2FtcGxlcktleSIsICJ0ZXh0dXJlS2V5IiwgImNyZWF0ZVByb3BlcnR5RGVmIiwgImRlZiIsICJjcmVhdGVBY2Nlc3NvckRlZiIsICJuZWVkc0JvdW5kcyIsICJzb21lIiwgImZyb3VuZCIsICJjcmVhdGVJbWFnZURhdGEiLCAiZm9ybWF0IiwgIkdMQiIsICJjcmVhdGVVUkkiLCAiYXNzaWduUmVzb3VyY2VVUkkiLCAidGhyb3dPbkNvbmZsaWN0IiwgImNvbmZsaWN0TWVzc2FnZSIsICJnZXRBY2Nlc3NvclVzYWdlIiwgImNhY2hlZFVzYWdlIiwgIlNQQVJTRSIsICJhZGRBY2Nlc3NvclRvVXNhZ2VHcm91cCIsICJwcmV2VXNhZ2UiLCAiVVNBR0VfVE9fVEFSR0VUIiwgIm11bHRpcGxlIiwgImNvdW50ZXIiLCAid3JpdGUiLCAiZG9jIiwgImV4dGVuc2lvbnNSZWdpc3RlcmVkIiwgImNvbmNhdEFjY2Vzc29ycyIsICJidWZmZXJJbmRleCIsICJidWZmZXJCeXRlT2Zmc2V0IiwgImJ1ZmZlclZpZXdUYXJnZXQiLCAiYWNjZXNzb3JBcnJheSIsICJidWZmZXJWaWV3RGF0YSIsICJpbnRlcmxlYXZlQWNjZXNzb3JzIiwgInZlcnRleENvdW50IiwgInZlcnRleEJ5dGVPZmZzZXQiLCAidmlld0J5dGVPZmZzZXQiLCAic2V0RmxvYXQzMiIsICJzZXRJbnQ4IiwgInNldEludDE2IiwgInNldFVpbnQ4IiwgInNldFVpbnQxNiIsICJzZXRVaW50MzIiLCAiY29uY2F0U3BhcnNlQWNjZXNzb3JzIiwgInNwYXJzZURhdGEiLCAibWF4SW5kZXgiLCAibmVlZFNwYXJzZVdhcm5pbmciLCAiZWwiLCAiZmlsbCIsICJWYWx1ZUFycmF5IiwgIkluZGV4QXJyYXkiLCAiSW5kZXhDb21wb25lbnRUeXBlIiwgImluZGljZXNCdWZmZXJWaWV3RGVmIiwgImluZGljZXNCeXRlT2Zmc2V0IiwgImluZGljZXNCdWZmZXJWaWV3SW5kZXgiLCAidmFsdWVzQnVmZmVyVmlld0RlZiIsICJ2YWx1ZXNCeXRlT2Zmc2V0IiwgInZhbHVlc0J1ZmZlclZpZXdJbmRleCIsICJ0ZXh0dXJlSW5kZXgiLCAiZ3JvdXBCeVBhcmVudCIsICJuZWVkc0J1ZmZlciIsICJzaXplIiwgInVuaXF1ZVBhcmVudHMiLCAicGFyZW50VG9JbmRleCIsICJhY2Nlc3Nvckdyb3VwcyIsICJidWZmZXJCeXRlTGVuZ3RoIiwgImdyb3VwQWNjZXNzb3JzIiwgInZlcnRleExheW91dCIsICJJTlRFUkxFQVZFRCIsICJpbWFnZVBhZGRpbmciLCAic2FtcGxlckluZGV4TWFwIiwgInNhbXBsZXJJbmRleCIsICJfZGVwZW5kZW5jaWVzIiwgIl92ZXJ0ZXhMYXlvdXQiLCAibGFzdFJlYWRCeXRlcyIsICJsYXN0V3JpdGVCeXRlcyIsICJyZWdpc3RlckV4dGVuc2lvbnMiLCAicmVnaXN0ZXJEZXBlbmRlbmNpZXMiLCAic2V0VmVydGV4TGF5b3V0IiwgImxheW91dCIsICJyZWFkSlNPTiIsICJyZWFkQXNKU09OIiwgInJlYWRVUkkiLCAiX2JpbmFyeVRvSlNPTiIsICJfcmVhZFJlc291cmNlc0V4dGVybmFsIiwgIl9yZWFkUmVzb3VyY2VzSW50ZXJuYWwiLCAiX2NvcHlKU09OIiwgImJpbmFyeVRvSlNPTiIsICJnbGIiLCAicmVhZEJpbmFyeSIsICJ3cml0ZUpTT04iLCAiR0xURiIsICJ3cml0ZUJpbmFyeSIsICJqc29uVGV4dCIsICJqc29uQ2h1bmtEYXRhIiwgImpzb25DaHVua0hlYWRlciIsICJqc29uQ2h1bmsiLCAiYmluQnVmZmVyIiwgImJpbkNodW5rRGF0YSIsICJiaW5DaHVua0hlYWRlciIsICJiaW5DaHVuayIsICJfdGhpcyIsICJwZW5kaW5nUmVzb3VyY2VzIiwgIlByb21pc2UiLCAiYWxsIiwgInJlc29sdmVSZXNvdXJjZSIsICJyZXNvdXJjZVVVSUQiLCAianNvbkJ5dGVPZmZzZXQiLCAianNvbkJ5dGVMZW5ndGgiLCAiYmluQnl0ZU9mZnNldCIsICJCSU4iLCAiYmluQnl0ZUxlbmd0aCIsICJmZXRjaENvbmZpZyIsICJfZmV0Y2hDb25maWciLCAicmVzcG9uc2UiLCAiZmV0Y2giLCAiYXJyYXlCdWZmZXIiLCAiaSIsICJtb2R1bGUiLCAiX19kZWZQcm9wIiwgIl9fZ2V0T3duUHJvcERlc2MiLCAiX19nZXRPd25Qcm9wTmFtZXMiLCAiX19oYXNPd25Qcm9wIiwgIl9fZXhwb3J0IiwgIl9fY29weVByb3BzIiwgInZhbHVlIiwgImJ1aWxkIiwgImluaXRpYWxpemUiLCAidmFsdWUyIiwgImxlbmd0aCIsICJkZWZpbmUiLCAiX2EiLCAiZXJyIiwgIm9ubWVzc2FnZSIsICJwb3N0TWVzc2FnZSIsICJfX2FzeW5jIiwgImdsb2JhbFRoaXMiLCAiZmQiLCAiZ28iLCAidXJsIiwgInJlYWQiLCAidmFsdWUiLCAiY3JlYXRlRGVmYXVsdENvbnRhaW5lciIsICJ2a0Zvcm1hdCIsICJWS19GT1JNQVRfVU5ERUZJTkVEIiwgInR5cGVTaXplIiwgInBpeGVsV2lkdGgiLCAicGl4ZWxIZWlnaHQiLCAicGl4ZWxEZXB0aCIsICJsYXllckNvdW50IiwgImZhY2VDb3VudCIsICJsZXZlbENvdW50IiwgInN1cGVyY29tcHJlc3Npb25TY2hlbWUiLCAiS0hSX1NVUEVSQ09NUFJFU1NJT05fTk9ORSIsICJsZXZlbHMiLCAiZGF0YUZvcm1hdERlc2NyaXB0b3IiLCAidmVuZG9ySWQiLCAiS0hSX0RGX1ZFTkRPUklEX0tIUk9OT1MiLCAiZGVzY3JpcHRvclR5cGUiLCAiS0hSX0RGX0tIUl9ERVNDUklQVE9SVFlQRV9CQVNJQ0ZPUk1BVCIsICJ2ZXJzaW9uTnVtYmVyIiwgIktIUl9ERl9WRVJTSU9OIiwgImNvbG9yTW9kZWwiLCAiS0hSX0RGX01PREVMX1VOU1BFQ0lGSUVEIiwgImNvbG9yUHJpbWFyaWVzIiwgIktIUl9ERl9QUklNQVJJRVNfQlQ3MDkiLCAidHJhbnNmZXJGdW5jdGlvbiIsICJLSFJfREZfVFJBTlNGRVJfU1JHQiIsICJmbGFncyIsICJLSFJfREZfRkxBR19BTFBIQV9TVFJBSUdIVCIsICJ0ZXhlbEJsb2NrRGltZW5zaW9uIiwgImJ5dGVzUGxhbmUiLCAic2FtcGxlcyIsICJrZXlWYWx1ZSIsICJnbG9iYWxEYXRhIiwgImRlY29kZVRleHQiLCAiYnVmZmVyIiwgIlRleHREZWNvZGVyIiwgImRlY29kZSIsICJyZWFkIiwgImRhdGEiLCAiaWQiLCAiVWludDhBcnJheSIsICJieXRlT2Zmc2V0IiwgIktUWDJfSUQiLCAibGVuZ3RoIiwgIkVycm9yIiwgImNvbnRhaW5lciIsICJoZWFkZXJCeXRlTGVuZ3RoIiwgIlVpbnQzMkFycmF5IiwgIkJZVEVTX1BFUl9FTEVNRU5UIiwgImhlYWRlclJlYWRlciIsICJCdWZmZXJSZWFkZXIiLCAiX25leHRVaW50MzIiLCAiZGZkQnl0ZU9mZnNldCIsICJkZmRCeXRlTGVuZ3RoIiwgImt2ZEJ5dGVPZmZzZXQiLCAia3ZkQnl0ZUxlbmd0aCIsICJzZ2RCeXRlT2Zmc2V0IiwgIl9uZXh0VWludDY0IiwgInNnZEJ5dGVMZW5ndGgiLCAibGV2ZWxCeXRlTGVuZ3RoIiwgIk1hdGgiLCAibWF4IiwgImxldmVsUmVhZGVyIiwgImkiLCAiaWwiLCAicHVzaCIsICJsZXZlbERhdGEiLCAidW5jb21wcmVzc2VkQnl0ZUxlbmd0aCIsICJkZmRSZWFkZXIiLCAiX3NraXAiLCAiX25leHRVaW50MTYiLCAiZGVzY3JpcHRvckJsb2NrU2l6ZSIsICJfbmV4dFVpbnQ4IiwgImRmZCIsICJzYW1wbGVTdGFydCIsICJzYW1wbGVXb3JkcyIsICJudW1TYW1wbGVzIiwgInNhbXBsZSIsICJiaXRPZmZzZXQiLCAiYml0TGVuZ3RoIiwgImNoYW5uZWxUeXBlIiwgInNhbXBsZVBvc2l0aW9uIiwgInNhbXBsZUxvd2VyIiwgIk51bWJlciIsICJORUdBVElWRV9JTkZJTklUWSIsICJzYW1wbGVVcHBlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJLSFJfREZfU0FNUExFX0RBVEFUWVBFX1NJR05FRCIsICJfbmV4dEludDMyIiwgImt2ZFJlYWRlciIsICJfb2Zmc2V0IiwgImtleVZhbHVlQnl0ZUxlbmd0aCIsICJrZXlEYXRhIiwgIl9zY2FuIiwgImtleSIsICJfbmV4dFVpbnQ4QXJyYXkiLCAiYnl0ZUxlbmd0aCIsICJtYXRjaCIsICJ0ZXh0IiwgInN1YnN0cmluZyIsICJsYXN0SW5kZXhPZiIsICJrdlBhZGRpbmciLCAic2dkUmVhZGVyIiwgImVuZHBvaW50Q291bnQiLCAic2VsZWN0b3JDb3VudCIsICJlbmRwb2ludHNCeXRlTGVuZ3RoIiwgInNlbGVjdG9yc0J5dGVMZW5ndGgiLCAidGFibGVzQnl0ZUxlbmd0aCIsICJleHRlbmRlZEJ5dGVMZW5ndGgiLCAiaW1hZ2VEZXNjcyIsICJpbWFnZUZsYWdzIiwgInJnYlNsaWNlQnl0ZU9mZnNldCIsICJyZ2JTbGljZUJ5dGVMZW5ndGgiLCAiYWxwaGFTbGljZUJ5dGVPZmZzZXQiLCAiYWxwaGFTbGljZUJ5dGVMZW5ndGgiLCAiZW5kcG9pbnRzQnl0ZU9mZnNldCIsICJzZWxlY3RvcnNCeXRlT2Zmc2V0IiwgInRhYmxlc0J5dGVPZmZzZXQiLCAiZXh0ZW5kZWRCeXRlT2Zmc2V0IiwgImVuZHBvaW50c0RhdGEiLCAic2VsZWN0b3JzRGF0YSIsICJ0YWJsZXNEYXRhIiwgImV4dGVuZGVkRGF0YSIsICJLSFJfREZfTU9ERUxfRVRDMVMiLCAiS0hSX0RGX01PREVMX1VBU1RDIiwgIk5VTCIsICJjb25zdHJ1Y3RvciIsICJsaXR0bGVFbmRpYW4iLCAiX2RhdGFWaWV3IiwgIl9saXR0bGVFbmRpYW4iLCAiRGF0YVZpZXciLCAidmFsdWUiLCAiZ2V0VWludDgiLCAiZ2V0VWludDE2IiwgImdldFVpbnQzMiIsICJsZWZ0IiwgInJpZ2h0IiwgImdldEludDMyIiwgImxlbiIsICJieXRlcyIsICJtYXhCeXRlTGVuZ3RoIiwgInRlcm0iLCAiaXNGYWxsYmFja0J1ZmZlciIsICJidWZmZXJEZWYiLCAiZXh0ZW5zaW9ucyIsICJFWFRfTUVTSE9QVF9DT01QUkVTU0lPTiIsICJmYWxsYmFja0RlZiIsICJmYWxsYmFjayIsICJwcmVwYXJlQWNjZXNzb3IiLCAiYWNjZXNzb3IiLCAiZW5jb2RlciIsICJtb2RlIiwgImZpbHRlck9wdGlvbnMiLCAiZmlsdGVyIiwgImJpdHMiLCAicmVzdWx0IiwgImFycmF5IiwgImdldEFycmF5IiwgImJ5dGVTdHJpZGUiLCAiZ2V0RWxlbWVudFNpemUiLCAiZ2V0Q29tcG9uZW50U2l6ZSIsICJjb21wb25lbnRUeXBlIiwgImdldENvbXBvbmVudFR5cGUiLCAibm9ybWFsaXplZCIsICJnZXROb3JtYWxpemVkIiwgIk1lc2hvcHRNb2RlIiwgIkFUVFJJQlVURVMiLCAiTWVzaG9wdEZpbHRlciIsICJOT05FIiwgImRlY29kZU5vcm1hbGl6ZWRJbnRBcnJheSIsICJGbG9hdDMyQXJyYXkiLCAiRVhQT05FTlRJQUwiLCAiRkxPQVQiLCAiZW5jb2RlRmlsdGVyRXhwIiwgImdldENvdW50IiwgIk9DVEFIRURSQUwiLCAiU0hPUlQiLCAiQllURSIsICJwYWROb3JtYWxzIiwgImVuY29kZUZpbHRlck9jdCIsICJRVUFURVJOSU9OIiwgImVuY29kZUZpbHRlclF1YXQiLCAiRXJyb3IiLCAibWluIiwgImdldE1pbiIsICJtYXgiLCAiZ2V0TWF4IiwgIm1hcCIsICJ2IiwgImRlY29kZU5vcm1hbGl6ZWRJbnQiLCAiZW5jb2RlTm9ybWFsaXplZEludCIsICJwYWRBcnJheUVsZW1lbnRzIiwgImJ5dGVMZW5ndGgiLCAiYXR0cmlidXRlIiwgInNyY0FycmF5IiwgImRzdEFycmF5IiwgImxlbmd0aCIsICJpIiwgImVsZW1lbnRTaXplIiwgIkJ1ZmZlclV0aWxzIiwgInBhZE51bWJlciIsICJCWVRFU19QRVJfRUxFTUVOVCIsICJlbGVtZW50U3RyaWRlIiwgImVsZW1lbnRDb3VudCIsICJjb25zdHJ1Y3RvciIsICJqIiwgImlsIiwgImdldE1lc2hvcHRNb2RlIiwgInVzYWdlIiwgIldyaXRlckNvbnRleHQiLCAiQnVmZmVyVmlld1VzYWdlIiwgIkVMRU1FTlRfQVJSQVlfQlVGRkVSIiwgImlzVHJpYW5nbGVzIiwgImxpc3RQYXJlbnRzIiwgInNvbWUiLCAicGFyZW50IiwgIlByaW1pdGl2ZSIsICJnZXRNb2RlIiwgIk1vZGUiLCAiVFJJQU5HTEVTIiwgIklORElDRVMiLCAiZ2V0TWVzaG9wdEZpbHRlciIsICJkb2MiLCAicmVmcyIsICJnZXRHcmFwaCIsICJsaXN0UGFyZW50RWRnZXMiLCAiZWRnZSIsICJnZXRQYXJlbnQiLCAiUm9vdCIsICJyZWYiLCAicmVmTmFtZSIsICJnZXROYW1lIiwgInJlZktleSIsICJnZXRBdHRyaWJ1dGVzIiwgImtleSIsICJpc0RlbHRhIiwgInByb3BlcnR5VHlwZSIsICJQcm9wZXJ0eVR5cGUiLCAiUFJJTUlUSVZFX1RBUkdFVCIsICJzdGFydHNXaXRoIiwgInRhcmdldFBhdGgiLCAiZ2V0VGFyZ2V0UGF0aCIsICJzYW1wbGVyIiwgIkFuaW1hdGlvblNhbXBsZXIiLCAiY2hhbm5lbCIsICJBbmltYXRpb25DaGFubmVsIiwgInVuYm94IiwgImRhdGEiLCAib2Zmc2V0IiwgInNpemUiLCAiZ2V0VWludDMyIiwgInR5cGUiLCAiZGVjb2RlVGV4dCIsICJVaW50OEFycmF5IiwgImJ1ZmZlciIsICJieXRlT2Zmc2V0IiwgInN0YXJ0IiwgImVuZCIsICJkZWNvZGVHZW9tZXRyeSIsICJkZWNvZGVyIiwgImRlY29kZXJNb2R1bGUiLCAiRGVjb2RlckJ1ZmZlciIsICJJbml0IiwgImdlb21ldHJ5VHlwZSIsICJHZXRFbmNvZGVkR2VvbWV0cnlUeXBlIiwgIlRSSUFOR1VMQVJfTUVTSCIsICJLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiIsICJkcmFjb01lc2giLCAiTWVzaCIsICJzdGF0dXMiLCAiRGVjb2RlQnVmZmVyVG9NZXNoIiwgIm9rIiwgInB0ciIsICJkZXN0cm95IiwgImRlY29kZUluZGV4IiwgIm1lc2giLCAibnVtRmFjZXMiLCAibnVtX2ZhY2VzIiwgIm51bUluZGljZXMiLCAiaW5kaWNlcyIsICJudW1fcG9pbnRzIiwgIlVpbnQxNkFycmF5IiwgIl9tYWxsb2MiLCAiR2V0VHJpYW5nbGVzVUludDE2QXJyYXkiLCAiSEVBUFUxNiIsICJzbGljZSIsICJVaW50MzJBcnJheSIsICJHZXRUcmlhbmdsZXNVSW50MzJBcnJheSIsICJIRUFQVTMyIiwgIl9mcmVlIiwgImRlY29kZUF0dHJpYnV0ZSIsICJhY2Nlc3NvckRlZiIsICJkYXRhVHlwZSIsICJEQVRBX1RZUEUiLCAiQXJyYXlDdG9yIiwgIkNPTVBPTkVOVF9BUlJBWSIsICJudW1Db21wb25lbnRzIiwgIm51bV9jb21wb25lbnRzIiwgIm51bVBvaW50cyIsICJudW1WYWx1ZXMiLCAiR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzIiwgIkhFQVBGMzIiLCAiaW5pdERlY29kZXJNb2R1bGUiLCAiX2RlY29kZXJNb2R1bGUiLCAiQWNjZXNzb3IiLCAiQ29tcG9uZW50VHlwZSIsICJVTlNJR05FRF9JTlQiLCAiVU5TSUdORURfU0hPUlQiLCAiVU5TSUdORURfQllURSIsICJJbnQxNkFycmF5IiwgIkludDhBcnJheSIsICJEVF9GTE9BVDMyIiwgIkRUX1VJTlQzMiIsICJEVF9VSU5UMTYiLCAiRFRfVUlOVDgiLCAiRFRfSU5UMTYiLCAiRFRfSU5UOCIsICJpbml0RW5jb2Rlck1vZHVsZSIsICJfZW5jb2Rlck1vZHVsZSIsICJlbmNvZGVyTW9kdWxlIiwgImVuY29kZUdlb21ldHJ5IiwgInByaW0iLCAiX29wdGlvbnMiLCAiREVGQVVMVF9FTkNPREVSX09QVElPTlMiLCAib3B0aW9ucyIsICJfZXh0ZW5kcyIsICJxdWFudGl6YXRpb25CaXRzIiwgIkRFRkFVTFRfUVVBTlRJWkFUSU9OX0JJVFMiLCAiYnVpbGRlciIsICJNZXNoQnVpbGRlciIsICJFeHBlcnRFbmNvZGVyIiwgImF0dHJpYnV0ZUlEcyIsICJkcmFjb0J1ZmZlciIsICJEcmFjb0ludDhBcnJheSIsICJoYXNNb3JwaFRhcmdldHMiLCAibGlzdFRhcmdldHMiLCAiaGFzU3BhcnNlQXR0cmlidXRlcyIsICJzZW1hbnRpYyIsICJsaXN0U2VtYW50aWNzIiwgImdldEF0dHJpYnV0ZSIsICJnZXRTcGFyc2UiLCAiYXR0cmlidXRlRW51bSIsICJnZXRBdHRyaWJ1dGVFbnVtIiwgImF0dHJpYnV0ZUlEIiwgImFkZEF0dHJpYnV0ZSIsICJxdWFudGl6YXRpb25Wb2x1bWUiLCAiU2V0QXR0cmlidXRlUXVhbnRpemF0aW9uIiwgInJhbmdlIiwgIk1hdGgiLCAiU2V0QXR0cmlidXRlRXhwbGljaXRRdWFudGl6YXRpb24iLCAiZ2V0SW5kaWNlcyIsICJFbmNvZGluZ0Vycm9yIiwgIkFkZEZhY2VzVG9NZXNoIiwgIlNldFNwZWVkT3B0aW9ucyIsICJlbmNvZGVTcGVlZCIsICJkZWNvZGVTcGVlZCIsICJTZXRUcmFja0VuY29kZWRQcm9wZXJ0aWVzIiwgIm1ldGhvZCIsICJFbmNvZGVyTWV0aG9kIiwgIlNFUVVFTlRJQUwiLCAiU2V0RW5jb2RpbmdNZXRob2QiLCAiTUVTSF9TRVFVRU5USUFMX0VOQ09ESU5HIiwgIk1FU0hfRURHRUJSRUFLRVJfRU5DT0RJTkciLCAiRW5jb2RlVG9EcmFjb0J1ZmZlciIsICJHZXRWYWx1ZSIsICJudW1WZXJ0aWNlcyIsICJHZXROdW1iZXJPZkVuY29kZWRQb2ludHMiLCAiR2V0TnVtYmVyT2ZFbmNvZGVkRmFjZXMiLCAiQXR0cmlidXRlRW51bSIsICJQT1NJVElPTiIsICJOT1JNQUwiLCAiQ09MT1IiLCAiVEVYX0NPT1JEIiwgIkdFTkVSSUMiLCAiY291bnQiLCAiaXRlbVNpemUiLCAiQWRkVUludDhBdHRyaWJ1dGUiLCAiQWRkSW50OEF0dHJpYnV0ZSIsICJBZGRVSW50MTZBdHRyaWJ1dGUiLCAiQWRkSW50MTZBdHRyaWJ1dGUiLCAiQWRkVUludDMyQXR0cmlidXRlIiwgIkFkZEZsb2F0QXR0cmlidXRlIiwgImxpc3REcmFjb1ByaW1pdGl2ZXMiLCAibG9nZ2VyIiwgImdldExvZ2dlciIsICJpbmNsdWRlZCIsICJTZXQiLCAiZXhjbHVkZWQiLCAibm9uSW5kZXhlZCIsICJub25UcmlhbmdsZXMiLCAiZ2V0Um9vdCIsICJsaXN0TWVzaGVzIiwgImxpc3RQcmltaXRpdmVzIiwgImFkZCIsICJ3YXJuIiwgImFjY2Vzc29ycyIsICJsaXN0QWNjZXNzb3JzIiwgImFjY2Vzc29ySW5kaWNlcyIsICJNYXAiLCAic2V0IiwgImluY2x1ZGVkQWNjZXNzb3JzIiwgImluY2x1ZGVkSGFzaEtleXMiLCAicHJpbVRvSGFzaEtleSIsICJBcnJheSIsICJmcm9tIiwgImhhc2hLZXkiLCAiY3JlYXRlSGFzaEtleSIsICJoYXMiLCAiZHN0SW5kaWNlcyIsICJjbG9uZSIsICJzd2FwIiwgImxpc3RBdHRyaWJ1dGVzIiwgImRzdEF0dHJpYnV0ZSIsICJrZXlzIiwgInBhcmVudFR5cGVzIiwgInByb3AiLCAiUFJJTUlUSVZFIiwgIlJPT1QiLCAiZ2V0IiwgImF0dHIiLCAiaW5kZXhNYXAiLCAiaGFzaEVsZW1lbnRzIiwgInB1c2giLCAic29ydCIsICJqb2luIiwgImNvcHlKU09OIiwgIm9iamVjdCIsICJKU09OIiwgInBhcnNlIiwgInN0cmluZ2lmeSIsICJFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORyIsICJFWFRfVEVYVFVSRV9XRUJQIiwgIkVYVF9URVhUVVJFX0FWSUYiLCAiS0hSX0xJR0hUU19QVU5DVFVBTCIsICJLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFkiLCAiS0hSX01BVEVSSUFMU19DTEVBUkNPQVQiLCAiS0hSX01BVEVSSUFMU19ESUZGVVNFX1RSQU5TTUlTU0lPTiIsICJLSFJfTUFURVJJQUxTX0RJU1BFUlNJT04iLCAiS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSCIsICJLSFJfTUFURVJJQUxTX0lPUiIsICJLSFJfTUFURVJJQUxTX0lSSURFU0NFTkNFIiwgIktIUl9NQVRFUklBTFNfUEJSX1NQRUNVTEFSX0dMT1NTSU5FU1MiLCAiS0hSX01BVEVSSUFMU19TSEVFTiIsICJLSFJfTUFURVJJQUxTX1NQRUNVTEFSIiwgIktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OIiwgIktIUl9NQVRFUklBTFNfVU5MSVQiLCAiS0hSX01BVEVSSUFMU19WT0xVTUUiLCAiS0hSX01BVEVSSUFMU19WQVJJQU5UUyIsICJLSFJfTUVTSF9RVUFOVElaQVRJT04iLCAiS0hSX1RFWFRVUkVfQkFTSVNVIiwgIktIUl9URVhUVVJFX1RSQU5TRk9STSIsICJLSFJfWE1QX0pTT05fTEQiLCAiSU5TVEFOQ0VfQVRUUklCVVRFIiwgIkluc3RhbmNlZE1lc2giLCAiRVhUTWVzaEdQVUluc3RhbmNpbmciLCAiRVhUTWVzaG9wdENvbXByZXNzaW9uIiwgIkFWSUZJbWFnZVV0aWxzIiwgIkVYVFRleHR1cmVBVklGIiwgIldFQlBJbWFnZVV0aWxzIiwgIkVYVFRleHR1cmVXZWJQIiwgIktIUkRyYWNvTWVzaENvbXByZXNzaW9uIiwgIkxpZ2h0IiwgIktIUkxpZ2h0c1B1bmN0dWFsIiwgIlIiLCAiRyIsICJCIiwgIkFuaXNvdHJvcHkiLCAiS0hSTWF0ZXJpYWxzQW5pc290cm9weSIsICJDbGVhcmNvYXQiLCAiS0hSTWF0ZXJpYWxzQ2xlYXJjb2F0IiwgIkEiLCAiRGlmZnVzZVRyYW5zbWlzc2lvbiIsICJLSFJNYXRlcmlhbHNEaWZmdXNlVHJhbnNtaXNzaW9uIiwgIkRpc3BlcnNpb24iLCAiS0hSTWF0ZXJpYWxzRGlzcGVyc2lvbiIsICJFbWlzc2l2ZVN0cmVuZ3RoIiwgIktIUk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGgiLCAiSU9SIiwgIktIUk1hdGVyaWFsc0lPUiIsICJJcmlkZXNjZW5jZSIsICJLSFJNYXRlcmlhbHNJcmlkZXNjZW5jZSIsICJQQlJTcGVjdWxhckdsb3NzaW5lc3MiLCAiS0hSTWF0ZXJpYWxzUEJSU3BlY3VsYXJHbG9zc2luZXNzIiwgIlNoZWVuIiwgIktIUk1hdGVyaWFsc1NoZWVuIiwgIlNwZWN1bGFyIiwgIktIUk1hdGVyaWFsc1NwZWN1bGFyIiwgIlRyYW5zbWlzc2lvbiIsICJLSFJNYXRlcmlhbHNUcmFuc21pc3Npb24iLCAiVW5saXQiLCAiS0hSTWF0ZXJpYWxzVW5saXQiLCAiTWFwcGluZyIsICJNYXBwaW5nTGlzdCIsICJWYXJpYW50IiwgIktIUk1hdGVyaWFsc1ZhcmlhbnRzIiwgIlZvbHVtZSIsICJLSFJNYXRlcmlhbHNWb2x1bWUiLCAiS0hSTWVzaFF1YW50aXphdGlvbiIsICJLVFgySW1hZ2VVdGlscyIsICJLSFJUZXh0dXJlQmFzaXN1IiwgIlRyYW5zZm9ybSIsICJLSFJUZXh0dXJlVHJhbnNmb3JtIiwgIlBBUkVOVF9UWVBFUyIsICJQYWNrZXQiLCAiS0hSWE1QIiwgIktIUk9OT1NfRVhURU5TSU9OUyIsICJBTExfRVhURU5TSU9OUyIsICJFeHRlbnNpb25Qcm9wZXJ0eSIsICJpbml0IiwgImV4dGVuc2lvbk5hbWUiLCAiTk9ERSIsICJnZXREZWZhdWx0cyIsICJPYmplY3QiLCAiYXNzaWduIiwgImF0dHJpYnV0ZXMiLCAiUmVmTWFwIiwgImdldFJlZk1hcCIsICJzZXRBdHRyaWJ1dGUiLCAic2V0UmVmTWFwIiwgImxpc3RSZWZNYXBWYWx1ZXMiLCAibGlzdFJlZk1hcEtleXMiLCAiRVhURU5TSU9OX05BTUUiLCAiRXh0ZW5zaW9uIiwgImFyZ3MiLCAicHJvdmlkZVR5cGVzIiwgInByZXdyaXRlVHlwZXMiLCAiQUNDRVNTT1IiLCAiY3JlYXRlSW5zdGFuY2VkTWVzaCIsICJkb2N1bWVudCIsICJyZWFkIiwgImNvbnRleHQiLCAianNvbkRvYyIsICJub2RlRGVmcyIsICJqc29uIiwgIm5vZGVzIiwgImZvckVhY2giLCAibm9kZURlZiIsICJub2RlSW5kZXgiLCAiaW5zdGFuY2VkTWVzaERlZiIsICJpbnN0YW5jZWRNZXNoIiwgInNldEV4dGVuc2lvbiIsICJwcmV3cml0ZSIsICJhY2Nlc3NvclVzYWdlR3JvdXBlZEJ5UGFyZW50IiwgInByb3BlcnRpZXMiLCAiYWRkQWNjZXNzb3JUb1VzYWdlR3JvdXAiLCAid3JpdGUiLCAibGlzdE5vZGVzIiwgIm5vZGUiLCAiZ2V0RXh0ZW5zaW9uIiwgIm5vZGVJbmRleE1hcCIsICJhY2Nlc3NvckluZGV4TWFwIiwgIk1hdGhVdGlscyIsICJRVUFOVElaRSIsICJwcmVyZWFkVHlwZXMiLCAiQlVGRkVSIiwgInJlYWREZXBlbmRlbmNpZXMiLCAid3JpdGVEZXBlbmRlbmNpZXMiLCAiX2RlY29kZXIiLCAiX2RlY29kZXJGYWxsYmFja0J1ZmZlck1hcCIsICJfZW5jb2RlciIsICJfZW5jb2Rlck9wdGlvbnMiLCAiX2VuY29kZXJGYWxsYmFja0J1ZmZlciIsICJfZW5jb2RlckJ1ZmZlclZpZXdzIiwgIl9lbmNvZGVyQnVmZmVyVmlld0RhdGEiLCAiX2VuY29kZXJCdWZmZXJWaWV3QWNjZXNzb3JzIiwgImluc3RhbGwiLCAiZGVwZW5kZW5jeSIsICJzZXRFbmNvZGVyT3B0aW9ucyIsICJwcmVyZWFkIiwgImlzUmVxdWlyZWQiLCAic3VwcG9ydGVkIiwgIl9wcmVyZWFkQnVmZmVycyIsICJfcHJlcmVhZFByaW1pdGl2ZXMiLCAidmlld0RlZnMiLCAiYnVmZmVyVmlld3MiLCAidmlld0RlZiIsICJpbmRleCIsICJtZXNob3B0RGVmIiwgInN0cmlkZSIsICJidWZmZXJzIiwgInJlc291cmNlIiwgInVyaSIsICJyZXNvdXJjZXMiLCAiR0xCX0JVRkZFUiIsICJzb3VyY2UiLCAidG9WaWV3IiwgImRlY29kZUdsdGZCdWZmZXIiLCAiZmFsbGJhY2tCdWZmZXIiLCAiZmFsbGJhY2tCdWZmZXJEZWYiLCAiX2NvbnRleHQiLCAiZGlzcG9zZSIsICJfcHJld3JpdGVBY2Nlc3NvcnMiLCAiX3ByZXdyaXRlQnVmZmVycyIsICJncmFwaCIsICJjcmVhdGVCdWZmZXIiLCAiZmFsbGJhY2tCdWZmZXJJbmRleCIsICJsaXN0QnVmZmVycyIsICJpbmRleE9mIiwgIm5leHRJRCIsICJwYXJlbnRUb0lEIiwgImdldFBhcmVudElEIiwgInByb3BlcnR5IiwgImlkIiwgInVuZGVmaW5lZCIsICJnZXRBY2Nlc3NvclVzYWdlIiwgInBhcmVudElEIiwgIkZJTFRFUiIsICJwcmVwYXJlZEFjY2Vzc29yIiwgImdldEJ1ZmZlciIsICJidWZmZXJJbmRleCIsICJidWZmZXJWaWV3IiwgImJ1ZmZlclZpZXdEYXRhIiwgImJ1ZmZlclZpZXdBY2Nlc3NvcnMiLCAidGFyZ2V0IiwgIlVTQUdFX1RPX1RBUkdFVCIsICJBUlJBWV9CVUZGRVIiLCAiY3JlYXRlQWNjZXNzb3JEZWYiLCAiRVhUX21lc2hvcHRfY29tcHJlc3Npb24iLCAib3RoZXJCdWZmZXJWaWV3cyIsICJjb25jYXQiLCAiZW5jb2RlR2x0ZkJ1ZmZlciIsICJjb21wcmVzc2VkRGF0YSIsICJwYWQiLCAiZmFsbGJhY2tCdWZmZXJCeXRlT2Zmc2V0IiwgImJ1ZmZlclZpZXdJbmRleCIsICJvdGhlckJ1ZmZlclZpZXdzSW5kZXhNYXAiLCAiZmluYWxCdWZmZXJWaWV3RGVmIiwgImNvbXByZXNzZWRCeXRlT2Zmc2V0IiwgImJ1ZmZlclZpZXdFeHRlbnNpb25EZWYiLCAiYnVmZmVySW5kZXhNYXAiLCAibWF0Y2giLCAiZ2V0U2l6ZSIsICJ2aWV3IiwgIkRhdGFWaWV3IiwgImJveCIsICJnZXRDaGFubmVscyIsICJfYnVmZmVyIiwgIlRFWFRVUkUiLCAicmVnaXN0ZXIiLCAiSW1hZ2VVdGlscyIsICJyZWdpc3RlckZvcm1hdCIsICJ0ZXh0dXJlRGVmcyIsICJ0ZXh0dXJlcyIsICJ0ZXh0dXJlRGVmIiwgImxpc3RUZXh0dXJlcyIsICJ0ZXh0dXJlIiwgImdldE1pbWVUeXBlIiwgImltYWdlSW5kZXgiLCAiaW1hZ2VJbmRleE1hcCIsICJSSUZGIiwgIldFQlAiLCAiY2h1bmtJZCIsICJnZXRVaW50OCIsICJjaHVua0J5dGVMZW5ndGgiLCAid2lkdGgiLCAiZ2V0SW50MTYiLCAiaGVpZ2h0IiwgImIwIiwgImIxIiwgImIyIiwgImIzIiwgIkVER0VCUkVBS0VSIiwgImRyYWNvTWVzaGVzIiwgIm1lc2hEZWZzIiwgIm1lc2hlcyIsICJtZXNoRGVmIiwgInByaW1EZWYiLCAicHJpbWl0aXZlcyIsICJkcmFjb0RlZiIsICJidWZmZXJWaWV3RGVmIiwgIkRlY29kZXIiLCAiZGVidWciLCAiZHJhY29BdHRyaWJ1dGUiLCAiR2V0QXR0cmlidXRlQnlVbmlxdWVJZCIsICJhdHRyaWJ1dGVBcnJheSIsICJzZXRBcnJheSIsICJ2YWx1ZXMiLCAiX3Byb3BlcnR5VHlwZSIsICJwcmltaXRpdmVIYXNoTWFwIiwgInByaW1pdGl2ZUVuY29kaW5nTWFwIiwgImxpc3RTY2VuZXMiLCAiZ2V0Qm91bmRzIiwgInBvcCIsICJwcmltSGFzaCIsICJhY2Nlc3NvckRlZnMiLCAiZW5jb2RlZFByaW0iLCAiZSIsICJtZXNzYWdlIiwgImluZGljZXNEZWYiLCAiYXR0cmlidXRlRGVmIiwgImV4dGVuc2lvbkRhdGEiLCAiZHJhY29Db250ZXh0IiwgIm1lc2hJbmRleE1hcCIsICJleHRlbnNpb25zVXNlZCIsICJuYW1lIiwgImV4dGVuc2lvbnNSZXF1aXJlZCIsICJjb2xvciIsICJpbnRlbnNpdHkiLCAiVHlwZSIsICJQT0lOVCIsICJpbm5lckNvbmVBbmdsZSIsICJvdXRlckNvbmVBbmdsZSIsICJQSSIsICJnZXRDb2xvciIsICJzZXRDb2xvciIsICJnZXRJbnRlbnNpdHkiLCAic2V0SW50ZW5zaXR5IiwgImdldFR5cGUiLCAic2V0VHlwZSIsICJnZXRSYW5nZSIsICJzZXRSYW5nZSIsICJnZXRJbm5lckNvbmVBbmdsZSIsICJzZXRJbm5lckNvbmVBbmdsZSIsICJhbmdsZSIsICJnZXRPdXRlckNvbmVBbmdsZSIsICJzZXRPdXRlckNvbmVBbmdsZSIsICJTUE9UIiwgIkRJUkVDVElPTkFMIiwgImNyZWF0ZUxpZ2h0IiwgInJvb3REZWYiLCAibGlnaHREZWZzIiwgImxpZ2h0cyIsICJsaWdodERlZiIsICJfbGlnaHREZWYkc3BvdCIsICJfbGlnaHREZWYkc3BvdDIiLCAibGlnaHQiLCAic2V0TmFtZSIsICJzcG90IiwgImxpZ2h0Tm9kZURlZiIsICJsaWdodEluZGV4TWFwIiwgImVxIiwgIlRleHR1cmVDaGFubmVsIiwgIk1BVEVSSUFMIiwgImFuaXNvdHJvcHlTdHJlbmd0aCIsICJhbmlzb3Ryb3B5Um90YXRpb24iLCAiYW5pc290cm9weVRleHR1cmUiLCAiYW5pc290cm9weVRleHR1cmVJbmZvIiwgIlRleHR1cmVJbmZvIiwgImdldEFuaXNvdHJvcHlTdHJlbmd0aCIsICJzZXRBbmlzb3Ryb3B5U3RyZW5ndGgiLCAic3RyZW5ndGgiLCAiZ2V0QW5pc290cm9weVJvdGF0aW9uIiwgInNldEFuaXNvdHJvcHlSb3RhdGlvbiIsICJyb3RhdGlvbiIsICJnZXRBbmlzb3Ryb3B5VGV4dHVyZSIsICJnZXRSZWYiLCAiZ2V0QW5pc290cm9weVRleHR1cmVJbmZvIiwgInNldEFuaXNvdHJvcHlUZXh0dXJlIiwgInNldFJlZiIsICJjaGFubmVscyIsICJNRVNIIiwgImNyZWF0ZUFuaXNvdHJvcHkiLCAibWF0ZXJpYWxEZWZzIiwgIm1hdGVyaWFscyIsICJtYXRlcmlhbERlZiIsICJtYXRlcmlhbEluZGV4IiwgImFuaXNvdHJvcHkiLCAiYW5pc290cm9weURlZiIsICJ0ZXh0dXJlSW5mb0RlZiIsICJzZXRUZXh0dXJlSW5mbyIsICJsaXN0TWF0ZXJpYWxzIiwgIm1hdGVyaWFsIiwgIm1hdGVyaWFsSW5kZXhNYXAiLCAidGV4dHVyZUluZm8iLCAiY3JlYXRlVGV4dHVyZUluZm9EZWYiLCAiY2xlYXJjb2F0RmFjdG9yIiwgImNsZWFyY29hdFRleHR1cmUiLCAiY2xlYXJjb2F0VGV4dHVyZUluZm8iLCAiY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yIiwgImNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUiLCAiY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZUluZm8iLCAiY2xlYXJjb2F0Tm9ybWFsU2NhbGUiLCAiY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSIsICJjbGVhcmNvYXROb3JtYWxUZXh0dXJlSW5mbyIsICJnZXRDbGVhcmNvYXRGYWN0b3IiLCAic2V0Q2xlYXJjb2F0RmFjdG9yIiwgImZhY3RvciIsICJnZXRDbGVhcmNvYXRUZXh0dXJlIiwgImdldENsZWFyY29hdFRleHR1cmVJbmZvIiwgInNldENsZWFyY29hdFRleHR1cmUiLCAiZ2V0Q2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yIiwgInNldENsZWFyY29hdFJvdWdobmVzc0ZhY3RvciIsICJnZXRDbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlIiwgImdldENsZWFyY29hdFJvdWdobmVzc1RleHR1cmVJbmZvIiwgInNldENsZWFyY29hdFJvdWdobmVzc1RleHR1cmUiLCAiZ2V0Q2xlYXJjb2F0Tm9ybWFsU2NhbGUiLCAic2V0Q2xlYXJjb2F0Tm9ybWFsU2NhbGUiLCAic2NhbGUiLCAiZ2V0Q2xlYXJjb2F0Tm9ybWFsVGV4dHVyZSIsICJnZXRDbGVhcmNvYXROb3JtYWxUZXh0dXJlSW5mbyIsICJzZXRDbGVhcmNvYXROb3JtYWxUZXh0dXJlIiwgImNyZWF0ZUNsZWFyY29hdCIsICJjbGVhcmNvYXQiLCAiY2xlYXJjb2F0RGVmIiwgImRpZmZ1c2VUcmFuc21pc3Npb25GYWN0b3IiLCAiZGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmUiLCAiZGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmVJbmZvIiwgImRpZmZ1c2VUcmFuc21pc3Npb25Db2xvckZhY3RvciIsICJkaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JUZXh0dXJlIiwgImRpZmZ1c2VUcmFuc21pc3Npb25Db2xvclRleHR1cmVJbmZvIiwgImdldERpZmZ1c2VUcmFuc21pc3Npb25GYWN0b3IiLCAic2V0RGlmZnVzZVRyYW5zbWlzc2lvbkZhY3RvciIsICJnZXREaWZmdXNlVHJhbnNtaXNzaW9uVGV4dHVyZSIsICJnZXREaWZmdXNlVHJhbnNtaXNzaW9uVGV4dHVyZUluZm8iLCAic2V0RGlmZnVzZVRyYW5zbWlzc2lvblRleHR1cmUiLCAiZ2V0RGlmZnVzZVRyYW5zbWlzc2lvbkNvbG9yRmFjdG9yIiwgInNldERpZmZ1c2VUcmFuc21pc3Npb25Db2xvckZhY3RvciIsICJnZXREaWZmdXNlVHJhbnNtaXNzaW9uQ29sb3JUZXh0dXJlIiwgImdldERpZmZ1c2VUcmFuc21pc3Npb25Db2xvclRleHR1cmVJbmZvIiwgInNldERpZmZ1c2VUcmFuc21pc3Npb25Db2xvclRleHR1cmUiLCAiY3JlYXRlRGlmZnVzZVRyYW5zbWlzc2lvbiIsICJ0cmFuc21pc3Npb24iLCAidHJhbnNtaXNzaW9uRGVmIiwgImRpc3BlcnNpb24iLCAiZ2V0RGlzcGVyc2lvbiIsICJzZXREaXNwZXJzaW9uIiwgImNyZWF0ZURpc3BlcnNpb24iLCAiZGlzcGVyc2lvbkRlZiIsICJlbWlzc2l2ZVN0cmVuZ3RoIiwgImdldEVtaXNzaXZlU3RyZW5ndGgiLCAic2V0RW1pc3NpdmVTdHJlbmd0aCIsICJjcmVhdGVFbWlzc2l2ZVN0cmVuZ3RoIiwgImVtaXNzaXZlU3RyZW5ndGhEZWYiLCAiaW9yIiwgImdldElPUiIsICJzZXRJT1IiLCAiY3JlYXRlSU9SIiwgImlvckRlZiIsICJpcmlkZXNjZW5jZUZhY3RvciIsICJpcmlkZXNjZW5jZVRleHR1cmUiLCAiaXJpZGVzY2VuY2VUZXh0dXJlSW5mbyIsICJpcmlkZXNjZW5jZUlPUiIsICJpcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0iLCAiaXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtIiwgImlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSIsICJpcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmVJbmZvIiwgImdldElyaWRlc2NlbmNlRmFjdG9yIiwgInNldElyaWRlc2NlbmNlRmFjdG9yIiwgImdldElyaWRlc2NlbmNlVGV4dHVyZSIsICJnZXRJcmlkZXNjZW5jZVRleHR1cmVJbmZvIiwgInNldElyaWRlc2NlbmNlVGV4dHVyZSIsICJnZXRJcmlkZXNjZW5jZUlPUiIsICJzZXRJcmlkZXNjZW5jZUlPUiIsICJnZXRJcmlkZXNjZW5jZVRoaWNrbmVzc01pbmltdW0iLCAic2V0SXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtIiwgInRoaWNrbmVzcyIsICJnZXRJcmlkZXNjZW5jZVRoaWNrbmVzc01heGltdW0iLCAic2V0SXJpZGVzY2VuY2VUaGlja25lc3NNYXhpbXVtIiwgImdldElyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSIsICJnZXRJcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmVJbmZvIiwgInNldElyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSIsICJjcmVhdGVJcmlkZXNjZW5jZSIsICJpcmlkZXNjZW5jZSIsICJpcmlkZXNjZW5jZURlZiIsICJpcmlkZXNjZW5jZUlvciIsICJkaWZmdXNlRmFjdG9yIiwgImRpZmZ1c2VUZXh0dXJlIiwgImRpZmZ1c2VUZXh0dXJlSW5mbyIsICJzcGVjdWxhckZhY3RvciIsICJnbG9zc2luZXNzRmFjdG9yIiwgInNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUiLCAic3BlY3VsYXJHbG9zc2luZXNzVGV4dHVyZUluZm8iLCAiZ2V0RGlmZnVzZUZhY3RvciIsICJzZXREaWZmdXNlRmFjdG9yIiwgImdldERpZmZ1c2VUZXh0dXJlIiwgImdldERpZmZ1c2VUZXh0dXJlSW5mbyIsICJzZXREaWZmdXNlVGV4dHVyZSIsICJpc0NvbG9yIiwgImdldFNwZWN1bGFyRmFjdG9yIiwgInNldFNwZWN1bGFyRmFjdG9yIiwgImdldEdsb3NzaW5lc3NGYWN0b3IiLCAic2V0R2xvc3NpbmVzc0ZhY3RvciIsICJnZXRTcGVjdWxhckdsb3NzaW5lc3NUZXh0dXJlIiwgImdldFNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmVJbmZvIiwgInNldFNwZWN1bGFyR2xvc3NpbmVzc1RleHR1cmUiLCAiY3JlYXRlUEJSU3BlY3VsYXJHbG9zc2luZXNzIiwgInNwZWNHbG9zcyIsICJzcGVjR2xvc3NEZWYiLCAic2hlZW5Db2xvckZhY3RvciIsICJzaGVlbkNvbG9yVGV4dHVyZSIsICJzaGVlbkNvbG9yVGV4dHVyZUluZm8iLCAic2hlZW5Sb3VnaG5lc3NGYWN0b3IiLCAic2hlZW5Sb3VnaG5lc3NUZXh0dXJlIiwgInNoZWVuUm91Z2huZXNzVGV4dHVyZUluZm8iLCAiZ2V0U2hlZW5Db2xvckZhY3RvciIsICJzZXRTaGVlbkNvbG9yRmFjdG9yIiwgImdldFNoZWVuQ29sb3JUZXh0dXJlIiwgImdldFNoZWVuQ29sb3JUZXh0dXJlSW5mbyIsICJzZXRTaGVlbkNvbG9yVGV4dHVyZSIsICJnZXRTaGVlblJvdWdobmVzc0ZhY3RvciIsICJzZXRTaGVlblJvdWdobmVzc0ZhY3RvciIsICJnZXRTaGVlblJvdWdobmVzc1RleHR1cmUiLCAiZ2V0U2hlZW5Sb3VnaG5lc3NUZXh0dXJlSW5mbyIsICJzZXRTaGVlblJvdWdobmVzc1RleHR1cmUiLCAiY3JlYXRlU2hlZW4iLCAic2hlZW4iLCAic2hlZW5EZWYiLCAic3BlY3VsYXJUZXh0dXJlIiwgInNwZWN1bGFyVGV4dHVyZUluZm8iLCAic3BlY3VsYXJDb2xvckZhY3RvciIsICJzcGVjdWxhckNvbG9yVGV4dHVyZSIsICJzcGVjdWxhckNvbG9yVGV4dHVyZUluZm8iLCAiZ2V0U3BlY3VsYXJDb2xvckZhY3RvciIsICJzZXRTcGVjdWxhckNvbG9yRmFjdG9yIiwgImdldFNwZWN1bGFyVGV4dHVyZSIsICJnZXRTcGVjdWxhclRleHR1cmVJbmZvIiwgInNldFNwZWN1bGFyVGV4dHVyZSIsICJnZXRTcGVjdWxhckNvbG9yVGV4dHVyZSIsICJnZXRTcGVjdWxhckNvbG9yVGV4dHVyZUluZm8iLCAic2V0U3BlY3VsYXJDb2xvclRleHR1cmUiLCAiY3JlYXRlU3BlY3VsYXIiLCAic3BlY3VsYXIiLCAic3BlY3VsYXJEZWYiLCAidHJhbnNtaXNzaW9uRmFjdG9yIiwgInRyYW5zbWlzc2lvblRleHR1cmUiLCAidHJhbnNtaXNzaW9uVGV4dHVyZUluZm8iLCAiZ2V0VHJhbnNtaXNzaW9uRmFjdG9yIiwgInNldFRyYW5zbWlzc2lvbkZhY3RvciIsICJnZXRUcmFuc21pc3Npb25UZXh0dXJlIiwgImdldFRyYW5zbWlzc2lvblRleHR1cmVJbmZvIiwgInNldFRyYW5zbWlzc2lvblRleHR1cmUiLCAiY3JlYXRlVHJhbnNtaXNzaW9uIiwgImNyZWF0ZVVubGl0IiwgInZhcmlhbnRzIiwgIlJlZlNldCIsICJnZXRNYXRlcmlhbCIsICJzZXRNYXRlcmlhbCIsICJhZGRWYXJpYW50IiwgInZhcmlhbnQiLCAiYWRkUmVmIiwgInJlbW92ZVZhcmlhbnQiLCAicmVtb3ZlUmVmIiwgImxpc3RWYXJpYW50cyIsICJsaXN0UmVmcyIsICJtYXBwaW5ncyIsICJhZGRNYXBwaW5nIiwgIm1hcHBpbmciLCAicmVtb3ZlTWFwcGluZyIsICJsaXN0TWFwcGluZ3MiLCAiY3JlYXRlTWFwcGluZ0xpc3QiLCAiY3JlYXRlVmFyaWFudCIsICJjcmVhdGVNYXBwaW5nIiwgInZhcmlhbnRzUm9vdERlZiIsICJ2YXJpYW50RGVmcyIsICJ2YXJpYW50RGVmIiwgIm1lc2hJbmRleCIsICJwcmltRGVmcyIsICJwcmltSW5kZXgiLCAibWFwcGluZ0xpc3QiLCAidmFyaWFudFByaW1EZWYiLCAibWFwcGluZ0RlZiIsICJ2YXJpYW50SW5kZXgiLCAidmFyaWFudEluZGV4TWFwIiwgImNyZWF0ZVByb3BlcnR5RGVmIiwgIm1hcHBpbmdEZWZzIiwgInRoaWNrbmVzc0ZhY3RvciIsICJ0aGlja25lc3NUZXh0dXJlIiwgInRoaWNrbmVzc1RleHR1cmVJbmZvIiwgImF0dGVudWF0aW9uRGlzdGFuY2UiLCAiSW5maW5pdHkiLCAiYXR0ZW51YXRpb25Db2xvciIsICJnZXRUaGlja25lc3NGYWN0b3IiLCAic2V0VGhpY2tuZXNzRmFjdG9yIiwgImdldFRoaWNrbmVzc1RleHR1cmUiLCAiZ2V0VGhpY2tuZXNzVGV4dHVyZUluZm8iLCAic2V0VGhpY2tuZXNzVGV4dHVyZSIsICJnZXRBdHRlbnVhdGlvbkRpc3RhbmNlIiwgInNldEF0dGVudWF0aW9uRGlzdGFuY2UiLCAiZGlzdGFuY2UiLCAiZ2V0QXR0ZW51YXRpb25Db2xvciIsICJzZXRBdHRlbnVhdGlvbkNvbG9yIiwgImNyZWF0ZVZvbHVtZSIsICJ2b2x1bWUiLCAidm9sdW1lRGVmIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJfIiwgImNvbnRhaW5lciIsICJyZWFkS1RYIiwgInBpeGVsV2lkdGgiLCAicGl4ZWxIZWlnaHQiLCAiZGZkIiwgImRhdGFGb3JtYXREZXNjcmlwdG9yIiwgImNvbG9yTW9kZWwiLCAiS0hSX0RGX01PREVMX0VUQzFTIiwgInNhbXBsZXMiLCAiY2hhbm5lbFR5cGUiLCAiS0hSX0RGX01PREVMX1VBU1RDIiwgImdldFZSQU1CeXRlTGVuZ3RoIiwgImhhc0FscGhhIiwgInVuY29tcHJlc3NlZEJ5dGVzIiwgImxldmVscyIsICJsZXZlbCIsICJ1bmNvbXByZXNzZWRCeXRlTGVuZ3RoIiwgImxldmVsV2lkdGgiLCAiZmxvb3IiLCAicG93IiwgImxldmVsSGVpZ2h0IiwgImJsb2NrU2l6ZSIsICJiYXNpc3VEZWYiLCAiVEVYVFVSRV9JTkZPIiwgInRleENvb3JkIiwgImdldE9mZnNldCIsICJzZXRPZmZzZXQiLCAiZ2V0Um90YXRpb24iLCAic2V0Um90YXRpb24iLCAiZ2V0U2NhbGUiLCAic2V0U2NhbGUiLCAiZ2V0VGV4Q29vcmQiLCAic2V0VGV4Q29vcmQiLCAiY3JlYXRlVHJhbnNmb3JtIiwgInRleHR1cmVJbmZvcyIsICJlbnRyaWVzIiwgInRyYW5zZm9ybSIsICJ0cmFuc2Zvcm1EZWYiLCAidGV4dHVyZUluZm9FbnRyaWVzIiwgInRleHR1cmVJbmZvRGVmTWFwIiwgIlNDRU5FIiwgIkFOSU1BVElPTiIsICJnZXRDb250ZXh0IiwgInNldENvbnRleHQiLCAibGlzdFByb3BlcnRpZXMiLCAiZ2V0UHJvcGVydHkiLCAic2V0UHJvcGVydHkiLCAidmFsdWUiLCAiX2Fzc2VydENvbnRleHQiLCAidG9KU09OTEQiLCAiZnJvbUpTT05MRCIsICJqc29ubGQiLCAicHJlZml4IiwgInNwbGl0IiwgImNyZWF0ZVBhY2tldCIsICJsaXN0UGFja2V0cyIsICJfY29udGV4dCRqc29uRG9jJGpzb24iLCAiZXh0ZW5zaW9uRGVmIiwgInBhY2tldHMiLCAicm9vdCIsICJwYWNrZXREZWYiLCAiZGVmTGlzdHMiLCAiYXNzZXQiLCAic2NlbmVzIiwgImltYWdlcyIsICJhbmltYXRpb25zIiwgInByb3BlcnR5TGlzdHMiLCAibGlzdEFuaW1hdGlvbnMiLCAiZGVmcyIsICJkZWYiLCAieG1wRGVmIiwgInBhY2tldCIsICJwYWNrZXREZWZzIiwgInBhcmVudERlZiIsICJzY2VuZUluZGV4TWFwIiwgImFuaW1hdGlvbkluZGV4TWFwIiwgImluZGljZXMiLCAiY2xlYW51cCIsICJjbGVhbnVwIiwgIk1vZHVsZSIsICJyZXF1aXJlIiwgIm91dCIsICJNZXNoIiwgInJ1biIsICJlcnIiLCAidmFsdWUiLCAidHlwZUNvbnZlcnRlcnMiLCAiZmllbGRUeXBlcyIsICJoYW5kbGUiLCAiYXJnVHlwZXMiLCAibGVuZ3RoIiwgIndhc21FeHBvcnRzIiwgInNldFdhc21VcmwiLCAiY2xlYW51cCIsICJsZW5ndGgiLCAiY2xlYW51cCIsICJ1bmxpdCIsICJpbml0X2luZGV4X21vZGVybiIsICJjbGVhbnVwIiwgImdldE1hdGVyaWFsQnlJRCIsICJzaG93IiwgIk1lc2giLCAiZ2V0R0xURk5vZGVzIiwgIm9ubHkiLCAicmVzZXRHTFRGTm9kZXMiLCAic2V0TWF0ZXJpYWwiLCAic2hvdyIsICJ2YWx1ZSIsICJsZW5ndGgiLCAicmVzb2x2ZVVyaSIsICJzb3J0Q29tcGFyYXRvciIsICJfYSIsICJjb252ZXJ0IiwgImxvY2F0aW9uIiwgImJ1aWxkIiwgIl9hIiwgIl9iIiwgImkiLCAiZmwiLCAiX2EiLCAibm9kZXMiLCAiaW5pdF9pbmRleF9tb2Rlcm4iLCAiY2xlYW51cCIsICJsb2ciLCAiZ2V0TWF0ZXJpYWxCeUlEIiwgIm5vZGVzIiwgImxvZyIsICJsb2ciLCAiY2xlYW51cCIsICJub2RlcyIsICJzZXRXYXNtVXJsIl0KfQo=
